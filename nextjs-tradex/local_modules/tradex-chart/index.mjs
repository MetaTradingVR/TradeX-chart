const NAME = "TradeX-Chart";
const SHORTNAME = "TX";
const CLASS_UTILS = "tradeXutils";
const CLASS_MENUS = "tradeXmenus";
const CLASS_MENU = "tradeXmenu";
const CLASS_DIVIDERS = "tradeXdividers";
const CLASS_WINDOWS = "tradeXwindows";
const CLASS_WINDOW = "tradeXwindow";
const CLASS_PROGRESS = "tradeXprogress";
const RANGELIMIT = 500;
const STREAM_NONE = "stream_None";
const STREAM_LISTENING = "stream_Listening";
const STREAM_STARTED = "stream_Started";
const STREAM_STOPPED = "stream_Stopped";
const STREAM_ERROR = "stream_Error";
const STREAM_FIRSTVALUE = "stream_candleFirst";
const STREAM_UPDATE = "stream_candleUpdate";
const STREAM_NEWVALUE = "stream_candleNew";
const STREAM_MAXUPDATE = 250;
const STREAM_PRECISION = 8;
const PRICE_PRECISION = 2;
const VOLUME_PRECISION = 2;
const MAX_CRYPTO_PRECISION = 18;
const HIT_DEBOUNCE = 100;
const CSSUNITS = /^(\d*\.?\d+)\s?(px|em|ex|%|in|cn|mm|pt|pc+)$/igm;

let _hasOwnProperty = Object.prototype.hasOwnProperty;
function _get(obj, path, defaultValue = undefined) {
    const travel = regexp => String.prototype.split
        .call(path, regexp)
        .filter(Boolean)
        .reduce((res, key) => (res !== null && res !== undefined ? res[key] : res), obj);
    const result = travel(/[,[\]]+?/) || travel(/[,[\].]+?/);
    return result === undefined || result === obj ? defaultValue : result;
}
function _set(obj, path, value) {
    if (path.length === 0) {
        return undefined;
    }
    let res = obj;
    let last = path[path.length - 1];
    if (path.length === 1) {
        if (isObject(res)) {
            return res[last] = value;
        }
        return undefined;
    }
    for (let i = 0; i < path.length - 1; i++) {
        let key = path[i];
        if (!_hasOwnProperty.call(res, key) || !isObject(res[key])) {
            res[key] = {};
        }
        res = res[key];
    }
    return res[last] = value;
}
function getPrototypeAt(level, obj) {
    let proto = Object.getPrototypeOf(obj);
    while (level--)
        proto = Object.getPrototypeOf(proto);
    return proto;
}
function prototypeHas(prop, obj, level = 3) {
    if ((!isNumber(level)) || level < 1)
        level = 3;
    for (let i = level; i >= 0; i--) {
        let proto = getPrototypeAt(i, obj);
        if (!!proto[prop])
            return true;
    }
    return false;
}
function mergeDeep(target, source) {
    if (!isObject(target) || !isObject(source)) {
        return source;
    }
    Object.keys(source).forEach(key => {
        const targetValue = target[key];
        const sourceValue = source[key];
        if (isArray(targetValue) && isArray(sourceValue)) {
            target[key] = mergeDeep(targetValue.concat([]), (sourceValue));
        }
        else if (isObject(targetValue) && isObject(sourceValue)) {
            target[key] = mergeDeep(Object.assign({}, targetValue), sourceValue);
        }
        else {
            target[key] = sourceValue;
        }
    });
    return target;
}
function copyDeep(obj) {
    if (obj === null || typeof obj !== 'object')
        return obj;
    let temp;
    if (obj instanceof Date)
        temp = new obj.constructor();
    else
        temp = isArray(obj) ? [] : {};
    for (let key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) {
            if (typeof obj[key] !== "object" || obj[key] === obj)
                temp[key] = obj[key];
            else {
                temp[key] = copyDeep(obj[key]);
            }
        }
    }
    return temp;
}
function doStructuredClone(obj) {
    try {
        return structuredClone(obj);
    }
    catch (e) {
        return copyDeep(obj);
    }
}
function objToString(obj, ndeep) {
    if (obj == null) {
        return String(obj);
    }
    switch (typeof obj) {
        case "string": return '"' + obj + '"';
        case "function": return obj.toString();
        case "object":
            let indent = Array(ndeep || 1).join('\t'), isArray = Array.isArray(obj);
            return '{['[+isArray] + Object.keys(obj).map(function (key) {
                return '\n\t' + indent + key + ': ' + objToString(obj[key], (ndeep || 1) + 1);
            }).join(',') + '\n' + indent + '}]'[+isArray];
        default: return obj.toString();
    }
}
function objRecurse(obj, fn) {
    if (!isObject(obj))
        return;
    for (let k in obj) {
        if (typeof obj[k] === 'object' && obj[k] !== null) {
            objRecurse(obj[k], fn);
        }
        else if (obj.hasOwnProperty(k)) {
            fn(k, obj[k]);
        }
    }
}
const findInObjectById = (obj, id, updateFn) => {
    if (obj["Id"] === id) {
        return updateFn(obj);
    }
    else {
        for (let propertyName in obj) {
            if (obj[propertyName] !== null && typeof obj[propertyName] === 'object') {
                obj[propertyName] = findInObjectById(obj[propertyName], id, updateFn);
            }
        }
    }
    return obj;
};
function objRecurseUpdate(path, obj) {
    path.split(".");
}
function setProperty(obj, path, value) {
    const [head, ...rest] = path.split('.');
    return {
        ...obj,
        [head]: rest.length
            ? setProperty(obj[head], rest.join('.'), value)
            : value
    };
}
function getProperty(obj, path) {
    const keys = path.split(".");
    return keys.reduce((o, key) => (o && o[key] !== 'undefined') ? o[key] : undefined, obj);
}
class DoubleLinkedList {
    constructor() {
        this.nodes = [];
    }
    get size() {
        return this.nodes.length;
    }
    get head() {
        return this.size ? this.nodes[0] : null;
    }
    get tail() {
        return this.size ? this.nodes[this.size - 1] : null;
    }
    insertAt(index, value) {
        const previousNode = this.nodes[index - 1] || null;
        const nextNode = this.nodes[index] || null;
        const node = { value, next: nextNode, previous: previousNode };
        if (previousNode)
            previousNode.next = node;
        if (nextNode)
            nextNode.previous = node;
        this.nodes.splice(index, 0, node);
    }
    insertFirst(value) {
        this.insertAt(0, value);
    }
    insertLast(value) {
        this.insertAt(this.size, value);
    }
    getAt(index) {
        return this.nodes[index];
    }
    removeAt(index) {
        const previousNode = this.nodes[index - 1] || null;
        const nextNode = this.nodes[index + 1] || null;
        if (previousNode)
            previousNode.next = nextNode;
        if (nextNode)
            nextNode.previous = previousNode;
        return this.nodes.splice(index, 1);
    }
    clear() {
        this.nodes = [];
    }
    reverse() {
        this.nodes = this.nodes.reduce((acc, { value }) => {
            const nextNode = acc[0] || null;
            const node = { value, next: nextNode, previous: null };
            if (nextNode)
                nextNode.previous = node;
            return [node, ...acc];
        }, []);
    }
    *[Symbol.iterator]() {
        yield* this.nodes;
    }
}
function isArrayEqual(a1, a2) {
    if (!isArray(a1) || !isArray(a2))
        return false;
    if (a1.length !== a2.length)
        return false;
    let i = a1.length;
    while (i--) {
        if (isArray(a1[i]) || isArray(a2[i])) {
            if (!isArrayEqual(a1[i], a2[i]))
                return false;
            continue;
        }
        if (isObject(a1[i]) || isObject(a1[i])) {
            if (!isObjectEqual(a1[i], a2[i]))
                return false;
            continue;
        }
        if (a1[i] !== a2[i])
            return false;
    }
    return true;
}
function nearestArrayValue(x, array) {
    let minDist = Infinity;
    let minDistIndex = -1;
    let minValue = null;
    let i = 0;
    while (i++ < array.length) {
        let xi = array[i];
        let diff = Math.abs(xi - x);
        if (diff < minDist) {
            minDist = diff;
            minDistIndex = i;
            minValue = xi;
        }
    }
    return [minDistIndex, minValue];
}
function arrayMove(arr, fromIndex, toIndex) {
    let element = arr[fromIndex];
    arr.splice(fromIndex, 1);
    arr.splice(toIndex, 0, element);
}
function swapArrayElements(myArray, index1, index2) {
    [myArray[index1], myArray[index2]] = [myArray[index2], myArray[index1]];
}
function valuesInArray(values, arr) {
    if (!isArray(arr))
        return false;
    if (!isArray(values))
        return arr.includes(values);
    return values.every(value => {
        return arr.includes(value);
    });
}
const unique = (a) => [...new Set(a)];
const uniqueBy = (x, f) => Object.values(x.reduce((a, b) => ((a[f(b)] = b), a), {}));
const intersection = (a, b) => a.filter((v) => b.includes(v));
const diff = (a, b) => a.filter((v) => !b.includes(v));
const symDiff = (a, b) => diff(a, b).concat(diff(b, a));
const union = (a, b) => diff(a, b).concat(b);
function isObjectAndEmpty(obj) {
    if (!isObject(obj))
        return false;
    if (Object.keys.length)
        return false;
    return true;
}
function isObjectNotEmpty(obj) {
    if (!isObject(obj))
        return false;
    if (!Object.keys(obj).length)
        return false;
    else
        return true;
}
function isObjectEqual(obj1, obj2) {
    if (!isObject(obj1) || !isObject(obj2))
        return false;
    const obj1Keys = Object.keys(obj1).sort();
    const obj2Keys = Object.keys(obj2).sort();
    if (obj1Keys.length !== obj2Keys.length)
        return false;
    else {
        const areEqual = obj1Keys.every((key, index) => {
            const val1 = obj1[key];
            const val2 = obj2[obj2Keys[index]];
            if (isArray(val1) || isArray(val2))
                return isArrayEqual(val1, val2);
            if (isObject(val1) || isObject(val2))
                return isObjectEqual(val1, val2);
            return val1 === val2;
        });
        return areEqual;
    }
}
function uid(tag = "ID") {
    if (isNumber(tag))
        tag = tag.toString();
    else if (!isString(tag))
        tag = "ID";
    tag = idSanitize(tag);
    const dateString = Date.now().toString(36);
    const randomness = Math.random().toString(36).substring(2, 5);
    return `${tag}_${dateString}_${randomness}`;
}
function idSanitize(tag) {
    return String(tag).replace(/ |,|;|:|\.|#/g, "_");
}
function b64toBlob(b64Data, contentType, sliceSize) {
    contentType = contentType || '';
    sliceSize = sliceSize || 512;
    let byteCharacters = atob(b64Data);
    let byteArrays = [];
    for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
        let slice = byteCharacters.slice(offset, offset + sliceSize);
        let byteNumbers = new Array(slice.length);
        for (let i = 0; i < slice.length; i++) {
            byteNumbers[i] = slice.charCodeAt(i);
        }
        let byteArray = new Uint8Array(byteNumbers);
        byteArrays.push(byteArray);
    }
    let blob = new Blob(byteArrays, { type: contentType });
    return blob;
}
function replacer(key, value) {
    if (value instanceof Map) {
        return {
            dataType: 'Map',
            value: [...value.entries()],
        };
    }
    else {
        return value;
    }
}
function reviver(key, value) {
    if (typeof value === 'object' && value !== null) {
        if (value.dataType === 'Map') {
            return new Map(value.value);
        }
    }
    return value;
}
const firstEntryInMap = map => map.entries().next().value;
const firstKeyInMap = map => map.entries().next().value[0];
const firstValueInMap = map => map.entries().next().value[1];
const lastEntryInMap = map => [...map].pop();
const lastKeyInMap = map => [...map.keys()].pop();
const lastValueInMap = map => [...map.values()].pop();
class xMap extends Map {
    constructor(x) {
        super(x);
    }
    indexOfKey(key) {
        return [...this.keys()].indexOf(key);
    }
    indexOfValue(value) {
        return [...this.values()].indexOf(value);
    }
    entryAtIndex(index) {
        return [...this.entries()][index];
    }
    keyAtIndex(index) {
        return [...this.keys()][index];
    }
    valueAtIndex(index) {
        return [...this.values()][index];
    }
    insert(key, value, index) {
        return this.insertIndex(index, key, value);
    }
    remove(index) {
        return this.removeIndex(index);
    }
    firstEntry() {
        return firstEntryInMap(this);
    }
    firstKey() {
        return firstKeyInMap(this);
    }
    firstValue() {
        return firstValueInMap(this);
    }
    lastEntry() {
        return lastEntryInMap(this);
    }
    lastKey() {
        return lastKeyInMap(this);
    }
    lastValue() {
        return lastValueInMap(this);
    }
    prevCurrNext(key) {
        let prev = curr = next = null;
        for (let keyVal of this) {
            prev = curr;
            curr = keyVal;
            if (keyVal.key == key)
                break;
        }
        return { prev, curr, next };
    }
    union(...iterables) {
        if (typeof super.prototype.union === "function")
            super.union(...iterables);
        else {
            for (const iterable of iterables) {
                for (const item of iterable) {
                    this.set(...item);
                }
            }
        }
    }
    setMultiple(array) {
        if (!isArray(array))
            return false;
        array.forEach(([k, v]) => this.set(k, v));
        return true;
    }
    populate(array) {
        if (!isArray(array))
            return false;
        this.clear();
        array.forEach(([k, v]) => this.set(k, v));
        return true;
    }
    insertIndex(index, key, value) {
        if (!isNumber(index))
            return false;
        const arr = [...this];
        arr.splice(index, 0, [key, value]);
        this.populate(arr);
        return true;
    }
    removeIndex(index) {
        if (!isNumber(index))
            return false;
        const arr = [...this];
        arr.splice(index, 1);
        this.populate(arr);
        return true;
    }
    swapIndices(index1, index2) {
        if (!isNumber(index1) || !isNumber(index2))
            return false;
        const arr = [...this];
        swapArrayElements(arr, index1, index2);
        this.populate(arr);
        return true;
    }
    swapKeys(key1, key2) {
        const arr = [...this], indexA = arr.findIndex(([v]) => v === key1), indexB = arr.findIndex(([v]) => v === key2);
        [arr[indexA], arr[indexB]] = [arr[indexB], arr[indexA]];
        this.clear();
        arr.forEach(([k, v]) => this.set(k, v));
        return true;
    }
}
function debounce(fn, wait = 100, scope, immediate = false) {
    let timeout;
    return function () {
        let context = scope || this;
        let args = arguments;
        let later = function () {
            timeout = null;
            if (!immediate)
                fn.apply(context, args);
        };
        let callNow = immediate && !timeout;
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
        if (callNow)
            fn.apply(context, args);
    };
}
function throttle(fn, threshold = 250, scope) {
    let last, deferTimer;
    let core = function () {
        let context = scope || this;
        let now = new Date(), args = arguments;
        if (last && now < last + threshold) {
            clearTimeout(deferTimer);
            deferTimer = setTimeout(function () {
                last = now;
                fn.apply(context, args);
            }, threshold);
        }
        else {
            last = now;
            fn.apply(context, args);
        }
    };
    function cancelTimer() {
        if (timeout) {
            clearTimeout(deferTimer);
            timeout = undefined;
        }
    }
    core.reset = function () {
        cancelTimer();
        last = 0;
    };
    return core;
}
const extender = (baseClass, ...mixins) => {
    class base extends baseClass {
        constructor(...args) {
            super(...args);
            mixins.forEach((mixin) => {
                copyProps(this, (new mixin));
            });
        }
    }
    let copyProps = (target, source) => {
        Object.getOwnPropertyNames(source)
            .concat(Object.getOwnPropertySymbols(source))
            .forEach((prop) => {
            if (!prop.match(/^(?:constructor|prototype|arguments|caller|name|bind|call|apply|toString|length)$/))
                Object.defineProperty(target, prop, Object.getOwnPropertyDescriptor(source, prop));
        });
    };
    mixins.forEach((mixin) => {
        copyProps(base.prototype, mixin.prototype);
        copyProps(base, mixin);
    });
    return base;
};
function promiseState(p) {
    const t = {};
    return Promise.race([p, t])
        .then(v => (v === t) ? "pending" : "fulfilled", () => "rejected");
}
class Deferred {
    constructor() {
        this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
        });
    }
}
function ab2str(buf) {
    return String.fromCharCode.apply(null, new Uint16Array(buf));
}
function str2ab(str) {
    let buf = new ArrayBuffer(str.length * 2);
    let bufView = new Uint16Array(buf);
    for (let i = 0, strLen = str.length; i < strLen; i++) {
        bufView[i] = str.charCodeAt(i);
    }
    return buf;
}
function encodePNGDataStore(src) {
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d');
    let buffer;
    if (src.isView(src))
        buffer = src;
    else if (typeof src === "string")
        buffer = str2ab(src);
    const imgData = new Uint8ClampedArray.from(buffer);
    const len = imgData.length;
    canvas.height = 1;
    canvas.width = len;
    ctx.putImageData(imgData);
    const dataURL = ctx.toDataURL();
    const base64 = getBase64StringFromDataURL(dataURL);
    return { dataURL, base64 };
}
function decodePNGDataStore(src, cb, type = "string") {
    const img = new Image();
    const ctx = document.createElement('canvas').getContext('2d');
    img.src = src;
    return img.decode().then(() => {
        ctx.width = img.width;
        ctx.height = img.height;
        ctx.drawImage(img, 0, 0);
        const data = ctx.getImageData(0, 0, img.width, img.height).data;
        const result = (type === "string") ? ab2str(data) : data;
        cb(result);
    });
}
class EventHandlers {
    static #entries = new xMap();
    static get entries() { return EventHandlers.#entries; }
    static isValid(ctx, el, evt, fn) {
        return (!isObject(ctx) ||
            !isHTMLElement(el) ||
            !isString(evt) ||
            !isFunction(fn));
    }
    static add(ctx, el, evt, fn) {
        if (!this.isValid(ctx, el, evt, fn))
            return false;
        el.addEventListener(evt, fn);
        if (!EventHandlers.#entries.has(ctx))
            EventHandlers.#entries.set(ctx, new xMap());
        const entry = EventHandlers.#entries.get(ctx);
        if (!entry.has(el))
            entry.set(el, {});
        const elm = entry.get(el);
        if (!isArray(elm[evt]))
            elm[evt] = [];
        elm[evt].push(fn);
        return true;
    }
    static remove(ctx, el, evt, fn) {
        if (!EventHandlers.isValid(ctx, el, evt, fn) ||
            !EventHandlers.#entries.has(ctx))
            return false;
        const entry = EventHandlers.#entries.get(ctx);
        if (!entry.has(el))
            return false;
        const elm = entry.get(el);
        if (!(evt in elm))
            return false;
        const i = elm[evt].indexOf(fn);
        if (i < 0)
            return false;
        elm[evt].splice(i, 1);
        if (elm[evt].length == 0)
            delete elm[evt];
        if (Object.keys(elm).length == 0)
            entry.delete(el);
        if (entry.size == 0)
            EventHandlers.#entries.delete(ctx);
        return true;
    }
    static expungeEvent(ctx, el, evt) {
        if (!isObject(ctx) ||
            !isHTMLElement(el) ||
            !isString(evt))
            return false;
        const entry = EventHandlers.#entries.get(ctx);
        if (!entry.has(el))
            return false;
        const elm = entry.get(el);
        if ((evt in elm)) {
            for (let fn of elm[evt]) {
                el.removeEventListener(evt, fn);
            }
            delete elm[evt];
        }
        return true;
    }
    static expungeElement(ctx, el) {
        if (!isObject(ctx) ||
            !isHTMLElement(el))
            return false;
        const entry = EventHandlers.#entries.get(ctx);
        if (entry.has(el)) {
            let elm = entry.get(el);
            for (let evt in elm) {
                EventHandlers.expungeEvent(ctx, el, evt);
            }
            entry.delete(el);
        }
        return true;
    }
    static expungeContext(ctx) {
        if (!isObject(ctx))
            return false;
        if (EventHandlers.#entries.has(ctx)) {
            const entry = EventHandlers.#entries.get(ctx);
            for (let el of entry) {
                EventHandlers.expungeElement(ctx, el);
            }
            EventHandlers.#entries.delete(ctx);
        }
        return true;
    }
    static expungeAll() {
    }
    static destroy() {
        for (let ctx of EventHandlers.#entries) {
            EventHandlers.expungeContext(ctx);
        }
        EventHandlers.#entries = undefined;
        return true;
    }
}
async function HMAC(key, message) {
    const g = str => new Uint8Array([...decodeURIComponent(encodeURIComponent(str))].map(c => c.charCodeAt(0))), k = g(key), m = g(message), c = await crypto.subtle.importKey('raw', k, { name: 'HMAC', hash: 'SHA-256' }, true, ['sign']), s = await crypto.subtle.sign('HMAC', c, m);
    return btoa(String.fromCharCode(...new Uint8Array(s)));
}
async function H$1(m) {
    const msgUint8 = new TextEncoder().encode(m);
    const hashBuffer = await crypto.subtle.digest('SHA-256', msgUint8);
    const hashArray = Array.from(new Uint8Array(hashBuffer));
    const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
    return hashHex;
}
function cyrb53(str, seed = 0) {
    let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
    for (let i = 0, ch; i < str.length; i++) {
        ch = str.charCodeAt(i);
        h1 = Math.imul(h1 ^ ch, 2654435761);
        h2 = Math.imul(h2 ^ ch, 1597334677);
    }
    h1 = Math.imul(h1 ^ (h1 >>> 16), 2246822507);
    h1 ^= Math.imul(h2 ^ (h2 >>> 13), 3266489909);
    h2 = Math.imul(h2 ^ (h2 >>> 16), 2246822507);
    h2 ^= Math.imul(h1 ^ (h1 >>> 13), 3266489909);
    return (h2 >>> 0).toString(16).padStart(8, 0) + (h1 >>> 0).toString(16).padStart(8, 0);
}

var utilities = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Deferred: Deferred,
    DoubleLinkedList: DoubleLinkedList,
    EventHandlers: EventHandlers,
    H: H$1,
    HMAC: HMAC,
    _get: _get,
    _set: _set,
    ab2str: ab2str,
    arrayMove: arrayMove,
    b64toBlob: b64toBlob,
    copyDeep: copyDeep,
    cyrb53: cyrb53,
    debounce: debounce,
    decodePNGDataStore: decodePNGDataStore,
    diff: diff,
    doStructuredClone: doStructuredClone,
    encodePNGDataStore: encodePNGDataStore,
    extender: extender,
    findInObjectById: findInObjectById,
    firstEntryInMap: firstEntryInMap,
    firstKeyInMap: firstKeyInMap,
    firstValueInMap: firstValueInMap,
    getProperty: getProperty,
    getPrototypeAt: getPrototypeAt,
    idSanitize: idSanitize,
    intersection: intersection,
    isArrayEqual: isArrayEqual,
    isObjectAndEmpty: isObjectAndEmpty,
    isObjectEqual: isObjectEqual,
    isObjectNotEmpty: isObjectNotEmpty,
    lastEntryInMap: lastEntryInMap,
    lastKeyInMap: lastKeyInMap,
    lastValueInMap: lastValueInMap,
    mergeDeep: mergeDeep,
    nearestArrayValue: nearestArrayValue,
    objRecurse: objRecurse,
    objRecurseUpdate: objRecurseUpdate,
    objToString: objToString,
    promiseState: promiseState,
    prototypeHas: prototypeHas,
    replacer: replacer,
    reviver: reviver,
    setProperty: setProperty,
    str2ab: str2ab,
    swapArrayElements: swapArrayElements,
    symDiff: symDiff,
    throttle: throttle,
    uid: uid,
    union: union,
    unique: unique,
    uniqueBy: uniqueBy,
    valuesInArray: valuesInArray,
    xMap: xMap
});

function isArray(v) {
    return Array.isArray(v);
}
function isArrayOfType(v, t) {
    if (!isArray(v))
        return false;
    return v.every((n) => checkType(t, n));
}
function isFunction(v) {
    return v && typeof v === 'function';
}
function isAsyncFunction(v) {
    return isFunction(v) && Object.prototype.toString.call(v) === '[object AsyncFunction]';
}
function isObject(v) {
    return (typeof v === 'object' &&
        !Array.isArray(v) &&
        v !== null);
}
function isObjectOfTypes(target, types, equal) {
    if (!isObject(target) ||
        !isObject(types))
        return false;
    const k1 = Object.keys(target);
    const k2 = Object.keys(types);
    if (!!equal && !isArrayEqual(k1, k2))
        return false;
    for (let k of k2) {
        if (!checkType(types[k], target[k]))
            return false;
    }
    return true;
}
function isNumber(v) {
    return typeof v === 'number' && !isNaN(v);
}
function isInteger(v) {
    return (typeof v === 'number') && (Math.abs(v % 1) === 0);
}
function isValid(v) {
    return v !== null && v !== undefined;
}
function isBoolean(v) {
    return typeof v === 'boolean';
}
function isString(v) {
    return typeof v === 'string';
}
function isMap(v) {
    return v instanceof Map;
}
function isPromise(v) {
    return !!v && (isObject(v) || isFunction(v)) && isFunction(v.then) && v[Symbol.toStringTag] === 'Promise';
}
function isError(v) {
    return v instanceof Error;
}
function isClass(v) {
    if (!(v && v.constructor === Function) || v.prototype === undefined)
        return false;
    if (Object.getOwnPropertyNames(v).includes('arguments'))
        return false;
    if (Function.prototype !== Object.getPrototypeOf(v))
        return true;
    return Object.getOwnPropertyNames(v.prototype).length > 1;
}
const types = ["array", "error", "class", "function", "asyncfunction", "map", "promise",
    "object", "integer", "number", "boolean", "string"];
function checkType(type, value) {
    const t = [...types, 'valid'];
    if (value === undefined ||
        value === null ||
        !t.includes(type))
        return false;
    switch (type) {
        case 'array': return isArray(value);
        case 'asyncfunction': return isAsyncFunction(value);
        case 'function': return isFunction(value);
        case 'object': return isObject(value);
        case 'integer': return isInteger(value);
        case 'number': return isNumber(value);
        case 'valid': return isValid(value);
        case 'boolean': return isBoolean(value);
        case 'string': return isString(value);
        case 'map': return isMap(value);
        case 'promise': return isPromise(value);
        case 'error': return isError(value);
        case 'class': return isClass(value);
        default: throw new Error(`No known test for type: ${type}`);
    }
}
function typeOf(value) {
    for (let type of types) {
        try {
            if (checkType(type, value))
                return type;
        }
        catch (e) {
            return typeof value;
        }
    }
}

var typeChecks = /*#__PURE__*/Object.freeze({
    __proto__: null,
    checkType: checkType,
    isArray: isArray,
    isArrayOfType: isArrayOfType,
    isAsyncFunction: isAsyncFunction,
    isBoolean: isBoolean,
    isClass: isClass,
    isError: isError,
    isFunction: isFunction,
    isInteger: isInteger,
    isMap: isMap,
    isNumber: isNumber,
    isObject: isObject,
    isObjectOfTypes: isObjectOfTypes,
    isPromise: isPromise,
    isString: isString,
    isValid: isValid,
    typeOf: typeOf
});

const htmlAttr = ["id", "class", "style", "alt", "width", "height", "title"];
const inputAttr = [...htmlAttr, "name", "type", "value", "default", "placeholder", "max", "min", "maxlenght", "src", "checked", "disabled", "pattern", "readonly", "required", "size", "step", "multiple", "autofocus", "list", "autocomplete"];
const inputTypes = ["button", "color", "date", "datetime-local", "email", "file", "hidden", "image", "month", "number", "password", "radio", "range", "reset", "search", "submit", "tel", "text", "time", "url", "week",];
function findByID(id, base = document) {
    return base.getElementById(id);
}
function findByClass(cl, base = document) {
    return base.getElementsByClassName(cl);
}
function findByName(name, base = document) {
    return base.getElementsByName(name);
}
function fndByTag(tag, base = document) {
    return base.getElementsByTagName(tag);
}
function findBySelector(sel, base = document) {
    return base.querySelector(sel);
}
function findBySelectorAll(sel, base = document) {
    return base.querySelectorAll(sel);
}
function isNode(o) {
    return typeof Node === "object"
        ? o instanceof Node
        : o &&
            typeof o === "object" &&
            typeof o.nodeType === "number" &&
            typeof o.nodeName === "string";
}
function isHTMLElement(o) {
    return typeof HTMLElement === "object"
        ? o instanceof HTMLElement
        : o &&
            typeof o === "object" &&
            o !== null &&
            o.nodeType === 1 &&
            typeof o.nodeName === "string";
}
function isVisible(o) {
    if (!isHTMLElement(o))
        return false;
    return (!!o && !!(o.offsetWidth || o.offsetHeight || o.getClientRects().length));
}
function isInViewport(el) {
    if (!isHTMLElement(el))
        return false;
    const rect = el.getBoundingClientRect();
    return (rect.top >= 0 &&
        rect.left >= 0 &&
        rect.bottom <=
            (window.innerHeight || document.documentElement.clientHeight) &&
        rect.right <= (window.innerWidth || document.documentElement.clientWidth));
}
function isVisibleToUser(el) {
    if (!isHTMLElement(el))
        return false;
    const style = getComputedStyle(el);
    if (style.display === "none")
        return false;
    if (style.visibility !== "visible")
        return false;
    if (parseFloat(style.opacity) < 0.1)
        return false;
    if (el.offsetWidth +
        el.offsetHeight +
        el.getBoundingClientRect().height +
        el.getBoundingClientRect().width ===
        0) {
        return false;
    }
    const elCenter = {
        x: el.getBoundingClientRect().left + el.offsetWidth / 2,
        y: el.getBoundingClientRect().top + el.offsetHeight / 2,
    };
    if (elCenter.x < 0)
        return false;
    if (elCenter.x > (document.documentElement.clientWidth || window.innerWidth))
        return false;
    if (elCenter.y < 0)
        return false;
    if (elCenter.y > (document.documentElement.clientHeight || window.innerHeight))
        return false;
    let pointContainer = document.elementFromPoint(elCenter.x, elCenter.y);
    do {
        if (pointContainer === elem)
            return true;
    } while ((pointContainer = pointContainer.parentNode));
    return false;
}
function isImage(img, cb) {
    if (isSVG(img)) {
        var DOMURL = window.URL || window.webkitURL || window;
        img = new Blob([img], { type: "image/svg+xml" });
        img = DOMURL.createObjectURL(img);
    }
    const i = new Image();
    i.src = img;
    if (isFunction(cb)) {
        if (i.complete)
            cb(i);
        else {
            i.onload = () => cb(i);
            i.onerror = () => cb(false);
        }
    }
    else {
        return new Promise(function (resolve, reject) {
            if (i.complete)
                resolve(i);
            else {
                i.onload = () => resolve(i);
                i.onerror = () => reject(false);
            }
        });
    }
}
function isSVG(html) {
    if (!isString(html))
        return false;
    const svg = /<\s*svg[^>]*>(.*?)<\s*\/\s*svg>/;
    return svg.test(html);
}
function waitForElm(selector) {
    return new Promise((resolve) => {
        if (document.querySelector(selector)) {
            return resolve(document.querySelector(selector));
        }
        const observer = new MutationObserver((mutations) => {
            if (document.querySelector(selector)) {
                observer.disconnect();
                resolve(document.querySelector(selector));
            }
        });
        observer.observe(document.body, {
            childList: true,
            subtree: true,
        });
    });
}
function elementDimPos(el) {
    if (!isHTMLElement(el))
        return false;
    let _x = 0;
    let _y = 0;
    let El = el;
    while (El &&
        El.tagName.toLowerCase() != "body" &&
        !isNaN(El.offsetLeft) &&
        !isNaN(El.offsetTop)) {
        _x += El.offsetLeft - El.scrollLeft;
        _y += El.offsetTop - El.scrollTop;
        El = El.offsetParent;
    }
    const dim = el.getBoundingClientRect();
    let _w = dim.right - dim.left;
    let _h = dim.bottom - dim.top;
    let _v = isVisible(el);
    let _vp = isInViewport(el);
    return {
        top: _y,
        bottom: _y + _h,
        left: _x,
        right: _x + _w,
        width: _w,
        height: _h,
        visible: _v,
        viewport: _vp,
    };
}
function elementsDistance(el1, el2) {
    if (!isHTMLElement(el1) || !isHTMLElement(el1))
        return false;
    const el1Location = elementDimPos(el1);
    const el2Location = elementDimPos(el2);
    return {
        x: el1Location.top - el2Location.top,
        y: el1Location.left - el2Location.left,
        el1Location: el1Location,
        el2Location: el2Location,
    };
}
function htmlToElement(html) {
    if (!isString(html))
        return false;
    const template = document.createElement("template");
    html = html.trim();
    template.innerHTML = html;
    return template.content.firstChild;
}
function htmlToElements(html) {
    if (!isString(html))
        return false;
    const template = document.createElement("template");
    template.innerHTML = html;
    return template.content.childNodes;
}
function svgToImage(html, fill, dims) {
    if (!isSVG(html) || !isNumber(dims?.w) || !isNumber(dims?.h))
        return false;
    let w = dims.w;
    let h = dims.h;
    let canvas = document.createElement("canvas");
    canvas.width = w;
    canvas.height = h;
    let svg = htmlToElement(html);
    svg.style.fill = fill;
    svg.setAttribute("width", w);
    svg.setAttribute("height", h);
    svg.xmlns = "http://www.w3.org/2000/svg";
    let xml = new XMLSerializer().serializeToString(svg);
    let svg64 = btoa(xml);
    let b64Start = "data:image/svg+xml;base64,";
    let image64 = b64Start + svg64;
    let img = new Image();
    img.setAttribute("width", w);
    img.setAttribute("height", h);
    img.onload = () => {
        canvas.getContext("2d").drawImage(img, 0, 0, w, h);
    };
    img.src = image64;
    return img;
}
function hideOnClickOutside(el) {
    if (!isHTMLElement(el))
        return false;
    const outsideClickListener = (event) => {
        if (!el.contains(event.target) && isVisible(el)) {
            el.style.display = "none";
            removeClickListener();
        }
    };
    const removeClickListener = () => {
        document.removeEventListener("click", outsideClickListener);
    };
    document.addEventListener("click", outsideClickListener);
}
function onClickOutside(el, cb) {
    if (!isHTMLElement(el))
        return false;
    const outsideClickListener = (event) => {
        if (!el.contains(event.target) && isVisible(el)) {
            cb();
            removeClickListener();
        }
    };
    const removeClickListener = () => {
        document.removeEventListener("click", outsideClickListener);
    };
    document.addEventListener("click", outsideClickListener);
}
function getStyle(el, styleProp) {
    let x, y;
    if (isString(el))
        x = document.getElementById(el);
    else if (isHTMLElement(el))
        x = el;
    else
        return false;
    const defaultView = (x.ownerDocument || document).defaultView;
    if (!isString(styleProp))
        return false;
    if (defaultView && defaultView.getComputedStyle) {
        styleProp = styleProp.replace(/([A-Z])/g, "-$1").toLowerCase();
        y = document.defaultView
            .getComputedStyle(x, null)
            .getPropertyValue(styleProp);
    }
    else if (x.currentStyle)
        y = x.currentStyle[styleProp];
    return y;
}
function addStyleRule(styleSheet, selector, property, value) {
    let r = findStyleRule(styleSheet, selector, property, value);
    if (!r)
        return;
    else if (r.i >= 0) {
        r.rules[r.i].style[r.property] = r.value;
    }
    else {
        addCSSRule(r.styleSheet, r.selector, r.rules, r.index);
    }
}
function deleteStyleRule(styleSheet, selector, property) {
    let r = findStyleRule(styleSheet, selector, property, "");
    let deleteRule = r.styleSheet.deleteRule || r.styleSheet.removeRule;
    deleteRule(r.i);
}
function findStyleRule(styleSheet, selector, property, value) {
    if (!styleSheet || !isObject(styleSheet))
        return null;
    else if (styleSheet.constructor.name == "HTMLStyleElement")
        styleSheet = styleSheet.sheet;
    else if (styleSheet.constructor.name != "CSSStyleSheet")
        return null;
    let r = styleRuleSanitize(selector, property, value);
    selector = r[0];
    property = r[1];
    value = r[2];
    const rules = styleSheet.cssRules || styleSheet.rules;
    for (var i = rules.length - 1; i > 0; --i) {
        let rule = rules[i];
        if (rule.selectorText === selector) {
            break;
        }
    }
    return { styleSheet, rules, selector, property, value, i };
}
function styleRuleSanitize(selector, property, value) {
    return [
        (selector = selector.toLowerCase().replace(/\s+/g, " ")),
        (property = property.toLowerCase()),
        (value = value.toLowerCase()),
    ];
}
function addCSSRule(sheet, selector, rules, index) {
    if (sheet.insertRule) {
        sheet.insertRule(selector + "{" + rules + "}", index);
    }
    else {
        sheet.addRule(selector, rules, index);
    }
}
function findTargetParentWithClass(el, selector) {
    if (!isHTMLElement(el) || !isString(selector))
        return null;
    if (el.classList.contains(selector))
        return el;
    else
        return findTargetParentWithClass(el.parentElement, selector);
}
function htmlInput(i, o) {
    let id = (isString(o?.entry)) ? o?.entry : "";
    let label = (isString(i)) ? `<label for="${id}">${i}</label>` : ``;
    let input = `${label}<input id="${id}" class="subject" `;
    for (let p in o) {
        if (inputAttr.includes(p) ||
            /^(data-[^\t\n\f \/>"'=]+)/g.test(p)) {
            input += `${p}="${o[p]}" `;
        }
    }
    return input += `>\n`;
}
function htmlSelect(i, o) {
    let id = (isString(o?.entry)) ? o?.entry : "";
    let label = (isString(i)) ? `<label for="${id}">${i}</label>` : ``;
    let options = "";
    for (let opt in o?.options) {
        options += `<option value="${o.options[opt]}">${opt}</option>`;
    }
    let input = `${label}<select id="${id}" class="subject">${options}</select>\n`;
    return input;
}
function blobToDataURL(blob) {
    return new Promise((resolve) => {
        let reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.readAsDataURL(blob);
    });
}
var DOM = {
    addCSSRule,
    addStyleRule,
    blobToDataURL,
    deleteStyleRule,
    elementDimPos,
    elementsDistance,
    findByClass,
    findByID,
    findByName,
    findBySelector,
    findBySelectorAll,
    findStyleRule,
    findTargetParentWithClass,
    fndByTag,
    getStyle,
    hideOnClickOutside,
    htmlAttr,
    htmlInput,
    htmlToElement,
    htmlToElements,
    inputAttr,
    inputTypes,
    isHTMLElement,
    isImage,
    isInViewport,
    isNode,
    isSVG,
    isVisible,
    isVisibleToUser,
    onClickOutside,
    styleRuleSanitize,
    svgToImage,
    waitForElm
};

const isBrowser = typeof window !== 'undefined' &&
    typeof window.document !== 'undefined';
typeof process !== 'undefined' &&
    process.versions != null &&
    process.versions.node != null;
(typeof window !== 'undefined' && window.name === 'nodejs') ||
    (typeof navigator !== 'undefined' &&
        (navigator.userAgent.includes('Node.js') ||
            navigator.userAgent.includes('jsdom')));
const isTouchDevice = (w => typeof w !== 'undefined' && ('onorientationchange' in w ||
    (typeof w.matchMedia === 'function' && w.matchMedia("(any-pointer:coarse)").matches) ||
    (typeof navigator !== 'undefined' && (navigator.maxTouchPoints > 0 ||
        navigator.msMaxTouchPoints > 0 ||
        'ontouchstart' in w ||
        (w.DocumentTouch && document instanceof w.DocumentTouch)))))(typeof window !== 'undefined' ? window : {});

const status = {
    idle: 0,
    dragStart: 1,
    dragging: 2
};
class Point {
    #x = 0;
    #y = 0;
    constructor() {
        if (arguments.length === 1) {
            const { x, y } = arguments[0];
            this.x = x || 0;
            this.y = y || 0;
        }
        else if (arguments.length > 1) {
            const [x, y] = arguments;
            this.x = x || 0;
            this.y = y || 0;
        }
    }
    set x(x) { if (isNumber(x))
        this.#x = x; }
    get x() { return this.#x; }
    set y(y) { if (isNumber(y))
        this.#y = y; }
    get y() { return this.#y; }
    clone() {
        return new Point(this.x, this.y);
    }
}

// Hammer.Manager mock for use in environments without `document` / `window`.
class HammerManagerMock {
    constructor() {
        this.get = () => null;
        this.set = () => this;
        this.on = () => this;
        this.off = () => this;
        this.destroy = () => this;
        this.emit = () => this;
    }
}
const Manager = HammerManagerMock;

let Input$1 = class Input {
    constructor(element, callback, options) {
        this.element = element;
        this.callback = callback;
        this.options = { enable: true, ...options };
    }
};

// This module contains constants that must be conditionally required
// due to `window`/`document` references downstream.
const RECOGNIZERS = null;
// Recognize the following gestures even if a given recognizer succeeds
const RECOGNIZER_COMPATIBLE_MAP = {
    tripan: ['rotate', 'pinch', 'pan'],
    rotate: ['pinch'],
    pinch: ['pan'],
    pan: ['press', 'doubletap', 'anytap', 'tap'],
    doubletap: ['anytap'],
    anytap: ['tap']
};
// Recognize the folling gestures only if a given recognizer fails
const RECOGNIZER_FALLBACK_MAP = {
    doubletap: ['tap']
};
/**
 * Only one set of basic input events will be fired by Hammer.js:
 * either pointer, touch, or mouse, depending on system support.
 * In order to enable an application to be agnostic of system support,
 * alias basic input events into "classes" of events: down, move, and up.
 * See `_onBasicInput()` for usage of these aliases.
 */
const BASIC_EVENT_ALIASES = {
    pointerdown: 'pointerdown',
    pointermove: 'pointermove',
    pointerup: 'pointerup',
    touchstart: 'pointerdown',
    touchmove: 'pointermove',
    touchend: 'pointerup',
    mousedown: 'pointerdown',
    mousemove: 'pointermove',
    mouseup: 'pointerup'
};
const INPUT_EVENT_TYPES = {
    KEY_EVENTS: ['keydown', 'keyup'],
    MOUSE_EVENTS: ['mousedown', 'mousemove', 'mouseup', 'mouseover', 'mouseout', 'mouseleave'],
    WHEEL_EVENTS: [
        // Chrome, Safari
        'wheel',
        // IE
        'mousewheel'
    ]
};
/**
 * "Gestural" events are those that have semantic meaning beyond the basic input event,
 * e.g. a click or tap is a sequence of `down` and `up` events with no `move` event in between.
 * Hammer.js handles these with its Recognizer system;
 * this block maps event names to the Recognizers required to detect the events.
 */
const EVENT_RECOGNIZER_MAP = {
    tap: 'tap',
    anytap: 'anytap',
    doubletap: 'doubletap',
    press: 'press',
    pinch: 'pinch',
    pinchin: 'pinch',
    pinchout: 'pinch',
    pinchstart: 'pinch',
    pinchmove: 'pinch',
    pinchend: 'pinch',
    pinchcancel: 'pinch',
    rotate: 'rotate',
    rotatestart: 'rotate',
    rotatemove: 'rotate',
    rotateend: 'rotate',
    rotatecancel: 'rotate',
    tripan: 'tripan',
    tripanstart: 'tripan',
    tripanmove: 'tripan',
    tripanup: 'tripan',
    tripandown: 'tripan',
    tripanleft: 'tripan',
    tripanright: 'tripan',
    tripanend: 'tripan',
    tripancancel: 'tripan',
    pan: 'pan',
    panstart: 'pan',
    panmove: 'pan',
    panup: 'pan',
    pandown: 'pan',
    panleft: 'pan',
    panright: 'pan',
    panend: 'pan',
    pancancel: 'pan',
    swipe: 'swipe',
    swipeleft: 'swipe',
    swiperight: 'swipe',
    swipeup: 'swipe',
    swipedown: 'swipe'
};
/**
 * Map gestural events typically provided by browsers
 * that are not reported in 'hammer.input' events
 * to corresponding Hammer.js gestures.
 */
const GESTURE_EVENT_ALIASES = {
    click: 'tap',
    anyclick: 'anytap',
    dblclick: 'doubletap',
    mousedown: 'pointerdown',
    mousemove: 'pointermove',
    mouseup: 'pointerup',
    mouseover: 'pointerover',
    mouseout: 'pointerout',
    mouseleave: 'pointerleave'
};

// Purpose: include this in your module to avoids adding dependencies on
// micro modules like 'global'
/* global window, global, document, navigator */
const userAgent = typeof navigator !== 'undefined' && navigator.userAgent ? navigator.userAgent.toLowerCase() : '';
const window_ = typeof window !== 'undefined' ? window : global;
/*
 * Detect whether passive option is supported by the current browser.
 * https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener
   #Safely_detecting_option_support
 */
let passiveSupported = false;
/* eslint-disable accessor-pairs, no-empty */
try {
    const options = {
        // This function will be called when the browser
        // attempts to access the passive property.
        get passive() {
            passiveSupported = true;
            return true;
        }
    };
    window_.addEventListener('test', null, options);
    window_.removeEventListener('test', null);
}
catch (err) {
    passiveSupported = false;
}

const firefox = userAgent.indexOf('firefox') !== -1;
const { WHEEL_EVENTS } = INPUT_EVENT_TYPES;
const EVENT_TYPE$1 = 'wheel';
// Constants for normalizing input delta
const WHEEL_DELTA_MAGIC_SCALER = 4.000244140625;
const WHEEL_DELTA_PER_LINE = 40;
// Slow down zoom if shift key is held for more precise zooming
const SHIFT_MULTIPLIER = 0.25;
class WheelInput extends Input$1 {
    constructor(element, callback, options) {
        super(element, callback, options);
        /* eslint-disable complexity, max-statements */
        this.handleEvent = (event) => {
            if (!this.options.enable) {
                return;
            }
            let value = event.deltaY;
            if (window_.WheelEvent) {
                // Firefox doubles the values on retina screens...
                if (firefox && event.deltaMode === window_.WheelEvent.DOM_DELTA_PIXEL) {
                    value /= window_.devicePixelRatio;
                }
                if (event.deltaMode === window_.WheelEvent.DOM_DELTA_LINE) {
                    value *= WHEEL_DELTA_PER_LINE;
                }
            }
            if (value !== 0 && value % WHEEL_DELTA_MAGIC_SCALER === 0) {
                // This one is definitely a mouse wheel event.
                // Normalize this value to match trackpad.
                value = Math.floor(value / WHEEL_DELTA_MAGIC_SCALER);
            }
            if (event.shiftKey && value) {
                value = value * SHIFT_MULTIPLIER;
            }
            this.callback({
                type: EVENT_TYPE$1,
                center: {
                    x: event.clientX,
                    y: event.clientY
                },
                delta: -value,
                srcEvent: event,
                pointerType: 'mouse',
                target: event.target
            });
        };
        this.events = (this.options.events || []).concat(WHEEL_EVENTS);
        this.events.forEach(event => element.addEventListener(event, this.handleEvent, passiveSupported ? { passive: false } : false));
    }
    destroy() {
        this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */
    enableEventType(eventType, enabled) {
        if (eventType === EVENT_TYPE$1) {
            this.options.enable = enabled;
        }
    }
}

const { MOUSE_EVENTS: MOUSE_EVENTS$1 } = INPUT_EVENT_TYPES;
const MOVE_EVENT_TYPE = 'pointermove';
const OVER_EVENT_TYPE = 'pointerover';
const OUT_EVENT_TYPE = 'pointerout';
const ENTER_EVENT_TYPE = 'pointerenter';
const LEAVE_EVENT_TYPE = 'pointerleave';
/**
 * Hammer.js swallows 'move' events (for pointer/touch/mouse)
 * when the pointer is not down. This class sets up a handler
 * specifically for these events to work around this limitation.
 * Note that this could be extended to more intelligently handle
 * move events across input types, e.g. storing multiple simultaneous
 * pointer/touch events, calculating speed/direction, etc.
 */
class MoveInput extends Input$1 {
    constructor(element, callback, options) {
        super(element, callback, options);
        this.handleEvent = (event) => {
            this.handleOverEvent(event);
            this.handleOutEvent(event);
            this.handleEnterEvent(event);
            this.handleLeaveEvent(event);
            this.handleMoveEvent(event);
        };
        this.pressed = false;
        const { enable } = this.options;
        this.enableMoveEvent = enable;
        this.enableLeaveEvent = enable;
        this.enableEnterEvent = enable;
        this.enableOutEvent = enable;
        this.enableOverEvent = enable;
        this.events = (this.options.events || []).concat(MOUSE_EVENTS$1);
        this.events.forEach(event => element.addEventListener(event, this.handleEvent));
    }
    destroy() {
        this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */
    enableEventType(eventType, enabled) {
        if (eventType === MOVE_EVENT_TYPE) {
            this.enableMoveEvent = enabled;
        }
        if (eventType === OVER_EVENT_TYPE) {
            this.enableOverEvent = enabled;
        }
        if (eventType === OUT_EVENT_TYPE) {
            this.enableOutEvent = enabled;
        }
        if (eventType === ENTER_EVENT_TYPE) {
            this.enableEnterEvent = enabled;
        }
        if (eventType === LEAVE_EVENT_TYPE) {
            this.enableLeaveEvent = enabled;
        }
    }
    handleOverEvent(event) {
        if (this.enableOverEvent) {
            if (event.type === 'mouseover') {
                this._emit(OVER_EVENT_TYPE, event);
            }
        }
    }
    handleOutEvent(event) {
        if (this.enableOutEvent) {
            if (event.type === 'mouseout') {
                this._emit(OUT_EVENT_TYPE, event);
            }
        }
    }
    handleEnterEvent(event) {
        if (this.enableEnterEvent) {
            if (event.type === 'mouseenter') {
                this._emit(ENTER_EVENT_TYPE, event);
            }
        }
    }
    handleLeaveEvent(event) {
        if (this.enableLeaveEvent) {
            if (event.type === 'mouseleave') {
                this._emit(LEAVE_EVENT_TYPE, event);
            }
        }
    }
    handleMoveEvent(event) {
        if (this.enableMoveEvent) {
            switch (event.type) {
                case 'mousedown':
                    if (event.button >= 0) {
                        // Button is down
                        this.pressed = true;
                    }
                    break;
                case 'mousemove':
                    // Move events use `bottons` to track the button being pressed
                    if (event.buttons === 0) {
                        // Button is not down
                        this.pressed = false;
                    }
                    if (!this.pressed) {
                        // Drag events are emitted by hammer already
                        // we just need to emit the move event on hover
                        this._emit(MOVE_EVENT_TYPE, event);
                    }
                    break;
                case 'mouseup':
                    this.pressed = false;
                    break;
            }
        }
    }
    _emit(type, event) {
        this.callback({
            type,
            center: {
                x: event.clientX,
                y: event.clientY
            },
            srcEvent: event,
            pointerType: 'mouse',
            target: event.target
        });
    }
}

const { KEY_EVENTS } = INPUT_EVENT_TYPES;
const DOWN_EVENT_TYPE = 'keydown';
const UP_EVENT_TYPE = 'keyup';
class KeyInput extends Input$1 {
    constructor(element, callback, options) {
        super(element, callback, options);
        this.handleEvent = (event) => {
            // Ignore if focused on text input
            const targetElement = (event.target || event.srcElement);
            if ((targetElement.tagName === 'INPUT' && targetElement.type === 'text') ||
                targetElement.tagName === 'TEXTAREA') {
                return;
            }
            if (this.enableDownEvent && event.type === 'keydown') {
                this.callback({
                    type: DOWN_EVENT_TYPE,
                    srcEvent: event,
                    key: event.key,
                    target: event.target
                });
            }
            if (this.enableUpEvent && event.type === 'keyup') {
                this.callback({
                    type: UP_EVENT_TYPE,
                    srcEvent: event,
                    key: event.key,
                    target: event.target
                });
            }
        };
        this.enableDownEvent = this.options.enable;
        this.enableUpEvent = this.options.enable;
        this.events = (this.options.events || []).concat(KEY_EVENTS);
        element.tabIndex = this.options.tabIndex || 0;
        element.style.outline = 'none';
        this.events.forEach(event => element.addEventListener(event, this.handleEvent));
    }
    destroy() {
        this.events.forEach(event => this.element.removeEventListener(event, this.handleEvent));
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */
    enableEventType(eventType, enabled) {
        if (eventType === DOWN_EVENT_TYPE) {
            this.enableDownEvent = enabled;
        }
        if (eventType === UP_EVENT_TYPE) {
            this.enableUpEvent = enabled;
        }
    }
}

const EVENT_TYPE = 'contextmenu';
class ContextmenuInput extends Input$1 {
    constructor(element, callback, options) {
        super(element, callback, options);
        this.handleEvent = (event) => {
            if (!this.options.enable) {
                return;
            }
            this.callback({
                type: EVENT_TYPE,
                center: {
                    x: event.clientX,
                    y: event.clientY
                },
                srcEvent: event,
                pointerType: 'mouse',
                target: event.target
            });
        };
        element.addEventListener('contextmenu', this.handleEvent);
    }
    destroy() {
        this.element.removeEventListener('contextmenu', this.handleEvent);
    }
    /**
     * Enable this input (begin processing events)
     * if the specified event type is among those handled by this input.
     */
    enableEventType(eventType, enabled) {
        if (eventType === EVENT_TYPE) {
            this.options.enable = enabled;
        }
    }
}

/* Constants */
const DOWN_EVENT = 1;
const MOVE_EVENT = 2;
const UP_EVENT = 4;
const MOUSE_EVENTS = {
    pointerdown: DOWN_EVENT,
    pointermove: MOVE_EVENT,
    pointerup: UP_EVENT,
    mousedown: DOWN_EVENT,
    mousemove: MOVE_EVENT,
    mouseup: UP_EVENT
};
// MouseEvent.button https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/button
const MOUSE_EVENT_BUTTON_LEFT = 0;
const MOUSE_EVENT_BUTTON_MIDDLE = 1;
const MOUSE_EVENT_BUTTON_RIGHT = 2;
// MouseEvent.buttons https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/buttons
const MOUSE_EVENT_BUTTONS_LEFT_MASK = 1;
const MOUSE_EVENT_BUTTONS_RIGHT_MASK = 2;
const MOUSE_EVENT_BUTTONS_MIDDLE_MASK = 4;
/**
 * Extract the involved mouse button
 */
function whichButtons(event) {
    const eventType = MOUSE_EVENTS[event.srcEvent.type];
    if (!eventType) {
        // Not a mouse evet
        return null;
    }
    const { buttons, button } = event.srcEvent;
    let leftButton = false;
    let middleButton = false;
    let rightButton = false;
    if (eventType === MOVE_EVENT) {
        leftButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_LEFT_MASK);
        middleButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_MIDDLE_MASK);
        rightButton = Boolean(buttons & MOUSE_EVENT_BUTTONS_RIGHT_MASK);
    }
    else {
        leftButton = button === MOUSE_EVENT_BUTTON_LEFT;
        middleButton = button === MOUSE_EVENT_BUTTON_MIDDLE;
        rightButton = button === MOUSE_EVENT_BUTTON_RIGHT;
    }
    return { leftButton, middleButton, rightButton };
}
/**
 * Calculate event position relative to the root element
 */
function getOffsetPosition(event, rootElement) {
    const center = event.center;
    // `center` is a hammer.js event property
    if (!center) {
        // Not a gestural event
        return null;
    }
    const rect = rootElement.getBoundingClientRect();
    // Fix scale for map affected by a CSS transform.
    // See https://stackoverflow.com/a/26893663/3528533
    const scaleX = rect.width / rootElement.offsetWidth || 1;
    const scaleY = rect.height / rootElement.offsetHeight || 1;
    // Calculate center relative to the root element
    const offsetCenter = {
        x: (center.x - rect.left - rootElement.clientLeft) / scaleX,
        y: (center.y - rect.top - rootElement.clientTop) / scaleY
    };
    return { center, offsetCenter };
}

const DEFAULT_OPTIONS$1 = {
    srcElement: 'root',
    priority: 0
};
class EventRegistrar {
    constructor(eventManager) {
        /**
         * Handles hammerjs event
         */
        this.handleEvent = (event) => {
            if (this.isEmpty()) {
                return;
            }
            const mjolnirEvent = this._normalizeEvent(event);
            let target = event.srcEvent.target;
            while (target && target !== mjolnirEvent.rootElement) {
                this._emit(mjolnirEvent, target);
                if (mjolnirEvent.handled) {
                    return;
                }
                target = target.parentNode;
            }
            this._emit(mjolnirEvent, 'root');
        };
        this.eventManager = eventManager;
        this.handlers = [];
        // Element -> handler map
        this.handlersByElement = new Map();
        this._active = false;
    }
    // Returns true if there are no non-passive handlers
    isEmpty() {
        return !this._active;
    }
    add(type, handler, options, once = false, passive = false) {
        const { handlers, handlersByElement } = this;
        let opts = DEFAULT_OPTIONS$1;
        if (typeof options === 'string' || (options && options.addEventListener)) {
            // is DOM element, backward compatibility
            // @ts-ignore
            opts = { ...DEFAULT_OPTIONS$1, srcElement: options };
        }
        else if (options) {
            opts = { ...DEFAULT_OPTIONS$1, ...options };
        }
        let entries = handlersByElement.get(opts.srcElement);
        if (!entries) {
            entries = [];
            handlersByElement.set(opts.srcElement, entries);
        }
        const entry = {
            type,
            handler,
            srcElement: opts.srcElement,
            priority: opts.priority
        };
        if (once) {
            entry.once = true;
        }
        if (passive) {
            entry.passive = true;
        }
        handlers.push(entry);
        this._active = this._active || !entry.passive;
        // Sort handlers by descending priority
        // Handlers with the same priority are excuted in the order of registration
        let insertPosition = entries.length - 1;
        while (insertPosition >= 0) {
            if (entries[insertPosition].priority >= entry.priority) {
                break;
            }
            insertPosition--;
        }
        entries.splice(insertPosition + 1, 0, entry);
    }
    remove(type, handler) {
        const { handlers, handlersByElement } = this;
        for (let i = handlers.length - 1; i >= 0; i--) {
            const entry = handlers[i];
            if (entry.type === type && entry.handler === handler) {
                handlers.splice(i, 1);
                const entries = handlersByElement.get(entry.srcElement);
                entries.splice(entries.indexOf(entry), 1);
                if (entries.length === 0) {
                    handlersByElement.delete(entry.srcElement);
                }
            }
        }
        this._active = handlers.some(entry => !entry.passive);
    }
    /**
     * Invoke handlers on a particular element
     */
    _emit(event, srcElement) {
        const entries = this.handlersByElement.get(srcElement);
        if (entries) {
            let immediatePropagationStopped = false;
            // Prevents the current event from bubbling up
            const stopPropagation = () => {
                event.handled = true;
            };
            // Prevent any remaining listeners from being called
            const stopImmediatePropagation = () => {
                event.handled = true;
                immediatePropagationStopped = true;
            };
            const entriesToRemove = [];
            for (let i = 0; i < entries.length; i++) {
                const { type, handler, once } = entries[i];
                handler({
                    ...event,
                    // @ts-ignore
                    type,
                    stopPropagation,
                    stopImmediatePropagation
                });
                if (once) {
                    entriesToRemove.push(entries[i]);
                }
                if (immediatePropagationStopped) {
                    break;
                }
            }
            for (let i = 0; i < entriesToRemove.length; i++) {
                const { type, handler } = entriesToRemove[i];
                this.remove(type, handler);
            }
        }
    }
    /**
     * Normalizes hammerjs and custom events to have predictable fields.
     */
    _normalizeEvent(event) {
        const rootElement = this.eventManager.getElement();
        return {
            ...event,
            ...whichButtons(event),
            ...getOffsetPosition(event, rootElement),
            preventDefault: () => {
                event.srcEvent.preventDefault();
            },
            stopImmediatePropagation: null,
            stopPropagation: null,
            handled: false,
            rootElement
        };
    }
}

const DEFAULT_OPTIONS = {
    // event handlers
    events: null,
    // custom recognizers
    recognizers: null,
    recognizerOptions: {},
    // Manager class
    Manager,
    // allow browser default touch action
    // https://github.com/uber/react-map-gl/issues/506
    touchAction: 'none',
    tabIndex: 0
};
// Unified API for subscribing to events about both
// basic input events (e.g. 'mousemove', 'touchstart', 'wheel')
// and gestural input (e.g. 'click', 'tap', 'panstart').
// Delegates gesture related event registration and handling to Hammer.js.
class EventManager {
    constructor(element = null, options) {
        /**
         * Handle basic events using the 'hammer.input' Hammer.js API:
         * Before running Recognizers, Hammer emits a 'hammer.input' event
         * with the basic event info. This function emits all basic events
         * aliased to the "class" of event received.
         * See constants.BASIC_EVENT_CLASSES basic event class definitions.
         */
        this._onBasicInput = (event) => {
            const { srcEvent } = event;
            const alias = BASIC_EVENT_ALIASES[srcEvent.type];
            if (alias) {
                // fire all events aliased to srcEvent.type
                this.manager.emit(alias, event);
            }
        };
        /**
         * Handle events not supported by Hammer.js,
         * and pipe back out through same (Hammer) channel used by other events.
         */
        this._onOtherEvent = (event) => {
            // console.log('onotherevent', event.type, event)
            this.manager.emit(event.type, event);
        };
        this.options = { ...DEFAULT_OPTIONS, ...options };
        this.events = new Map();
        this.setElement(element);
        // Register all passed events.
        const { events } = this.options;
        if (events) {
            this.on(events);
        }
    }
    getElement() {
        return this.element;
    }
    setElement(element) {
        if (this.element) {
            // unregister all events
            this.destroy();
        }
        this.element = element;
        if (!element) {
            return;
        }
        const { options } = this;
        const ManagerClass = options.Manager;
        this.manager = new ManagerClass(element, {
            touchAction: options.touchAction,
            recognizers: options.recognizers || RECOGNIZERS
        }).on('hammer.input', this._onBasicInput);
        if (!options.recognizers) {
            // Set default recognize withs
            // http://hammerjs.github.io/recognize-with/
            Object.keys(RECOGNIZER_COMPATIBLE_MAP).forEach(name => {
                const recognizer = this.manager.get(name);
                if (recognizer) {
                    RECOGNIZER_COMPATIBLE_MAP[name].forEach(otherName => {
                        recognizer.recognizeWith(otherName);
                    });
                }
            });
        }
        // Set recognizer options
        for (const recognizerName in options.recognizerOptions) {
            const recognizer = this.manager.get(recognizerName);
            if (recognizer) {
                const recognizerOption = options.recognizerOptions[recognizerName];
                // `enable` is managed by the event registrations
                delete recognizerOption.enable;
                recognizer.set(recognizerOption);
            }
        }
        // Handle events not handled by Hammer.js:
        // - mouse wheel
        // - pointer/touch/mouse move
        this.wheelInput = new WheelInput(element, this._onOtherEvent, {
            enable: false
        });
        this.moveInput = new MoveInput(element, this._onOtherEvent, {
            enable: false
        });
        this.keyInput = new KeyInput(element, this._onOtherEvent, {
            enable: false,
            tabIndex: options.tabIndex
        });
        this.contextmenuInput = new ContextmenuInput(element, this._onOtherEvent, {
            enable: false
        });
        // Register all existing events
        for (const [eventAlias, eventRegistrar] of this.events) {
            if (!eventRegistrar.isEmpty()) {
                // Enable recognizer for this event.
                this._toggleRecognizer(eventRegistrar.recognizerName, true);
                this.manager.on(eventAlias, eventRegistrar.handleEvent);
            }
        }
    }
    // Tear down internal event management implementations.
    destroy() {
        if (this.element) {
            // wheelInput etc. are created in setElement() and therefore
            // cannot exist if there is no element
            this.wheelInput.destroy();
            this.moveInput.destroy();
            this.keyInput.destroy();
            this.contextmenuInput.destroy();
            this.manager.destroy();
            this.wheelInput = null;
            this.moveInput = null;
            this.keyInput = null;
            this.contextmenuInput = null;
            this.manager = null;
            this.element = null;
        }
    }
    /** Register an event handler function to be called on `event` */
    on(event, handler, opts) {
        this._addEventHandler(event, handler, opts, false);
    }
    once(event, handler, opts) {
        this._addEventHandler(event, handler, opts, true);
    }
    watch(event, handler, opts) {
        this._addEventHandler(event, handler, opts, false, true);
    }
    off(event, handler) {
        this._removeEventHandler(event, handler);
    }
    /*
     * Enable/disable recognizer for the given event
     */
    _toggleRecognizer(name, enabled) {
        const { manager } = this;
        if (!manager) {
            return;
        }
        const recognizer = manager.get(name);
        // @ts-ignore
        if (recognizer && recognizer.options.enable !== enabled) {
            recognizer.set({ enable: enabled });
            const fallbackRecognizers = RECOGNIZER_FALLBACK_MAP[name];
            if (fallbackRecognizers && !this.options.recognizers) {
                // Set default require failures
                // http://hammerjs.github.io/require-failure/
                fallbackRecognizers.forEach(otherName => {
                    const otherRecognizer = manager.get(otherName);
                    if (enabled) {
                        // Wait for this recognizer to fail
                        otherRecognizer.requireFailure(name);
                        /**
                         * This seems to be a bug in hammerjs:
                         * requireFailure() adds both ways
                         * dropRequireFailure() only drops one way
                         * https://github.com/hammerjs/hammer.js/blob/master/src/recognizerjs/
                           recognizer-constructor.js#L136
                         */
                        recognizer.dropRequireFailure(otherName);
                    }
                    else {
                        // Do not wait for this recognizer to fail
                        otherRecognizer.dropRequireFailure(name);
                    }
                });
            }
        }
        this.wheelInput.enableEventType(name, enabled);
        this.moveInput.enableEventType(name, enabled);
        this.keyInput.enableEventType(name, enabled);
        this.contextmenuInput.enableEventType(name, enabled);
    }
    /**
     * Process the event registration for a single event + handler.
     */
    _addEventHandler(event, handler, opts, once, passive) {
        if (typeof event !== 'string') {
            // @ts-ignore
            opts = handler;
            // If `event` is a map, call `on()` for each entry.
            for (const eventName in event) {
                this._addEventHandler(eventName, event[eventName], opts, once, passive);
            }
            return;
        }
        const { manager, events } = this;
        // Alias to a recognized gesture as necessary.
        const eventAlias = GESTURE_EVENT_ALIASES[event] || event;
        let eventRegistrar = events.get(eventAlias);
        if (!eventRegistrar) {
            eventRegistrar = new EventRegistrar(this);
            events.set(eventAlias, eventRegistrar);
            // Enable recognizer for this event.
            eventRegistrar.recognizerName = EVENT_RECOGNIZER_MAP[eventAlias] || eventAlias;
            // Listen to the event
            if (manager) {
                manager.on(eventAlias, eventRegistrar.handleEvent);
            }
        }
        eventRegistrar.add(event, handler, opts, once, passive);
        if (!eventRegistrar.isEmpty()) {
            this._toggleRecognizer(eventRegistrar.recognizerName, true);
        }
    }
    /**
     * Process the event deregistration for a single event + handler.
     */
    _removeEventHandler(event, handler) {
        if (typeof event !== 'string') {
            // If `event` is a map, call `off()` for each entry.
            for (const eventName in event) {
                this._removeEventHandler(eventName, event[eventName]);
            }
            return;
        }
        const { events } = this;
        // Alias to a recognized gesture as necessary.
        const eventAlias = GESTURE_EVENT_ALIASES[event] || event;
        const eventRegistrar = events.get(eventAlias);
        if (!eventRegistrar) {
            return;
        }
        eventRegistrar.remove(event, handler);
        if (eventRegistrar.isEmpty()) {
            const { recognizerName } = eventRegistrar;
            // Disable recognizer if no more handlers are attached to its events
            let isRecognizerUsed = false;
            for (const eh of events.values()) {
                if (eh.recognizerName === recognizerName && !eh.isEmpty()) {
                    isRecognizerUsed = true;
                    break;
                }
            }
            if (!isRecognizerUsed) {
                this._toggleRecognizer(recognizerName, false);
            }
        }
    }
}

class PointerAgent {
    #types = [
        "pointerdown",
        "pointerup",
        "pointerover", "pointerenter",
        "pointerout", "pointerleave",
        "pointermove",
        "pointercancel",
        "gotpointercapture",
        "lostpointercapture",
        "click",
        "dblclick",
        "anyclick",
        "wheel",
        "contextmenu",
        "pointerdrag",
        "pointerdragend",
        "pan",
        "panstart",
        "panmove",
        "panup",
        "pandown",
        "panleft",
        "panright",
        "panend",
        "pancancel"
    ];
    #input;
    #pad = {
        left: false
    };
    constructor(input) {
        this.#input = input;
    }
    has(event) {
        return (this.#types.indexOf(event) == -1) ? false : true;
    }
    on(event, handler, options, once) {
        let cb = handler;
        switch (event) {
            case "pointerdown":
                cb = function (e) {
                    if (e.leftButton)
                        this.#input.pad.left = true;
                    this.#input.onPointerDown(e);
                    handler(this.#input.pointerEventData(e));
                };
                break;
            case "pointerup":
                cb = function (e) {
                    this.#input.onPointerUp(e);
                    handler(this.#input.pointerEventData(e));
                };
                break;
            case "pointermove":
                cb = function (e) {
                    this.#input.motion(e);
                    handler(this.#input.pointerEventData(e));
                };
                break;
            case "click":
            case "dbclick":
            case "pointerenter":
            case "pointerleave":
            case "pointerout":
            case "pointerover":
            case "contextmenu":
                cb = function (e) {
                    this.#input.location(e);
                    handler(this.#input.pointerEventData(e));
                };
                break;
            case "wheel":
                cb = function (e) {
                    this.#input.wheeldelta = e;
                    handler(this.#input.pointerEventData(e));
                };
                break;
            case "pointercancel":
            case "gotpointercapture":
            case "lostpointercapture":
                cb = function (e) {
                    handler(e);
                };
                break;
            case "pointerdrag":
                cb = function (e) {
                    this.#input.motion(e);
                    handler(this.#input.pointerEventData(e));
                };
                this.#input.agent.on("panstart", this.#input.startPointerDrag.bind(this.#input));
                event = "panmove";
                break;
            case "pointerdragend":
                cb = function (e) {
                    this.#input.motion(e);
                    this.#input.endPointerDrag(e);
                    handler(this.#input.pointerEventData(e));
                };
                event = "panend";
                break;
        }
        if (once)
            this.#input.agent.once(event, cb.bind(this), options);
        else
            this.#input.agent.on(event, cb.bind(this), options);
        return cb;
    }
    off(event, handler, options) {
        this.#input.agent.off(event, handler, options);
    }
}

class TouchAgent {
    #types = [
        'rotate',
        'rotatestart',
        'rotatemove',
        'rotateend',
        'rotatecancel',
        'pinch',
        'pinchin',
        'pinchout',
        'pinchstart',
        'pinchmove',
        'pinchend',
        'pinchcancel',
        'swipe',
        'swipeleft',
        'swiperight',
        'swipeup',
        'swipedown',
        'tripan',
        'tripanstart',
        'tripanmove',
        'tripanup',
        'tripandown',
        'tripanleft',
        'tripanright',
        'tripanend',
        'tripancancel',
    ];
    #input;
    constructor(input) {
        this.#input = input;
    }
    has(event) {
        return (this.#types.indexOf(event) == -1) ? false : true;
    }
    on(event, handler, options, once) {
        let cb = handler;
        if (once)
            this.#input.agent.once(event, cb.bind(this), options);
        else
            this.#input.agent.on(event, cb.bind(this), options);
        return cb;
    }
    off(event, handler, options) {
        this.#input.agent.off(event, handler, options);
    }
}

class KeyboardAgent {
    #types = [
        'keydown',
        'keyup',
    ];
    #input;
    constructor(input) {
        this.#input = input;
    }
    has(event) {
        return (this.#types.indexOf(event) == -1) ? false : true;
    }
    on(event, handler, options, once) {
        let cb = handler;
        if (once)
            this.#input.agent.once(event, cb.bind(this), options);
        else
            this.#input.agent.on(event, cb.bind(this), options);
        return cb;
    }
    off(event, handler, options) {
        this.#input.agent.off(event, handler, options);
    }
}

const defaultOptions = {
    element: undefined,
    contextMenu: true,
    panX: true,
    panY: true
};
class Input {
    #options;
    #element;
    #eventsAgent;
    #status;
    #listeners;
    #pointer;
    #key;
    #touch;
    #isTouch;
    #isPan;
    #wheelDelta;
    constructor(element, options) {
        this.#listeners = [];
        this.#pointer = null;
        this.#key = null;
        this.#touch = null;
        this.#isPan = false;
        this.pad = { left: false };
        this.#options = { ...defaultOptions, ...options };
        this.#status = status.idle;
        this.#isTouch = isTouchDevice;
        this.#element = element;
        if (!this.#element && this.#options.elementId) {
            this.#element = document.getElementById(this.#options.elementId);
        }
        if (!isHTMLElement(this.#element)) {
            throw "Must specify an element to receive user input.";
        }
        if (!this.#options.contextMenu) {
            window.oncontextmenu = (e) => {
                e.preventDefault();
                return false;
            };
        }
        const T = this.#isTouch ? 10 : 0;
        const opts = {
            recognizerOptions: {
                pan: { threshold: T },
                pinch: { threshold: 0 }
            }
        };
        this.#eventsAgent = new EventManager(this.#element, opts);
        this.pointerInit();
    }
    get agent() { return this.#eventsAgent; }
    get pointer() {
        if (this.#pointer instanceof PointerAgent)
            return this.#pointer;
        this.#pointer = new PointerAgent(this);
        return this.#pointer;
    }
    get touch() {
        if (this.#touch instanceof TouchAgent)
            return this.#touch;
        this.#touch = new TouchAgent(this);
        return this.#touch;
    }
    get key() {
        if (this.#key instanceof KeyboardAgent)
            return this.#key;
        this.#key = new KeyboardAgent(this);
        return this.#key;
    }
    get status() { return this.#status; }
    get element() { return this.#element; }
    get isTouch() { return this.#isTouch; }
    get isPan() { return this.#isPan; }
    set wheeldelta(w) { this.#wheelDelta = w.delta; }
    get wheeldelta() { return this.#wheelDelta; }
    destroy() {
        for (let l of this.#listeners) {
            this.off(l.event, l.handler, l.options);
        }
        this.#eventsAgent.destroy();
        this.#pointer = undefined;
        this.#key = undefined;
        this.#touch = undefined;
    }
    isValid(event, handler) {
        return (isString(event) ||
            isFunction(handler)) ? true : false;
    }
    validOptions(options) {
        return (isObject(options) && isBoolean(options)) ? options : undefined;
    }
    on(event, handler, options, once = false) {
        if (!this.isValid(event, handler))
            return false;
        if (this.pointer.has(event))
            this.#pointer.on(event, handler, options, once);
        else if (this.touch.has(event))
            this.#touch.on(event, handler, options, once);
        else if (this.key.has(event))
            this.#key.on(event, handler, options, once);
        else
            this.#element.addEventListener(event, handler, this.validOptions(options));
        this.#listeners.push({ event, handler, options });
    }
    off(event, handler, options) {
        if (this.#pointer?.has(event))
            this.#pointer.off(event, handler, options);
        else if (this.#touch?.has(event))
            this.#touch.off(event, handler, options);
        else if (this.#key?.has(event))
            this.#key.off(event, handler, options);
        else
            this.#element.removeEventListener(event, handler, this.validOptions(options));
        for (let l of this.#listeners) {
            if (l.event === event &&
                l.handler === handler &&
                l.options === options) {
                let i = this.#listeners.indexOf(l);
                this.#listeners.splice(i, 1);
            }
        }
    }
    once(event, handler, options) {
        this.on(event, handler, options, true);
    }
    setCursor(type) {
        this.#element.style.cursor = type;
    }
    pointerInit() {
        this.clientPosPrev = new Point([null, null]);
        this.position = new Point([0, 0]);
        this.movement = new Point([0, 0]);
        this.dragstart = new Point([null, null]);
        this.dragend = new Point([null, null]);
        this.dragCheckThreshold = 3;
        this.dragStatus = false;
        this.wheeldelta = 0;
        this.pointerButtons = [false, false, false, false, false];
        this.pointerdrag = new Event("pointerdrag");
        this.pointerdragend = new Event("pointerdragend");
    }
    pointerEventData(e) {
        return {
            isProcessed: false,
            pointerType: e.pointerType,
            position: this.position.clone(),
            movement: this.movement.clone(),
            dragstart: this.dragstart.clone(),
            dragend: this.dragend.clone(),
            wheeldelta: this.wheeldelta,
            buttons: this.pointerButtons,
            domEvent: e,
            timeStamp: Date.now()
        };
    }
    motion(e) {
        let clientRect = { left: 0, top: 0 };
        try {
            clientRect = e.srcEvent.target?.getBoundingClientRect();
        }
        catch (err) { }
        const clientX = e.srcEvent.clientX || this.position.x;
        const clientY = e.srcEvent.clientY || this.position.y;
        this.movement.x = clientX - this.clientPosPrev.x;
        this.movement.y = clientY - this.clientPosPrev.y;
        this.position.x = clientX - clientRect.left;
        this.position.y = clientY - clientRect.top;
        this.clientPosPrev.x = clientX;
        this.clientPosPrev.y = clientY;
    }
    location(e) {
        let clientRect = { left: 0, top: 0 };
        try {
            clientRect = e.srcEvent.target?.getBoundingClientRect();
        }
        catch (err) { }
        this.clientPosPrev.x = e.srcEvent.clientX;
        this.clientPosPrev.y = e.srcEvent.clientY;
        this.position.x = e.srcEvent.clientX - clientRect.left;
        this.position.y = e.srcEvent.clientY - clientRect.top;
        this.movement.x = 0;
        this.movement.y = 0;
    }
    onPointerDown(e) {
        this.location(e);
        this.pointerButtons[e.srcEvent.button] = true;
    }
    onPointerUp(e) {
        this.location(e);
        this.pointerButtons[e.srcEvent.button] = false;
    }
    startPointerDrag(e) {
        this.#isPan = true;
        this.onPointerDown(e);
    }
    endPointerDrag(e) {
        this.#isPan = false;
    }
}

const DEFAULT_TIMEINTERVAL = 60000;
const DEFAULT_TIMEFRAME = "1m";
const DEFAULT_TIMEFRAMEMS = DEFAULT_TIMEINTERVAL;
const XAXIS_ZOOM = 0.05;
const XAXIS_STEP = 100;
const YAXIS_STEP = 100;
const YAXIS_BOUNDS = 0.2;
const YAXIS_PADDING = 1.2;
const YAXIS_MINDIGITS = 8;
class YAXIS_TYPE {
    static { this.default = new YAXIS_TYPE("default"); }
    static { this.percent = new YAXIS_TYPE("percent"); }
    static { this.relative = new YAXIS_TYPE("relative"); }
    static { this.log = new YAXIS_TYPE("log"); }
    static valid(t) {
        return (t instanceof YAXIS_TYPE) ? t : YAXIS_TYPE.default;
    }
    static get types() {
        let types = [];
        for (let key in YAXIS_TYPE) {
            if (YAXIS_TYPE[key] instanceof YAXIS_TYPE)
                types.push(key);
        }
        return types;
    }
    constructor(name) {
        this.name = name;
    }
}
const YAXIS_TYPES = YAXIS_TYPE.types;
const INTITIALCNT = 30;
const LIMITFUTURE = 200;
const LIMITPAST = 200;
const MINCANDLES = 20;
const MAXCANDLES = 1920;
const BUFFERSIZE = 5;
const ROWMINHEIGHT = 50;
const SECONDARYDEFAULTHEIGHT = 30;
const DIVIDERHEIGHT = 8;
const COLLAPSEDHEIGHT = 30;
const UTILSLOCATIONS = [true, "top"];
class OHLCV {
    static { this.t = 0; }
    static { this.o = 1; }
    static { this.h = 2; }
    static { this.l = 3; }
    static { this.c = 4; }
    static { this.v = 5; }
}
const OVERLAYPANES = {
    mainPane: {},
    primaryPane: {},
    secondaryPane: {},
    scale: {},
    timeline: {}
};
Array.from(Object.keys(OVERLAYPANES));

class Divider {
    #id;
    #core;
    #config;
    #theme;
    #widgets;
    #chartPane;
    #elDividers;
    #elDivider;
    #cursorPos;
    #cursorStyle;
    #input;
    static { this.dividerList = {}; }
    static { this.divideCnt = 0; }
    static { this.class = CLASS_DIVIDERS; }
    static { this.Name = "Dividers"; }
    static { this.type = "divider"; }
    static create(widgets, config) {
        const id = `${config.core.ID}_divider_${++Divider.divideCnt}`;
        config.id = id;
        Divider.dividerList[id] = new Divider(widgets, config);
        return Divider.dividerList[id];
    }
    static destroy() {
        for (let id in Divider.dividerList) {
            Divider.dividerList[id].destroy();
            delete Divider.dividerList[id];
        }
    }
    static defaultNode() {
        const dividersStyle = `position: absolute;`;
        const node = `
  <div slot="widget" class="${CLASS_DIVIDERS}" style="${dividersStyle}"></div>
  `;
        return node;
    }
    constructor(widgets, config) {
        const cfg = { ...config };
        this.#widgets = widgets;
        this.#core = cfg.core;
        this.#config = cfg;
        this.#theme = cfg.core.theme;
        this.#id = cfg.id;
        this.#chartPane = cfg.chartPane;
        this.#elDividers = widgets.elements[Divider.type];
        this.init();
    }
    get el() { return this.#elDivider; }
    get id() { return this.#id; }
    get chartPane() { return this.#chartPane; }
    get config() { return this.#core.config; }
    get pos() { return this.dimensions; }
    get dimensions() { return elementDimPos(this.#elDivider); }
    get height() { return this.#elDivider.getBoundingClientRect().height; }
    set cursor(c) { this.setCursorStyle(c); }
    get cursor() { return this.#cursorStyle; }
    get type() { return Divider.type; }
    init() {
        this.mount();
    }
    start() {
        this.cursor = "row-resize";
        this.eventsListen();
    }
    destroy() {
        this.#input.destroy();
        this.el.remove();
        delete Divider.dividerList[this.id];
    }
    eventsListen() {
        this.#input = new Input(this.#elDivider, { disableContextMenu: false });
        this.#input.on("pointerover", this.onMouseEnter.bind(this));
        this.#input.on("pointerout", this.onMouseOut.bind(this));
        this.#input.on("pointerdrag", this.onPointerDrag.bind(this));
        this.#input.on("pointerdragend", this.onPointerDragEnd.bind(this));
    }
    on(topic, handler, context = this) {
        this.#core.on(topic, handler, context);
    }
    off(topic, handler, context = this) {
        this.#core.off(topic, handler, context);
    }
    emit(topic, data) {
        this.#core.emit(topic, data);
    }
    onMouseEnter() {
        this.#elDivider.style.background = this.#theme.divider.active;
        this.#core.MainPane.onMouseEnter();
    }
    onMouseOut() {
        this.#elDivider.style.background = this.#theme.divider.idle;
        this.#core.MainPane.onMouseEnter();
    }
    onPointerDrag(e) {
        this.#cursorPos = this.#core.MainPane.cursorPos;
        this.#elDivider.style.background = this.#theme.divider.active;
        this.emit(`${this.id}_pointerDrag`, this.#cursorPos);
        this.emit(`divider_pointerDrag`, {
            id: this.id,
            e: e,
            pos: this.#cursorPos,
            chartPane: this.chartPane
        });
        this.chartPane.resize();
    }
    onPointerDragEnd(e) {
        this.#elDivider.style.background = this.#theme.divider.idle;
        this.#cursorPos = this.#core.MainPane.cursorPos;
        this.emit(`${this.id}_pointerDragend`, this.#cursorPos);
        this.emit("divider_pointerDragEnd", {
            id: this.id,
            e: e,
            pos: this.#cursorPos,
            chartPane: this.chartPane
        });
        this.chartPane.resize();
    }
    mount() {
        if (this.#elDividers.lastElementChild == null)
            this.#elDividers.innerHTML = this.dividerNode();
        else
            this.#elDividers.lastElementChild.insertAdjacentHTML("afterend", this.dividerNode());
        this.#elDivider = findBySelector(`#${this.#id}`, this.#elDividers);
    }
    dividerNode() {
        let theme = this.#core.theme, top = this.#chartPane.pos.top - elementDimPos(this.#elDividers).top; this.#core.elBody.width - this.#core.elBody.scale.width; let height = (isNumber(this.config.dividerHeight)) ?
            this.config.dividerHeight : DIVIDERHEIGHT, left = this.#core.elBody.tools.width;
        top -= (height / 2);
        switch (theme.tools.location) {
            case "left": break;
            case false:
            case "none":
            case "right":
                left *= -1;
                break;
        }
        const styleDivider = `position: absolute; top: ${top}px; left: ${left}px; z-index:100; width: 100%; height: ${height}px; background: ${theme.divider.idle};`;
        const styleLine = `width: 100%; margin: 3.5px 0; border: 0; border-top: ${theme.divider.style} ${theme.divider.line};`;
        const node = `
      <div id="${this.#id}" class="divider" style="${styleDivider}"><hr style="${styleLine}"></div>
    `;
        return node;
    }
    setPos() {
        let top = this.#chartPane.pos.top - elementDimPos(this.#elDividers).top;
        top = top - (this.height / 2) + 1;
        this.#elDivider.style.top = `${top}px`;
    }
    setWidth() {
        let pos = this.#core.theme.tools.location;
        let toolsW = (pos == "left" || pos == "right") ? this.#theme.tools.width || TOOLSW : 0;
        this.#core.WidgetsG.elements.divider.style.width = `${this.#core.elBody.width - toolsW}px`;
        this.#core.WidgetsG.elements.divider.style.right = (pos === "left") ? `0px` : `${toolsW}px`;
    }
    setCursorStyle(c) {
        if (!isString(c))
            return;
        this.#cursorStyle = c;
        this.#elDivider.style.cursor = c;
    }
    hide() {
        this.#elDivider.style.display = `none`;
    }
    show() {
        this.#elDivider.style.display = `block`;
    }
}

const camera = `<svg width="46.08" height="46.08" viewBox="-51.2 -51.2 614.4 614.4" ><path d="M471.993 112h-89.2l-16.242-46.75a32.023 32.023 0 00-30.229-21.5H175.241a31.991 31.991 0 00-30.294 21.691L129.1 112H40a24.027 24.027 0 00-24 24v312a24.027 24.027 0 0024 24h431.993a24.027 24.027 0 0024-24V136a24.027 24.027 0 00-24-24zm-8 328H48.007V144h104.01l23.224-68.25h161.081l23.71 68.25h103.961z" class="ci-primary"></path><path d="M256 168a114 114 0 10114 114 114.13 114.13 0 00-114-114zm0 196a82 82 0 1182-82 82.093 82.093 0 01-82 82z"></path></svg>`;
const chart = `<svg width="46.08" height="46.08" viewBox="-51.2 -51.2 614.4 614.4"><path d="M376 160v32h65.372L252 381.373l-72-72L76.686 412.686l22.628 22.628L180 354.627l72 72 212-211.999V280h32V160H376z"></path><path d="M48 104H16v392h480v-32H48V104z"></path></svg>`;
const clock = `<svg width="46.08" height="46.08" viewBox="-51.2 -51.2 614.4 614.4"><path d="M271.514 95.5h-32v178.111l115.613 54.948 13.737-28.902-97.35-46.268V95.5z"></path><path d="M256 16C123.452 16 16 123.452 16 256s107.452 240 240 240 240-107.452 240-240S388.548 16 256 16zm0 448c-114.875 0-208-93.125-208-208S141.125 48 256 48s208 93.125 208 208-93.125 208-208 208z"></path></svg>`;
const config = `<svg width="46.08" height="46.08" viewBox="-51.2 -51.2 614.4 614.4"><path d="M245.151 168a88 88 0 1088 88 88.1 88.1 0 00-88-88zm0 144a56 56 0 1156-56 56.063 56.063 0 01-56 56z"></path><path d="M464.7 322.319l-31.77-26.153a193.081 193.081 0 000-80.332l31.77-26.153a19.941 19.941 0 004.606-25.439l-32.612-56.483a19.936 19.936 0 00-24.337-8.73l-38.561 14.447a192.038 192.038 0 00-69.54-40.192l-6.766-40.571A19.936 19.936 0 00277.762 16H212.54a19.937 19.937 0 00-19.728 16.712l-6.762 40.572a192.03 192.03 0 00-69.54 40.192L77.945 99.027a19.937 19.937 0 00-24.334 8.731L21 164.245a19.94 19.94 0 004.61 25.438l31.767 26.151a193.081 193.081 0 000 80.332l-31.77 26.153A19.942 19.942 0 0021 347.758l32.612 56.483a19.937 19.937 0 0024.337 8.73l38.562-14.447a192.03 192.03 0 0069.54 40.192l6.762 40.571A19.937 19.937 0 00212.54 496h65.222a19.936 19.936 0 0019.728-16.712l6.763-40.572a192.038 192.038 0 0069.54-40.192l38.564 14.449a19.938 19.938 0 0024.334-8.731l32.609-56.487a19.939 19.939 0 00-4.6-25.436zm-50.636 57.12l-48.109-18.024-7.285 7.334a159.955 159.955 0 01-72.625 41.973l-10 2.636L267.6 464h-44.89l-8.442-50.642-10-2.636a159.955 159.955 0 01-72.625-41.973l-7.285-7.334-48.117 18.024L53.8 340.562l39.629-32.624-2.7-9.973a160.9 160.9 0 010-83.93l2.7-9.972L53.8 171.439l22.446-38.878 48.109 18.024 7.285-7.334a159.955 159.955 0 0172.625-41.973l10-2.636L222.706 48H267.6l8.442 50.642 10 2.636a159.955 159.955 0 0172.625 41.973l7.285 7.334 48.109-18.024 22.447 38.877-39.629 32.625 2.7 9.972a160.9 160.9 0 010 83.93l-2.7 9.973 39.629 32.623z"></path></svg>`;
const cursor = `<svg width="46.08" height="46.08" version="1.1" viewBox="-51.2 -51.2 614.4 614.4"><rect x="16" y="240.18" width="188.84" height="31.635"/><g transform="translate(-3.3234e-7 -112.18)"><rect x="307.16" y="352.37" width="188.84" height="31.635"/></g><rect transform="rotate(-90)" x="-496" y="240.18" width="188.84" height="31.635"/><rect transform="rotate(-90)" x="-204.84" y="240.18" width="188.84" height="31.635"/></svg>`;
const del = `<svg width="46.08" height="46.08" viewBox="0 0 24 24"><path fill="none" d="M0 0h24v24H0z"></path><path d="M6.535 3H21a1 1 0 011 1v16a1 1 0 01-1 1H6.535a1 1 0 01-.832-.445l-5.333-8a1 1 0 010-1.11l5.333-8A1 1 0 016.535 3zm.535 2l-4.666 7 4.666 7H20V5H7.07zM13 10.586l2.828-2.829 1.415 1.415L14.414 12l2.829 2.828-1.415 1.415L13 13.414l-2.828 2.829-1.415-1.415L11.586 12 8.757 9.172l1.415-1.415L13 10.586z"></path></svg>`;
const fibonacci = `<svg width="46.08" height="46.08" version="1.1" viewBox="-51.2 -51.2 614.4 614.4"><g stroke-width="30.155"><rect x="14.757" y="240.92" width="482.49" height="30.155" rx="15.078"/><rect x="14.757" y="147" width="482.49" height="30.155" rx="15.078"/><rect x="14.757" y="334.84" width="482.49" height="30.155" rx="15.078"/></g ><g transform="translate(5.937 -288.34)"><path d="m23.904 712.34c-8.3532 0-15.078 6.7252-15.078 15.078s6.7249 15.078 15.078 15.078h173.93c-0.65295-3.3651-2.0312-6.4697-2.0312-10.026 0-7.1393 1.5573-13.888 4.0625-20.13zm276.35 0c2.5051 6.2423 4.0365 12.991 4.0365 20.13 0 3.5554-1.3526 6.6618-2.0052 10.026h173.93c8.3532 0 15.078-6.7252 15.078-15.078s-6.7249-15.078-15.078-15.078z"/><path d="m250.06 759.97c17.965 0 32.545-14.58 32.545-32.545 0-17.965-14.58-32.545-32.545-32.545-17.965 0-32.545 14.58-32.545 32.545 0 17.965 14.58 32.545 32.545 32.545zm0 21.697c-29.964 0-54.242-24.279-54.242-54.242 0-29.964 24.279-54.242 54.242-54.242 29.964 0 54.242 24.279 54.242 54.242 0 29.964-24.279 54.242-54.242 54.242z" stroke-width="21.697"/></g ><path d="m144.05 18.672c-24.694 0-45.285 16.595-51.849 39.167h-62.37c-8.3532 0-15.078 6.7252-15.078 15.078s6.7249 15.078 15.078 15.078h62.37c6.5639 22.572 27.155 39.167 51.849 39.167s45.285-16.595 51.849-39.167h120.03c6.5639 22.572 27.155 39.167 51.849 39.167 24.694 0 45.285-16.595 51.849-39.167h62.552c8.3532 0 15.078-6.7252 15.078-15.078s-6.7249-15.078-15.078-15.078h-62.552c-6.5639-22.572-27.155-39.167-51.849-39.167-24.694 0-45.285 16.595-51.849 39.167h-120.03c-6.5639-22.572-27.155-39.167-51.849-39.167zm0 21.693c17.965 0 32.552 14.587 32.552 32.552 0 17.965-14.587 32.552-32.552 32.552-17.965 1e-5 -32.552-14.587-32.552-32.552 0-17.965 14.587-32.552 32.552-32.552zm223.72 0c17.965 0 32.552 14.587 32.552 32.552 0 17.965-14.587 32.552-32.552 32.552-17.965 0-32.552-14.587-32.552-32.552 0-17.965 14.587-32.552 32.552-32.552z" stroke-width="30.155"/></svg>`;
const line = `<svg width="46.08" height="46.08" version="1.1" viewBox="-51.2 -51.2 614.4 614.4"><g transform="matrix(21.697 0 0 21.697 -47.758 -47.758)"><path d="m7.354 21.354 14-14-0.707-0.707-14 14z"/><path d="m22.5 7c0.828 0 1.5-0.672 1.5-1.5s-0.672-1.5-1.5-1.5-1.5 0.672-1.5 1.5 0.672 1.5 1.5 1.5zm0 1c-1.381 0-2.5-1.119-2.5-2.5s1.119-2.5 2.5-2.5 2.5 1.119 2.5 2.5-1.119 2.5-2.5 2.5zm-17 16c0.828 0 1.5-0.672 1.5-1.5s-0.672-1.5-1.5-1.5-1.5 0.672-1.5 1.5 0.672 1.5 1.5 1.5zm0 1c-1.381 0-2.5-1.119-2.5-2.5s1.119-2.5 2.5-2.5 2.5 1.119 2.5 2.5-1.119 2.5-2.5 2.5z"/></g></svg>`;
const measure = `<svg width="46.08" height="46.08" viewBox="0 0 32 32"><path d="M 3.2758709,20.241377 11.758622,28.72413 28.72413,11.758622 20.241377,3.2758709 Z m 2.1206881,0 1.5905161,-1.590515 3.7112049,3.711203 1.060342,-1.060345 -3.7112027,-3.711204 1.0603441,-1.060344 2.1206876,2.12069 1.060346,-1.060346 -2.120689,-2.120688 1.060343,-1.060344 3.711203,3.711203 L 16,17.060346 l -3.711203,-3.711208 1.060341,-1.060341 2.12069,2.120687 1.060344,-1.060346 -2.120688,-2.120687 1.060344,-1.060343 3.711204,3.711205 1.060345,-1.060345 -3.711205,-3.7112046 1.060344,-1.0603441 2.120687,2.1206887 1.060346,-1.0603446 -2.120687,-2.1206883 1.590515,-1.5905161 6.362065,6.362063 -14.84482,14.84482 z" style="stroke-width:0.749776" /></svg>`;
const range = `<svg width="46.08" height="46.08" viewBox="-51.2 -51.2 614.4 614.4"><g id="g930" transform="matrix(21.128963,0,0,21.128963,-29.235597,-50.369964)"><path clip-rule="evenodd" d="m 4.5,5 a 1.5,1.5 0 1 0 0,3 1.5,1.5 0 0 0 0,-3 z M 2,6.5 A 2.5,2.5 0 0 1 6.95,6 H 24 V 7 H 6.95 A 2.5,2.5 0 0 1 2,6.5 Z M 4.5,15 a 1.5,1.5 0 1 0 0,3 1.5,1.5 0 0 0 0,-3 z M 2,16.5 A 2.5,2.5 0 0 1 6.95,16 h 13.1 a 2.5,2.5 0 1 1 0,1 H 6.95 A 2.5,2.5 0 0 1 2,16.5 Z M 22.5,15 a 1.5,1.5 0 1 0 0,3 1.5,1.5 0 0 0 0,-3 z m -18,6 a 1.5,1.5 0 1 0 0,3 1.5,1.5 0 0 0 0,-3 z M 2,22.5 A 2.5,2.5 0 0 1 6.95,22 H 24 v 1 H 6.95 A 2.5,2.5 0 0 1 2,22.5 Z" id="path908" /><path clip-rule="evenodd" d="M 22.4,8.94 21.01,9.57 20.6,8.66 21.99,8.03 Z m -4,1.8 -1.39,0.63 -0.41,-0.91 1.39,-0.63 z m -4,1.8 -1.4,0.63 -0.4,-0.91 1.39,-0.63 z m -4,1.8 L 9,14.97 8.6,14.06 9.99,13.43 Z" id="path910" /></g></svg>`;
const text = `<svg width="46.08" height="46.08" viewBox="-51.2 -51.2 614.4 614.4"><path d="M231.359 147l-80.921 205h45.155l15.593-39.5h89.628l15.593 39.5h45.155l-80.921-205zm-3.594 123.5L256 198.967l28.235 71.533z"></path><path d="M384 56H128V16H16v112h40v256H16v112h112v-40h256v40h112V384h-40V128h40V16H384zM48 96V48h48v48zm48 368H48v-48h48zm288-40H128v-40H88V128h40V88h256v40h40v256h-40zm80-8v48h-48v-48zM416 48h48v48h-48z"></path></svg>`;
const tradePosition = `<svg style="width: 46px; height: 46px" viewBox="-51.2 -51.2 614.4 614.4" xmlns="http://www.w3.org/2000/svg">
 <path d="m65.845 55.275a31.693 31.693 0 1 0 0 63.387 31.693 31.693 0 0 0 0-63.387zm-52.822 31.693a52.822 52.822 0 0 1 104.59-10.564h360.25v21.129h-360.25a52.822 52.822 0 0 1-104.59-10.564zm52.822 179.6a31.693 31.693 0 1 0 0 63.387 31.693 31.693 0 0 0 0-63.387zm-52.822 31.693a52.822 52.822 0 0 1 104.59-10.564h276.79a52.822 52.822 0 1 1 0 21.129h-276.79a52.822 52.822 0 0 1-104.59-10.564zm433.14-31.693a31.693 31.693 0 1 0 0 63.387 31.693 31.693 0 0 0 0-63.387zm-380.32 126.77a31.693 31.693 0 1 0 0 63.387 31.693 31.693 0 0 0 0-63.387zm-52.822 31.693a52.822 52.822 0 0 1 104.59-10.564h360.25v21.129h-360.25a52.822 52.822 0 0 1-104.59-10.564z" clip-rule="evenodd" stroke-width="21.129"/>
</svg>`;
const close = `<svg style="width: 46px; height: 46px" viewBox="-1.6 -1.6 19.2 19.2"><path d="M 15,2 C 15,1.4477153 14.552285,1 14,1 H 2 C 1.4477153,1 1,1.4477153 1,2 v 12 c 0,0.552285 0.4477153,1 1,1 h 12 c 0.552285,0 1,-0.447715 1,-1 z M 0,2 C 0,0.8954305 0.8954305,0 2,0 h 12 c 1.104569,0 2,0.8954305 2,2 v 12 c 0,1.104569 -0.895431,2 -2,2 H 2 C 0.8954305,16 0,15.104569 0,14 Z" id="path2" /><g id="g718" transform="translate(0,1.2499996)"><path d="M 7.5010125,7.9560661 5.355012,10.103066 c -0.472,0.472 -1.18,-0.2360003 -0.708,-0.7080003 L 7.6470125,6.3950659 c 0.195364,-0.195858 0.512636,-0.195858 0.708,0 l 3.0000005,2.9999998 c 0.472,0.472 -0.236,1.1800003 -0.708,0.7080003 L 8.5010125,7.9560661 c -0.431103,-0.417289 -0.523896,-0.423024 -1,0 z" style="" id="path566-5" /><path d="m 7.4989873,5.5439348 -2.1460003,-2.147 c -0.472,-0.472 -1.18,0.236 -0.708,0.708 l 3.0000003,3 c 0.1953639,0.195858 0.5126361,0.195858 0.708,0 l 2.9999997,-3 c 0.472,-0.472 -0.236,-1.18 -0.708,-0.708 l -2.1459997,2.147 c -0.4311027,0.417289 -0.5238956,0.423024 -1,0 z" style="" id="path566-6-3" /></g></svg>`;
const up = `<svg style="width: 46px; height: 46px" viewBox="-1.6 -1.6 19.2 19.2"><path d="M 15,2 C 15,1.4477153 14.552285,1 14,1 H 2 C 1.4477153,1 1,1.4477153 1,2 v 12 c 0,0.552285 0.4477153,1 1,1 h 12 c 0.552285,0 1,-0.447715 1,-1 z M 0,2 C 0,0.8954305 0.8954305,0 2,0 h 12 c 1.104569,0 2,0.8954305 2,2 v 12 c 0,1.104569 -0.895431,2 -2,2 H 2 C 0.8954305,16 0,15.104569 0,14 Z" id="path2" /><path d="m 7.4989873,7.7026182 -2.1460003,2.147 c -0.472,0.4719998 -1.18,-0.236 -0.708,-0.708 l 3.0000003,-3 c 0.1953639,-0.1958581 0.5126361,-0.1958581 0.708,0 l 2.9999997,3 c 0.472,0.472 -0.236,1.1799998 -0.708,0.708 l -2.1459997,-2.147 c -0.4311027,-0.417289 -0.5238956,-0.423024 -1,0 z" style="" id="path566-6-3" /></svg>`;
const down = `<svg style="width: 46px; height: 46px" viewBox="-1.6 -1.6 19.2 19.2"><path d="M 15,2 C 15,1.4477153 14.552285,1 14,1 H 2 C 1.4477153,1 1,1.4477153 1,2 v 12 c 0,0.552285 0.4477153,1 1,1 h 12 c 0.552285,0 1,-0.447715 1,-1 z M 0,2 C 0,0.8954305 0.8954305,0 2,0 h 12 c 1.104569,0 2,0.8954305 2,2 v 12 c 0,1.104569 -0.895431,2 -2,2 H 2 C 0.8954305,16 0,15.104569 0,14 Z" id="path2" /><path d="m 7.4989873,8.2973819 -2.1460003,-2.147 c -0.472,-0.472 -1.18,0.236 -0.708,0.708 l 3.0000003,3 c 0.1953639,0.1958581 0.5126361,0.1958581 0.708,0 l 2.9999997,-3 c 0.472,-0.472 -0.236,-1.18 -0.708,-0.708 l -2.1459997,2.147 c -0.4311027,0.417289 -0.5238956,0.423024 -1,0 z" style="" id="path566-6-3" /></svg>`;
const up2 = `<svg width="46.08" height="46.08" version="1.1" viewBox="-1.6 -1.6 19.2 19.2" xmlns="http://www.w3.org/2000/svg"> <path d="m1 14a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-12a1 1 0 0 0-1-1h-12a1 1 0 0 0-1 1zm15 0a2 2 0 0 1-2 2h-12a2 2 0 0 1-2-2v-12a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2zm-8.5-2.5a0.5 0.5 0 0 0 1 0v-5.793l2.146 2.147a0.50063 0.50063 0 1 0 0.708-0.708l-3-3a0.5 0.5 0 0 0-0.708 0l-3 3a0.50063 0.50063 0 0 0 0.708 0.708l2.146-2.147z" fill-rule="evenodd"/></svg>`;
const down2 = `<svg width="46.08" height="46.08" viewBox="-1.6 -1.6 19.2 19.2" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" d="M 15,2 A 1,-1 0 0 0 14,1 H 2 A 1,-1 0 0 0 1,2 v 12 a 1,-1 0 0 0 1,1 h 12 a 1,-1 0 0 0 1,-1 z M 0,2 A 2,-2 0 0 1 2,0 h 12 a 2,-2 0 0 1 2,2 v 12 a 2,-2 0 0 1 -2,2 H 2 A 2,-2 0 0 1 0,14 Z m 8.5,2.5 a 0.5,-0.5 0 0 0 -1,0 v 5.793 L 5.354,8.146 A 0.5006316,-0.5006316 0 1 0 4.646,8.854 l 3,3 a 0.5,-0.5 0 0 0 0.708,0 l 3,-3 A 0.5006316,-0.5006316 0 0 0 10.646,8.146 L 8.5,10.293 Z" id="path2" /></svg>`;
const restore = `<svg style="width: 46px; height: 46px" viewBox="-1.6 -1.6 19.2 19.2"><path d="M 15,2 C 15,1.4477153 14.552285,1 14,1 H 2 C 1.4477153,1 1,1.4477153 1,2 v 12 c 0,0.552285 0.4477153,1 1,1 h 12 c 0.552285,0 1,-0.447715 1,-1 z M 0,2 C 0,0.8954305 0.8954305,0 2,0 h 12 c 1.104569,0 2,0.8954305 2,2 v 12 c 0,1.104569 -0.895431,2 -2,2 H 2 C 0.8954305,16 0,15.104569 0,14 Z" id="path2" /><g id="g687" transform="translate(15.647255,-0.0288128)"><path d="m -8.1462425,10.484879 -2.1460005,2.146999 c -0.472,0.472 -1.18,-0.236 -0.708,-0.708 l 3.0000005,-2.9999994 c 0.195364,-0.195858 0.512636,-0.195858 0.708,0 l 3.0000005,2.9999994 c 0.472,0.472 -0.236,1.18 -0.708,0.708 l -2.1460005,-2.146999 c -0.431103,-0.417289 -0.523896,-0.423024 -1,0 z" style="" id="path566-5" /><path d="m -8.1482677,5.5727476 -2.1460003,-2.147 c -0.472,-0.472 -1.18,0.236 -0.708,0.708 l 3.0000003,3 c 0.1953639,0.195858 0.5126361,0.195858 0.708,0 l 2.9999997,-3 c 0.472,-0.472 -0.236,-1.18 -0.708,-0.708 l -2.1459997,2.147 c -0.4311027,0.417289 -0.5238956,0.423024 -1,0 z" style="" id="path566-6-3" /></g></svg>`;
const maximize = `<svg style="width: 46px; height: 46px" viewBox="-1.6 -1.6 19.2 19.2"><path d="M 15,2 C 15,1.4477153 14.552285,1 14,1 H 2 C 1.4477153,1 1,1.4477153 1,2 v 12 c 0,0.552285 0.4477153,1 1,1 h 12 c 0.552285,0 1,-0.447715 1,-1 z M 0,2 C 0,0.8954305 0.8954305,0 2,0 h 12 c 1.104569,0 2,0.8954305 2,2 v 12 c 0,1.104569 -0.895431,2 -2,2 H 2 C 0.8954305,16 0,15.104569 0,14 Z" id="path2" /><g id="g611" transform="translate(0.2050748,-0.8829888)"><path d="m 7.2959375,11.933818 -2.146,-2.1469999 c -0.472,-0.4719998 -1.18,0.2359999 -0.708,0.7079999 l 3,3 c 0.195364,0.195858 0.512636,0.195858 0.708,0 l 3.0000005,-3 c 0.472,-0.472 -0.236,-1.1799997 -0.708,-0.7079999 L 8.2959375,11.933818 c -0.431103,0.417289 -0.523896,0.423024 -1,0 z" style="" id="path566" /><path d="m 7.2939123,5.8321596 -2.146,2.147 c -0.4719998,0.472 -1.1799998,-0.236 -0.708,-0.708 l 3,-3 c 0.1953639,-0.195858 0.5126361,-0.195858 0.708,0 l 2.9999997,3 c 0.472,0.472 -0.236,1.18 -0.708,0.708 l -2.1459997,-2.147 c -0.4311027,-0.417289 -0.5238956,-0.423024 -1,0 z" style="" id="path566-6" /></g></svg>`;
const collapse = `<svg style="width: 46px; height: 46px" viewBox="-1.6 -1.6 19.2 19.2"><path d="M 15,2 C 15,1.4477153 14.552285,1 14,1 H 2 C 1.4477153,1 1,1.4477153 1,2 v 12 c 0,0.552285 0.4477153,1 1,1 h 12 c 0.552285,0 1,-0.447715 1,-1 z M 0,2 C 0,0.8954305 0.8954305,0 2,0 h 12 c 1.104569,0 2,0.8954305 2,2 v 12 c 0,1.104569 -0.895431,2 -2,2 H 2 C 0.8954305,16 0,15.104569 0,14 Z" id="path2" /><path d="m 11.500447,8.5 c 0.666666,0 0.666666,-1 0,-1 H 4.444275 c -0.1571231,0 -0.224029,0.07336 -0.2978281,0.1459999 -0.1958579,0.195364 -0.1958579,0.5126361 0,0.7080001 0,0 0.113806,0.146 0.320186,0.146 z" style="" id="path887" /></svg>`;
const expand = `<svg style="height:46px;width:46px" version="1.1" viewBox="-1.6 -1.6 19.2 19.2" xmlns="http://www.w3.org/2000/svg"> <g fill-rule="evenodd">  <path d="m15 2c0-0.55228-0.44772-1-1-1h-12c-0.55228 0-1 0.44772-1 1v12c0 0.55228 0.44772 1 1 1h12c0.55228 0 1-0.44772 1-1zm-15 0c0-1.1046 0.89543-2 2-2h12c1.1046 0 2 0.89543 2 2v12c0 1.1046-0.89543 2-2 2h-12c-1.1046 0-2-0.89543-2-2z"/>  <path d="m4.4449 4.097c-0.01964 0-0.037678 0.0018-0.054687 0.0039-0.017011 0.0022-0.034068 0.0058-0.048828 0.0098-0.014761 4e-3 -0.028126 0.0081-0.041016 0.01367-0.012889 0.0056-0.025711 0.01268-0.037109 0.01953-0.022796 0.01371-0.041442 0.02783-0.060547 0.04492s-0.038191 0.03653-0.056641 0.05469c-0.024482 0.02442-0.046092 0.05037-0.064453 0.07813-0.018362 0.02775-0.032681 0.05776-0.044922 0.08789s-0.021223 0.06023-0.027344 0.0918c-0.00612 0.03156-0.00977 0.06366-0.00977 0.0957 0 8e-3 -4.378e-4 0.01543 0 0.02344v1.2988c0 0.02083 6.41e-5 0.04102 0.00195 0.06055 0.00189 0.01953 0.0061 0.03841 0.00977 0.05664 0.00366 0.01823 0.00836 0.03581 0.013672 0.05273 0.00531 0.01693 0.010742 0.0332 0.017578 0.04883 0.013672 0.03125 0.029785 0.0599 0.048828 0.08594s0.041016 0.04948 0.064453 0.07031 0.049316 0.03906 0.076172 0.05469c0.026855 0.01563 0.054687 0.02865 0.083984 0.03906 0.029297 0.01042 0.059082 0.01823 0.089844 0.02344 0.030762 0.0052 0.0625 0.0078 0.09375 0.0078s0.062988-0.0026 0.09375-0.0078 0.060547-0.01302 0.089844-0.02344 0.057129-0.02344 0.083984-0.03906c0.026855-0.01563 0.052734-0.03385 0.076172-0.05469 0.023437-0.02083 0.04541-0.04427 0.064453-0.07031s0.035156-0.05469 0.048828-0.08594c0.00684-0.01563 0.012268-0.0319 0.017578-0.04883s0.01001-0.0345 0.013672-0.05273c0.00366-0.01823 0.00787-0.03711 0.00977-0.05664 0.00189-0.01953 0.00195-0.03971 0.00195-0.06055v-0.82227h6v0.98633c0 0.02083 2e-3 0.04102 0.0039 0.06055s0.0042 0.03841 0.0078 0.05664c0.0037 0.01823 0.0084 0.03581 0.01367 0.05273 0.0053 0.01693 0.01074 0.0332 0.01758 0.04883 0.01367 0.03125 0.03174 0.0599 0.05078 0.08594s0.03906 0.04948 0.0625 0.07031 0.04932 0.03906 0.07617 0.05469c0.02686 0.01563 0.05469 0.02865 0.08399 0.03906 0.0293 0.01042 0.06104 0.01823 0.0918 0.02344 0.03076 0.0052 0.06055 0.0078 0.0918 0.0078s0.06299-0.0026 0.09375-0.0078 0.06055-0.01302 0.08984-0.02344c0.0293-0.01042 0.05908-0.02344 0.08594-0.03906 0.02686-0.01563 0.05078-0.03385 0.07422-0.05469 0.02344-0.02083 0.04541-0.04427 0.06445-0.07031s0.03516-0.05469 0.04883-0.08594c0.0068-0.01563 0.01422-0.0319 0.01953-0.04883 0.0053-0.01693 0.01001-0.0345 0.01367-0.05273 0.0037-0.01823 0.0059-0.03711 0.0078-0.05664s2e-3 -0.03971 2e-3 -0.06055v-1.4629c3.25e-4 -0.0078 0-0.01563 0-0.02344 0-0.03125-0.0026-0.06299-0.0078-0.09375s-0.01302-0.06055-0.02344-0.08984c-0.01042-0.0293-0.02344-0.05713-0.03906-0.08398-0.01563-0.02685-0.03385-0.05273-0.05469-0.07617-0.02083-0.02344-0.04427-0.04541-0.07031-0.06445s-0.05469-0.03516-0.08594-0.04883c-0.01563-0.0068-0.0319-0.01227-0.04883-0.01758-0.01693-0.0053-0.0345-0.01001-0.05273-0.01367-0.01823-0.0037-0.03711-0.0059-0.05664-0.0078s-0.03971-0.0039-0.06055-0.0039h-6.5z"/>  <path d="m11.555 11.903c0.01964 0 0.03768-0.0018 0.05469-0.0039 0.01701-0.0022 0.03407-0.0058 0.04883-0.0098s0.02813-0.0081 0.04102-0.01367c0.01289-0.0056 0.02571-0.01268 0.03711-0.01953 0.0228-0.01371 0.04144-0.02783 0.06055-0.04492 0.0191-0.01709 0.03819-0.03653 0.05664-0.05469 0.02448-0.02442 0.04609-0.05037 0.06445-0.07813 0.01836-0.02775 0.03268-0.05776 0.04492-0.08789s0.02122-0.06023 0.02734-0.0918c0.0061-0.03156 0.0098-0.06366 0.0098-0.0957 0-8e-3 4.38e-4 -0.01543 0-0.02344v-1.2988c0-0.02083-6.4e-5 -0.04102-2e-3 -0.06055-0.0019-0.01953-0.0061-0.03841-0.0098-0.05664s-0.0084-0.03581-0.01367-0.05273c-0.0053-0.01693-0.01074-0.0332-0.01758-0.04883-0.01367-0.03125-0.02979-0.0599-0.04883-0.08594s-0.04102-0.04948-0.06445-0.07031c-0.02344-0.02083-0.04932-0.03906-0.07617-0.05469s-0.05469-0.02865-0.08398-0.03906c-0.0293-0.01042-0.05908-0.01823-0.08984-0.02344-0.03076-0.0052-0.0625-0.0078-0.09375-0.0078s-0.06299 0.0026-0.09375 0.0078-0.06055 0.01302-0.08984 0.02344c-0.0293 0.01042-0.05713 0.02344-0.08398 0.03906-0.02685 0.01563-0.05273 0.03385-0.07617 0.05469-0.02344 0.02083-0.04541 0.04427-0.06445 0.07031s-0.03516 0.05469-0.04883 0.08594c-0.0068 0.01563-0.01227 0.0319-0.01758 0.04883-0.0053 0.01693-0.01001 0.0345-0.01367 0.05273-0.0037 0.01823-0.0079 0.03711-0.0098 0.05664s-0.0019 0.03971-0.0019 0.06055v0.82227h-6v-0.98633c0-0.02083-2e-3 -0.04102-0.0039-0.06055s-0.0042-0.03841-0.0078-0.05664c-0.0037-0.01823-0.0084-0.03581-0.01367-0.05273-0.0053-0.01693-0.01074-0.0332-0.01758-0.04883-0.01367-0.03125-0.03174-0.0599-0.05078-0.08594s-0.03906-0.04948-0.0625-0.07031-0.04932-0.03906-0.07617-0.05469c-0.02686-0.01563-0.05469-0.02865-0.08399-0.03906-0.0293-0.01042-0.06104-0.01823-0.0918-0.02344-0.03076-0.0052-0.06055-0.0078-0.0918-0.0078s-0.06299 0.0026-0.09375 0.0078-0.06055 0.01302-0.08984 0.02344c-0.0293 0.01042-0.05908 0.02344-0.08594 0.03906-0.02686 0.01563-0.05078 0.03385-0.07422 0.05469-0.02344 0.02083-0.04541 0.04427-0.06445 0.07031s-0.03516 0.05469-0.04883 0.08594c-0.0068 0.01563-0.01422 0.0319-0.01953 0.04883-0.0053 0.01693-0.01001 0.03451-0.01367 0.05273-0.0037 0.01823-0.0059 0.03711-0.0078 0.05664s-2e-3 0.03971-2e-3 0.06055v1.4629c-3.25e-4 0.0078 0 0.01563 0 0.02344 0 0.03125 0.0026 0.06299 0.0078 0.09375s0.01302 0.06055 0.02344 0.08984c0.01042 0.0293 0.02344 0.05713 0.03906 0.08398 0.01563 0.02685 0.03385 0.05273 0.05469 0.07617 0.02083 0.02344 0.04427 0.04541 0.07031 0.06445s0.05469 0.03516 0.08594 0.04883c0.01563 0.0068 0.0319 0.01227 0.04883 0.01758 0.01693 0.0053 0.0345 0.01001 0.05273 0.01367 0.01823 0.0037 0.03711 0.0059 0.05664 0.0078s0.03971 0.0039 0.06055 0.0039h6.5z"/></g></svg>`;
const visible = `<svg style="height:46px;width:46px" version="1.1" viewBox="-1.6 -1.6 19.2 19.2" xmlns="http://www.w3.org/2000/svg"> <path d="m15 2c0-0.55228-0.44772-1-1-1h-12c-0.55228 0-1 0.44772-1 1v12c0 0.55228 0.44772 1 1 1h12c0.55228 0 1-0.44772 1-1zm-15 0c0-1.1046 0.89543-2 2-2h12c1.1046 0 2 0.89543 2 2v12c0 1.1046-0.89543 2-2 2h-12c-1.1046 0-2-0.89543-2-2z" fill-rule="evenodd"/> <path d="m13.291 7.7876c-1.0729-2.491-3.0911-4.0365-5.2687-4.0365-2.1776 0-4.1958 1.5456-5.2687 4.0365a0.53112 0.53112 0 0 0 0 0.4249c1.0729 2.491 3.0911 4.0365 5.2687 4.0365 2.1776 0 4.1959-1.5456 5.2687-4.0365a0.53112 0.53112 0 0 0 0-0.4249zm-5.2687 3.3992c-1.6836 0-3.277-1.2163-4.1958-3.1867 0.91884-1.9705 2.5122-3.1867 4.1958-3.1867 1.6837 0 3.277 1.2163 4.1959 3.1867-0.91884 1.9705-2.5122 3.1867-4.1959 3.1867zm0-5.3112a2.1245 2.1245 0 1 0 2.1245 2.1245 2.1245 2.1245 0 0 0-2.1245-2.1245zm0 3.1867a1.0622 1.0622 0 1 1 1.0622-1.0622 1.0622 1.0622 0 0 1-1.0622 1.0622z" stroke-width=".53112"/></svg>`;
const notVisible = `<svg style="height:46px;width:46px" version="1.1" viewBox="-1.6 -1.6 19.2 19.2" xmlns="http://www.w3.org/2000/svg"> <path d="m15 2c0-0.55228-0.44772-1-1-1h-12c-0.55228 0-1 0.44772-1 1v12c0 0.55228 0.44772 1 1 1h12c0.55228 0 1-0.44772 1-1zm-15 0c0-1.1046 0.89543-2 2-2h12c1.1046 0 2 0.89543 2 2v12c0 1.1046-0.89543 2-2 2h-12c-1.1046 0-2-0.89543-2-2z" fill-rule="evenodd"/> <path d="m13.291 7.7876c-1.0729-2.491-3.0911-4.0365-5.2687-4.0365-2.1776 0-4.1958 1.5456-5.2687 4.0365a0.53112 0.53112 0 0 0 0 0.4249c1.0729 2.491 3.0911 4.0365 5.2687 4.0365 2.1776 0 4.1959-1.5456 5.2687-4.0365a0.53112 0.53112 0 0 0 0-0.4249zm-5.2687 3.3992c-1.6836 0-3.277-1.2163-4.1958-3.1867 0.91884-1.9705 2.5122-3.1867 4.1958-3.1867 1.6837 0 3.277 1.2163 4.1959 3.1867-0.91884 1.9705-2.5122 3.1867-4.1959 3.1867zm0-5.3112a2.1245 2.1245 0 1 0 2.1245 2.1245 2.1245 2.1245 0 0 0-2.1245-2.1245zm0 3.1867a1.0622 1.0622 0 1 1 1.0622-1.0622 1.0622 1.0622 0 0 1-1.0622 1.0622z" stroke-width=".53112"/> <path d="m12.757 3.0055c-0.11087 0.0051358-0.22696 0.051177-0.33008 0.1543l-4.9883 4.9902c-0.061946 0.061947-0.086644 0.12038-0.097656 0.17773l-4.8184 4.8164c-0.1111 0.1111-0.1066 0.2109-0.10742 0.31445-3.5e-4 0.27663 0.22337 0.50035 0.5 0.5 0 0 0.18415 0.022881 0.33008-0.12305l4.9746-4.9727c0.06758-0.06758 0.10951-0.13979 0.13281-0.21289l4.7832-4.7832c0.36828-0.36828 0.017071-0.87967-0.37891-0.86133z" fill-rule="evenodd"/></svg>`;
const fwdEnd = `<svg class="ov-icon" width="46.08" height="46.08" version="1.1" viewBox="-1.6 -1.6 19.2 19.2"><path d="m14 15c0.55228 0 1-0.44772 1-1v-12c0-0.55228-0.44772-1-1-1h-12c-0.55228 0-1 0.44772-1 1v12c0 0.55228 0.44772 1 1 1zm0-15c1.1046 0 2 0.89543 2 2v12c0 1.1046-0.89543 2-2 2h-12c-1.1046 0-2-0.89543-2-2v-12c0-1.1046 0.89543-2 2-2z" fill-rule="evenodd"/><g transform="translate(-1.1585)" fill-rule="evenodd">  <path d="m8.2964 7.5-2.147-2.146c-0.472-0.472 0.236-1.18 0.708-0.708l3 3c0.19586 0.19536 0.19586 0.51264 0 0.708l-3 3c-0.472 0.472-1.18-0.236-0.708-0.708l2.147-2.146c0.41729-0.4311 0.42302-0.5239 0-1z"/>  <path d="m12.323 4.4996c0-0.66667-1-0.66667-1 0v7.0562c0 0.15712 0.07336 0.22403 0.146 0.29783 0.19536 0.19586 0.51264 0.19586 0.708 0 0 0 0.146-0.11381 0.146-0.32019z"/></g></svg>`;
const rwdStart = `<svg class="ov-icon" width="46.08" height="46.08" version="1.1" viewBox="-1.6 -1.6 19.2 19.2"><path d="m2 15c-0.55228 0-1-0.44772-1-1v-12c0-0.55228 0.44772-1 1-1h12c0.55228 0 1 0.44772 1 1v12c0 0.55228-0.44772 1-1 1zm0-15c-1.1046 0-2 0.89543-2 2v12c0 1.1046 0.89543 2 2 2h12c1.1046 0 2-0.89543 2-2v-12c0-1.1046-0.89543-2-2-2z" fill-rule="evenodd"/><g transform="matrix(-1 0 0 1 17.159 0)" fill-rule="evenodd">  <path d="m8.2964 7.5-2.147-2.146c-0.472-0.472 0.236-1.18 0.708-0.708l3 3c0.19586 0.19536 0.19586 0.51264 0 0.708l-3 3c-0.472 0.472-1.18-0.236-0.708-0.708l2.147-2.146c0.41729-0.4311 0.42302-0.5239 0-1z"/>  <path d="m12.323 4.4996c0-0.66667-1-0.66667-1 0v7.0562c0 0.15712 0.07336 0.22403 0.146 0.29783 0.19536 0.19586 0.51264 0.19586 0.708 0 0 0 0.146-0.11381 0.146-0.32019z"/></g></svg>`;
const arrowDown = `<svg clip-rule="evenodd" fill-rule="evenodd" image-rendering="optimizeQuality" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" version="1.1" viewBox="0 0 336.96 336.36" xmlns="http://www.w3.org/2000/svg"><path d="m0 0 168.48 336.36 168.48-336.36z"/></svg>`;
const arrowUp = `<svg clip-rule="evenodd" fill-rule="evenodd" image-rendering="optimizeQuality" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" version="1.1" viewBox="0 0 336.96 336.36" xmlns="http://www.w3.org/2000/svg"><path d="m0 336.36 168.48-336.36 168.48 336.36z"/></svg>`;
const arrowDownRound = `<svg clip-rule="evenodd" fill-rule="evenodd" image-rendering="optimizeQuality" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m512 256c0 70.67-28.66 134.68-74.99 181.01s-110.34 74.99-181.01 74.99c-70.68 0-134.69-28.66-181.01-74.99-46.33-46.33-74.99-110.34-74.99-181.01 0-70.68 28.66-134.69 74.99-181.01 46.32-46.33 110.33-74.99 181.01-74.99 70.67 0 134.68 28.66 181.01 74.99 46.33 46.32 74.99 110.33 74.99 181.01zm-204.29-21.97v-67.04c0-7.53-6.19-13.72-13.73-13.72h-75.96c-7.53 0-13.72 6.17-13.72 13.72v67.03h-42.84c-16.5 0-24.78 19.64-13.86 31.54l94.74 110.57c7.44 9 21.03 9.01 28.66 0.37l93.71-111.31c10.69-12.27 1.64-31.14-14.19-31.16h-42.81zm105.52 179.2c40.22-40.24 65.11-95.84 65.11-157.23 0-61.4-24.89-117-65.11-157.23-40.24-40.23-95.84-65.11-157.23-65.11-61.4 0-117 24.88-157.23 65.11s-65.11 95.83-65.11 157.23c0 61.39 24.88 116.99 65.11 157.23 40.23 40.22 95.83 65.11 157.23 65.11 61.39 0 116.99-24.89 157.23-65.11z" fill-rule="nonzero"/></svg>`;
const arrowUpRound = `<svg clip-rule="evenodd" fill-rule="evenodd" image-rendering="optimizeQuality" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m512 256c0-70.67-28.66-134.68-74.99-181.01s-110.34-74.99-181.01-74.99c-70.68 0-134.69 28.66-181.01 74.99-46.33 46.33-74.99 110.34-74.99 181.01 0 70.68 28.66 134.69 74.99 181.01 46.32 46.33 110.33 74.99 181.01 74.99 70.67 0 134.68-28.66 181.01-74.99 46.33-46.32 74.99-110.33 74.99-181.01zm-204.29 21.97v67.04c0 7.53-6.19 13.72-13.73 13.72h-75.96c-7.53 0-13.72-6.17-13.72-13.72v-67.03h-42.84c-16.5 0-24.78-19.64-13.86-31.54l94.74-110.57c7.44-9 21.03-9.01 28.66-0.37l93.71 111.31c10.69 12.27 1.64 31.14-14.19 31.16zm105.52-179.2c40.22 40.24 65.11 95.84 65.11 157.23 0 61.4-24.89 117-65.11 157.23-40.24 40.23-95.84 65.11-157.23 65.11-61.4 0-117-24.88-157.23-65.11s-65.11-95.83-65.11-157.23c0-61.39 24.88-116.99 65.11-157.23 40.23-40.22 95.83-65.11 157.23-65.11 61.39 0 116.99 24.89 157.23 65.11z" fill-rule="nonzero"/></svg>`;
const arrowDownRoundSolid = `<svg clip-rule="evenodd" fill-rule="evenodd" image-rendering="optimizeQuality" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="M512 256c0-70.67-28.66-134.68-74.98-181.02C390.69 28.66 326.68 0 256 0S121.31 28.66 74.98 74.98C28.66 121.32 0 185.33 0 256c0 70.68 28.66 134.69 74.98 181.02C121.31 483.34 185.32 512 256 512c70.67 0 134.69-28.66 181.02-74.98C483.34 390.69 512 326.68 512 256zm-160.23-21.5h-43.38v-67.93c0-7.63-6.27-13.9-13.91-13.9H217.5c-7.62 0-13.9 6.25-13.9 13.9v67.92h-43.41c-16.71 0-25.11 19.9-14.05 31.96l96.01 112.05c7.54 9.12 21.31 9.12 29.04.37l94.96-112.8c10.83-12.43 1.66-31.55-14.38-31.57z"/></svg>`;
const arrowUpRoundSolid = `<svg clip-rule="evenodd" fill-rule="evenodd" image-rendering="optimizeQuality" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" version="1.1" viewBox="0 0 512 512" xmlns="http://www.w3.org/2000/svg"><path d="m512 256c0 70.67-28.66 134.68-74.98 181.02-46.33 46.32-110.34 74.98-181.02 74.98s-134.69-28.66-181.02-74.98c-46.32-46.34-74.98-110.35-74.98-181.02 0-70.68 28.66-134.69 74.98-181.02 46.33-46.32 110.34-74.98 181.02-74.98 70.67 0 134.69 28.66 181.02 74.98 46.32 46.33 74.98 110.34 74.98 181.02zm-160.23 21.5h-43.38v67.93c0 7.63-6.27 13.9-13.91 13.9h-76.98c-7.62 0-13.9-6.25-13.9-13.9v-67.92h-43.41c-16.71 0-25.11-19.9-14.05-31.96l96.01-112.05c7.54-9.12 21.31-9.12 29.04-0.37l94.96 112.8c10.83 12.43 1.66 31.55-14.38 31.57z"/></svg>`;
const buySolid = `<svg width="800px" height="800px" version="1.1" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">  <defs>   <clipPath id="clipPath1">    <path d="m6.1885 15.281v-9.0209h3.1721q1.0764 0 1.6765 0.65299 0.63822 0.71345 0.63822 1.7171 0 0.58043-0.22862 1.0158-0.21909 0.42323-0.743 0.84646 1.1812 0.87065 1.1812 2.1887 0 0.53206-0.19051 1.0762-0.19051 0.53206-0.51439 0.87065-0.60964 0.65299-1.7908 0.65299zm1.467-7.4731v2.0315h1.5813q1.0383 0 1.0383-1.0158 0-1.0158-1.0383-1.0158zm0 3.5793v2.3459h1.7432q1.0859 0 1.0859-1.1609 0-1.185-1.0859-1.185zm9.6876-5.1271h1.467v6.1066q0 1.4874-0.69538 2.2854-0.80016 0.91902-2.1242 0.91902t-2.1242-0.91902q-0.69538-0.79809-0.69538-2.2854v-6.1066h1.4574v6.1066q0 1.6083 1.3622 1.6083 1.3526 0 1.3526-1.6083zm6.2108 5.6834v3.3375h-1.467v-3.3375l-2.3528-5.6834h1.6289l1.4479 3.9784 1.3622-3.9784h1.6384z" display="none" stroke-width=".041213" style="white-space:pre" aria-label="BUY"/>    <path class="powerclip" d="m-5-5h42v42.001h-42zm11.189 20.281h3.2006q1.1812 0 1.7908-0.65299 0.32387-0.33859 0.51439-0.87065 0.19051-0.54416 0.19051-1.0762 0-1.3181-1.1812-2.1887 0.52391-0.42323 0.743-0.84646 0.22862-0.43532 0.22862-1.0158 0-1.0037-0.63822-1.7171-0.60012-0.65299-1.6765-0.65299h-3.1721zm1.467-7.4731v2.0315h1.5813q1.0383 0 1.0383-1.0158 0-1.0158-1.0383-1.0158zm0 3.5793v2.3459h1.7432q1.0859 0 1.0859-1.1609 0-1.185-1.0859-1.185zm9.6876-5.1271v6.1066q0 1.6083-1.3526 1.6083-1.3622 0-1.3622-1.6083v-6.1066h-1.4574v6.1066q0 1.4874 0.69538 2.2854 0.80016 0.91902 2.1242 0.91902t2.1242-0.91902q0.69538-0.79809 0.69538-2.2854v-6.1066zm6.2108 5.6834 2.2576-5.6834h-1.6384l-1.3622 3.9784-1.4479-3.9784h-1.6289l2.3528 5.6834v3.3375h1.467z" stroke-width=".041213" style="white-space:pre"/>   </clipPath>  </defs>  <g clip-path="url(#clipPath1)" fill="none" fill-rule="evenodd">   <g id="Icon-Set" transform="translate(-360 -255)" fill="#000">    <path d="m386.67 255h-21.334c-2.945 0-5.333 2.371-5.333 5.297v12.33c0 2.924 2.055 4.813 5 4.813h6.639l4.361 9.561 4.361-9.561h6.639c2.945 0 5-1.889 5-4.813v-12.33c0-2.926-2.388-5.297-5.333-5.297z"/>   </g>  </g> </svg>`;
const sellSolid = `<svg width="800px" height="800px" version="1.1" viewBox="0 0 32 32" xmlns="http://www.w3.org/2000/svg">  <defs>   <clipPath id="clipPath4">    <path d="m10.026 8.6238h-1.2531q-0.06962-1.4148-1.3576-1.4148-0.51344 0-0.81803 0.30231-0.30458 0.30231-0.30458 0.81019 0 0.49579 0.25237 0.74972 0.26107 0.24185 0.97467 0.43532l1.0182 0.26603q0.90505 0.24185 1.3054 0.83437 0.40901 0.59252 0.40901 1.6566 0 1.3785-0.7049 2.1524-0.69619 0.77391-1.958 0.77391-1.2444 0-1.9406-0.76182-0.68749-0.77391-0.74841-2.225h1.2967q0.03481 0.72554 0.40901 1.1125t1.053 0.38696q0.60917 0 0.95727-0.32649 0.3568-0.32649 0.3568-0.89483 0-0.54416-0.27848-0.83437-0.27848-0.30231-0.94856-0.4716l-0.90505-0.25394q-0.99208-0.26603-1.4098-0.81019-0.41772-0.55625-0.41772-1.6083 0-1.3181 0.64398-2.0436 0.65268-0.73763 1.8188-0.73763 1.4185 0 2.0886 1.0278 0.46123 0.71345 0.46123 1.8743zm2.5672 2.3822v2.3459h3.5245v1.5478h-4.8559v-9.0209h4.6993v1.5478h-3.3678v2.0315h3.1155v1.5478zm5.9612-5.1271v7.4731h3.1068v1.5478h-4.4469v-9.0209zm5.439 0v7.4731h3.1068v1.5478h-4.4469v-9.0209z" display="none" stroke-width=".039392" style="white-space:pre" aria-label="SELL"/>    <path class="powerclip" d="m-5-5h42v42.001h-42zm15.026 13.624q0-1.1609-0.46123-1.8743-0.67009-1.0278-2.0886-1.0278-1.1661 0-1.8188 0.73763-0.64398 0.72554-0.64398 2.0436 0 1.052 0.41772 1.6083 0.41772 0.54416 1.4098 0.81019l0.90505 0.25394q0.67009 0.16929 0.94856 0.4716 0.27848 0.29022 0.27848 0.83437 0 0.56834-0.3568 0.89483-0.3481 0.32649-0.95727 0.32649-0.67879 0-1.053-0.38696-0.3742-0.38695-0.40901-1.1125h-1.2967q0.060917 1.4511 0.74841 2.225 0.69619 0.76182 1.9406 0.76182 1.2619 0 1.958-0.77391 0.7049-0.77391 0.7049-2.1524 0-1.0641-0.40901-1.6566-0.40031-0.59252-1.3054-0.83437l-1.0182-0.26603q-0.7136-0.19348-0.97467-0.43532-0.25237-0.25394-0.25237-0.74972 0-0.50788 0.30458-0.81019t0.81803-0.30231q1.288 0 1.3576 1.4148zm2.5672 2.3822h3.1155v-1.5478h-3.1155v-2.0315h3.3678v-1.5478h-4.6993v9.0209h4.8559v-1.5478h-3.5245zm5.9612-5.1271h-1.3402v9.0209h4.4469v-1.5478h-3.1068zm5.439 0h-1.3402v9.0209h4.4469v-1.5478h-3.1068z" stroke-width=".039392" style="white-space:pre"/>   </clipPath>  </defs>  <path d="m26.667 0h-21.334c-2.945 0-5.333 2.371-5.333 5.297v12.33c0 2.924 2.055 4.813 5 4.813h6.639l4.361 9.561 4.361-9.561h6.639c2.945 0 5-1.889 5-4.813v-12.33c0-2.926-2.388-5.297-5.333-5.297z" clip-path="url(#clipPath4)" fill-rule="evenodd"/> </svg>`;
const noteSolid = `<svg width="493px" height="512px" clip-rule="evenodd" fill-rule="evenodd" image-rendering="optimizeQuality" shape-rendering="geometricPrecision" text-rendering="geometricPrecision" version="1.1" viewBox="0 0 493 511.77" xmlns="http://www.w3.org/2000/svg"><path d="m33.11 458.2 104.5-79.1c3.09-3 7.08-4.47 11.08-4.45l302.6-0.08c2.67 0 5.09-1.08 6.78-2.77 1.74-1.81 2.84-4.24 2.84-6.87v-323.2c0-2.59-1.12-5-2.86-6.74-1.78-1.78-4.2-2.9-6.76-2.9h-409.56c-2.54 0-4.94 1.14-6.72 2.92s-2.92 4.18-2.92 6.72c0 793.72 1.02 39.329 1.02 416.47zm90.6-229.77c10.9 0 19.74 8.85 19.74 19.74s-8.84 19.73-19.74 19.73c-10.89 0-19.73-8.84-19.73-19.73s8.84-19.74 19.73-19.74zm0-101.14c10.9 0 19.74 8.85 19.74 19.74s-8.84 19.74-19.74 19.74c-10.89 0-19.73-8.85-19.73-19.74s8.84-19.74 19.73-19.74zm61.72 138.89c-9.95 0-18.02-8.07-18.02-18.01 0-9.95 8.07-18.02 18.02-18.02h185.56c9.95 0 18.01 8.07 18.01 18.02 0 9.94-8.06 18.01-18.01 18.01zm0-101.13c-9.95 0-18.02-8.07-18.02-18.02 0-9.94 8.07-18.01 18.02-18.01h185.56c9.95 0 18.01 8.07 18.01 18.01 0 9.95-8.06 18.02-18.01 18.02zm-30.38 241.61-125.97 99.69c-2.96 3.32-7.24 5.42-12.01 5.42-8.85 0-17.07-7.1228-17.07-15.963v-454.08c0-11.4 4.77-21.88 12.31-29.42s18.02-12.31 29.42-12.31h409.56c11.4 0 21.9 4.74 29.45 12.29 7.5 7.51 12.26 17.96 12.26 29.44v323.2c0 11.48-4.7 21.95-12.24 29.49-7.61 7.54-18.05 12.24-29.47 12.24z" fill-rule="nonzero"/></svg>`;
const lightning = `<svg width="800px" height="800px" fill="none" version="1.1" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="m15.746 2.7281c-5.1207-2.0689-10.949 0.40512-13.018 5.5258-2.0689 5.1207 0.40512 10.949 5.5258 13.018 5.1207 2.0689 10.949-0.40508 13.018-5.5258 2.0689-5.1207-0.40508-10.949-5.5258-13.018zm-1.3378 8.3035-1.2703-0.51325c-0.21854-0.08829-0.32785-0.13246-0.3683-0.22775-0.04045-0.09529 0.0037-0.20461 0.09201-0.42314l1.6595-4.1073c0.33362-0.82575 0.50047-1.2387 0.33474-1.3523-0.16582-0.11359-0.49058 0.19103-1.1403 0.8003l-4.7426 4.4469c-1.0274 0.96338-1.541 1.445-1.4405 1.9835 0.10054 0.53837 0.75347 0.80216 2.0594 1.3298l1.2703 0.51325c0.21854 0.08829 0.32785 0.13246 0.3683 0.22775 0.04045 0.09529-0.0037 0.20461-0.09201 0.42314l-1.6595 4.1073c-0.33365 0.82582-0.50047 1.2387-0.33475 1.3523 0.16582 0.1136 0.49059-0.19104 1.1403-0.80025l4.7425-4.4469c1.0275-0.96346 1.5411-1.4451 1.4406-1.9836-0.10057-0.53838-0.75352-0.80218-2.0594-1.3298z" clip-rule="evenodd" fill-rule="evenodd"/></svg>`;
const loadingBars = `<svg enable-background="new 0 0 100 100" version="1.1" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">  <g>   <rect transform="scale(-1)" x="-15" y="-100" width="15" height="100">    <animate attributeName="height" attributeType="XML" dur="1s" repeatCount="indefinite" values="30; 100; 30"/>   </rect>   <rect transform="scale(-1)" x="-36.25" y="-100" width="15" height="100">    <animate attributeName="height" attributeType="XML" begin="0.1s" dur="1s" repeatCount="indefinite" values="30; 100; 30"/>   </rect>   <rect transform="scale(-1)" x="-57.5" y="-100" width="15" height="100">    <animate attributeName="height" attributeType="XML" begin="0.3s" dur="1s" repeatCount="indefinite" values="30; 100; 30"/>   </rect>   <rect transform="scale(-1)" x="-78.75" y="-100" width="15" height="100">    <animate attributeName="height" attributeType="XML" begin="0.5s" dur="1s" repeatCount="indefinite" values="30; 100; 30"/>   </rect>   <rect transform="scale(-1)" x="-100" y="-100" width="15" height="100">    <animate attributeName="height" attributeType="XML" begin="0.1s" dur="1s" repeatCount="indefinite" values="30; 100; 30"/>   </rect>  </g> </svg>`;
const loadingSpin = `<svg version="1.1" id="L7" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px"  viewBox="0 0 100 100" enable-background="new 0 0 100 100" xml:space="preserve">   <path fill="#fff" d="M42.3,39.6c5.7-4.3,13.9-3.1,18.1,2.7c4.3,5.7,3.1,13.9-2.7,18.1l4.1,5.5c8.8-6.5,10.6-19,4.1-27.7  c-6.5-8.8-19-10.6-27.7-4.1L42.3,39.6z">      <animateTransform         attributeName="transform"         attributeType="XML"         type="rotate"         dur="3s"         from="0 50 50"         to="360 50 50"         repeatCount="indefinite" />  </path> <path fill="#fff" d="M82,35.7C74.1,18,53.4,10.1,35.7,18S10.1,46.6,18,64.3l7.6-3.4c-6-13.5,0-29.3,13.5-35.3s29.3,0,35.3,13.5  L82,35.7z">      <animateTransform         attributeName="transform"         attributeType="XML"         type="rotate"         dur="2s"         from="0 50 50"         to="360 50 50"         repeatCount="indefinite" />  </path>   <path fill="#fff" d="M31.6,3.5C5.9,13.6-6.6,42.7,3.5,68.4c10.1,25.7,39.2,38.3,64.9,28.1l-3.1-7.9c-21.3,8.4-45.4-2-53.8-23.3  c-8.4-21.3,2-45.4,23.3-53.8L31.6,3.5z">      <animateTransform         attributeName="transform"         attributeType="XML"         type="rotate"         dur="1s"         from="0 50 50"         to="360 50 50"         repeatCount="indefinite" />  </path></svg>`;

const CHART_MINH = 300;
const CHART_MINW = 400;
const TX_MINW = `${CHART_MINW}px`;
const TX_MINH = `${CHART_MINH}px`;
const TX_MAXW = "100%";
const TX_MAXH = "100%";
const UTILSH = 30;
const TOOLSW = 35;
const TIMESCALEH = 25;
const TIMENAVIGATIONH = 25;
const TIMEH = TIMESCALEH + TIMENAVIGATIONH;
const SCALEW = 60;
const FONTWEIGHT = "normal";
const FONTSIZE = 12;
const FONTSTYLE = "normal";
const FONTFAMILY = "Avenir, Helvetica, Arial, sans-serif";
const FONTFAMILYMONO = "Andalé, Lucida, Monaco, Courier";
const COLOUR_BG = "#141414";
const COLOUR_BORDER = "#333";
const COLOUR_TXT = "#cccccc";
const COLOUR_ICON = "#888888";
const COLOUR_ICONHOVER = "#cccccc";
const ICONSIZE = "25px";
const STYLE_ROW = "position: relative;";
const GlobalStyle = {
    COLOUR_BG: COLOUR_BG,
    COLOUR_BORDER: COLOUR_BORDER,
    COLOUR_TXT: COLOUR_TXT,
    COLOUR_ICON: COLOUR_ICON,
    COLOUR_ICONHOVER: COLOUR_ICONHOVER,
    BORDER_THICKNESS: 0,
    FONTWEIGHT: FONTWEIGHT,
    FONTSIZE: FONTSIZE,
    FONTSTYLE: FONTSTYLE,
    FONTFAMILY: FONTFAMILY,
    FONT: `${FONTSTYLE} ${FONTSIZE}px ${FONTWEIGHT} ${FONTFAMILY}`,
    FONTSTRING: `font-style: ${FONTSTYLE}; font-size: ${FONTSIZE}px; font-weight: ${FONTWEIGHT}; font-family: ${FONTFAMILY};`,
};
const CanvasStyle = {
    fontSize: FONTSIZE,
    fontWeight: FONTWEIGHT,
    fontFamily: FONTFAMILY,
    paddingLeft: 3,
    paddingRight: 3,
    paddingTop: 2,
    paddingBottom: 2,
    borderWidth: 1,
    txtCol: "#000000",
    bakCol: "#cccccc",
    stroke: "#ffffff",
    fill: "#888888"
};
const dashedPatterns = {
    "─────────": [],
    "┈┈┈┈┈┈┈┈┈": [1, 1],
    "- - - - -": [10, 10],
    "─ ─ ─ ─ ─": [20, 5],
    "─ ▪ ─ ▪ ─": [15, 3, 3, 3],
};
const ToolsStyle = {
    COLOUR_ICON: COLOUR_ICON,
    COLOUR_ICONHOVER: COLOUR_ICONHOVER,
    ICONSIZE: ICONSIZE
};
const UtilsStyle = {
    COLOUR_ICON: COLOUR_ICON,
    COLOUR_ICONHOVER: COLOUR_ICONHOVER,
    ICONSIZE: ICONSIZE
};
const MenuStyle = {
    COLOUR_BG: COLOUR_BG,
    COLOUR_BORDER: COLOUR_BORDER,
    COLOUR_TXT: COLOUR_TXT,
};
const WindowStyle = {
    COLOUR_BG: COLOUR_BG,
    COLOUR_BORDER: COLOUR_BORDER,
    COLOUR_TXT: COLOUR_TXT,
    SHADOW: "rgb(0,0,0) 0px 20px 30px -10px",
    CONTENT: "padding: 1em",
    TITLE: "padding: 2px 1em 5px; background: #333; white-space: nowrap;"
};
const ProgressStyle = {
    FILL: COLOUR_ICONHOVER + "88"
};
const CandleType = {
    CANDLE_SOLID: 'candle_solid',
    CANDLE_HOLLOW: 'candle_hollow',
    CANDLE_UP_HOLLOW: 'candle_up_hollow',
    CANDLE_DOWN_HOLLOW: 'candle_down_hollow',
    OHLC: 'ohlc',
    AREA: 'area',
    LINE: 'line'
};
const CandleStyle = {
    COLOUR_CANDLE_UP: "#00F04088",
    COLOUR_CANDLE_DN: "#F0004088",
    COLOUR_WICK_UP: "#0F4",
    COLOUR_WICK_DN: "#F04",
};
const VolumeStyle = {
    COLOUR_VOLUME_UP: "#00F04044",
    COLOUR_VOLUME_DN: "#F0004044",
    ONCHART_VOLUME_HEIGHT: 15,
};
const YAxisFontSizeFactor = 1.75;
const YAxisStyle_FONTWEIGHT = 500;
const YAxisStyle_FONTSIZE = FONTSIZE + 2;
const YAxisStyle_FONTFAMILY = FONTFAMILYMONO;
const YAxisStyle = {
    COLOUR_TICK: "#888",
    COLOUR_LABEL: "888",
    COLOUR_CURSOR: "#000",
    COLOUR_CURSOR_BG: "#CCC",
    FONTFAMILY: YAxisStyle_FONTFAMILY,
    FONTSIZE: YAxisStyle_FONTSIZE,
    FONTWEIGHT: YAxisStyle_FONTWEIGHT,
    FONT_LABEL: `${YAxisStyle_FONTWEIGHT} ${YAxisStyle_FONTSIZE}px ${YAxisStyle_FONTFAMILY}`,
    FONT_LABEL_BOLD: `bold ${YAxisStyle_FONTSIZE}px ${YAxisStyle_FONTFAMILY}`
};
const XAxisStyle_FONTWEIGHT = 500;
const XAxisStyle_FONTSIZE = FONTSIZE + 2;
const XAxisStyle_FONTFAMILY = FONTFAMILYMONO;
const XAxisStyle = {
    COLOUR_TICK: "#888",
    COLOUR_LABEL: "888",
    COLOUR_CURSOR: "#000",
    COLOUR_CURSOR_BG: "#CCC",
    FONTFAMILY: XAxisStyle_FONTFAMILY,
    FONTSIZE: XAxisStyle_FONTSIZE,
    FONTWEIGHT: XAxisStyle_FONTWEIGHT,
    FONT_LABEL: `${XAxisStyle_FONTWEIGHT} ${XAxisStyle_FONTSIZE}px ${XAxisStyle_FONTFAMILY}`,
    FONT_LABEL_BOLD: `bold ${YAxisStyle_FONTSIZE}px ${YAxisStyle_FONTFAMILY}`
};
const GridStyle = {
    COLOUR_GRID: "#222"
};
const PriceLineStyle = {
    width: 1,
    stroke: "#ccc",
    dash: [1, 1]
};
const LegendStyle = {
    text: GlobalStyle.FONTSTRING,
    font: GlobalStyle.FONT,
    colour: GlobalStyle.COLOUR_TXT
};
const DividerStyle = {
    ACTIVE: "#888888C0",
    IDLE: "#FFFFFF00",
    LINE: GlobalStyle.COLOUR_BORDER,
    STYLE: "2px solid"
};
const watermark = {
    FONTSIZE: 50,
    FONTWEIGHT: "bold",
    FONTFAMILY: GlobalStyle.FONTFAMILY,
    COLOUR: "#181818",
    IMGWIDTH: "200",
    IMGHEIGHT: "200"
};
const drawingNode = {
    idle: {
        stroke: "#000",
        fill: "#ccc",
        width: 2,
        radius: 6,
    },
    hover: {
        stroke: "#c00",
        fill: "#ccc",
        width: 2,
        radius: 6,
    },
    selected: {
        stroke: "#c00",
        fill: "#ccc",
        width: 2,
        radius: 6,
    },
    active: {
        stroke: "#800",
        fill: "#fff",
        width: 2,
        radius: 6,
    },
};
const tradeIcons = { arrowDown, arrowUp, arrowDownRound, arrowUpRound, arrowDownRoundSolid, arrowUpRoundSolid, buySolid, sellSolid };
const eventIcons = { noteSolid, lightning };
const defaultTheme = {
    title: {
        display: true,
    },
    candle: {
        Type: CandleType.CANDLE_SOLID,
        UpBodyColour: CandleStyle.COLOUR_CANDLE_UP,
        UpWickColour: CandleStyle.COLOUR_WICK_UP,
        DnBodyColour: CandleStyle.COLOUR_CANDLE_DN,
        DnWickColour: CandleStyle.COLOUR_WICK_DN,
    },
    volume: {
        Height: VolumeStyle.ONCHART_VOLUME_HEIGHT,
        UpColour: VolumeStyle.COLOUR_VOLUME_UP,
        DnColour: VolumeStyle.COLOUR_VOLUME_DN,
    },
    xAxis: {
        colourTick: XAxisStyle.COLOUR_TICK,
        colourLabel: XAxisStyle.COLOUR_LABEL,
        colourCursor: XAxisStyle.COLOUR_CURSOR,
        colourCursorBG: XAxisStyle.COLOUR_CURSOR_BG,
        fontFamily: XAxisStyle.FONTFAMILY,
        fontSize: XAxisStyle.FONTSIZE,
        fontWeight: XAxisStyle.FONTWEIGHT,
        line: "#656565",
        slider: "#555555",
        handle: "#55555588",
        icon: COLOUR_ICON,
        iconHover: COLOUR_ICONHOVER
    },
    yAxis: {
        colourTick: YAxisStyle.COLOUR_TICK,
        colourLabel: YAxisStyle.COLOUR_LABEL,
        colourCursor: YAxisStyle.COLOUR_CURSOR,
        colourCursorBG: YAxisStyle.COLOUR_CURSOR_BG,
        fontFamily: YAxisStyle.FONTFAMILY,
        fontSize: YAxisStyle.FONTSIZE,
        fontWeight: YAxisStyle.FONTWEIGHT,
        line: "#656565"
    },
    chart: {
        Background: GlobalStyle.COLOUR_BG,
        BorderColour: GlobalStyle.COLOUR_BORDER,
        BorderThickness: GlobalStyle.BORDER_THICKNESS,
        TextColour: GlobalStyle.COLOUR_TXT,
        FontWeight: GlobalStyle.FONTWEIGHT,
        FontSize: GlobalStyle.FONTSIZE,
        FontStyle: GlobalStyle.FONTSTYLE,
        FontFamily: GlobalStyle.FONTFAMILY,
        Font: GlobalStyle.FONT,
        FontString: GlobalStyle.FONTSTRING,
        GridColour: GridStyle.COLOUR_GRID,
    },
    primaryPane: {
        separator: "#666"
    },
    secondaryPane: {
        separator: "#666"
    },
    tools: {
        location: false,
        width: TOOLSW
    },
    utils: {
        location: false
    },
    time: {
        navigation: false,
        font: FONTFAMILYMONO,
        colour: "#96a9db",
        handleColour: "#586ea6",
    },
    legend: {
        font: LegendStyle.font,
        colour: LegendStyle.colour,
        controls: true,
        controlsColour: "#aaa",
        controlsOver: "#fff",
        controlsW: 18,
        controlsH: 18,
    },
    icon: {
        colour: COLOUR_ICON,
        hover: COLOUR_ICONHOVER
    },
    divider: {
        active: DividerStyle.ACTIVE,
        idle: DividerStyle.IDLE,
        line: DividerStyle.LINE,
        style: DividerStyle.STYLE
    },
    window: WindowStyle,
    watermark: watermark,
    trades: {
        iconBuy: tradeIcons.arrowUp,
        iconSell: tradeIcons.arrowDown,
        iconHeight: 30,
        iconWidth: 30,
        iconMinDim: 10,
        buyColour: "#0f0",
        sellColour: "#f00",
        defaultIcons: tradeIcons,
        offset: 10,
        positionLine: 1,
        positionStyle: "1px solid",
        positionDash: [1, 0],
        stopLossColour: "#fc0",
        stopLossLine: 1,
        stopLossStyle: "1px solid",
        stopLossDash: [1, 0],
        takeProfitColour: "#0cf",
        takeProfitLine: 1,
        takeProfitStyle: "1px solid",
        takeProfitDash: [1, 0],
    },
    events: {
        iconEvent: eventIcons.lightning,
        iconHeight: 30,
        iconWidth: 30,
        iconMinDim: 10,
        iconColour: "#ccc",
        defaultIcons: eventIcons,
        offset: 10
    },
    drawing: {
        node: drawingNode
    }
};
const cssVars = `
<style id="txc_CSSVars">
  --txc-background: #141414:
  --txc-border-color: #888;
  --txc-time-scrollbar-color: #888;
  --txc-time-handle-color: #888;
  --txc-time-slider-color: #888;
  --txc-time-cursor-fore: #222;
  --txc-time-cursor-back: #ccc;
  --txc-time-icon-color: #888;
  --txc-time-icon-hover-color: #888;
</style>`;
const style = `
<style id="txc_globalCSS">
  tradex-chart {
    content-visibility: auto;
    display: grid;
    width: var(--txc-width, 100%);
    height: var(--txc-height, 100%);
    min-width: var(--txc-min-width, ${TX_MINW});
    min-height: var(--txc-min-height, ${TX_MINH});
    max-width: var(--txc-max-width, ${TX_MAXW});
    max-height: var(--txc-max-height, ${TX_MAXH});
    overflow: hidden;
    background: var(--txc-background, ${GlobalStyle.COLOUR_BG});
    font: var(--txc-font, ${GlobalStyle.FONT});
  }
  .tradeXchart .tradeXtime .navigation { 
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: stretch;
    gap: 2px;
  }
  .tradeXchart .tradeXtime .navigation .icon { 
    flex-basis: 20px;
   }
  .tradeXchart .tradeXtime .navigation #tScrollBar { 
    height: 20px; 
    border: 1px solid; 
    border-radius: 3px; 
    flex-basis: 100%;
    overflow: hidden;
  }
  .tradeXchart .tradeXtime .navigation #tScrollBar .handle { 
    height: 18px; 
    border-radius: 2px; 
    margin: 1px;
  }

  tradex-grid {
    position: absolute;
  }
</style>
`;

var __INIT__ = (function () {
    var _scriptDir = typeof document !== "undefined" && document.currentScript
        ? document.currentScript.src
        : undefined;
    if (typeof __filename !== "undefined")
        _scriptDir = _scriptDir || __filename;
    return function (__INIT__) {
        __INIT__ = __INIT__ || {};
        var Module = typeof __INIT__ !== "undefined" ? __INIT__ : {};
        var readyPromiseResolve, readyPromiseReject;
        Module["ready"] = new Promise(function (resolve, reject) {
            readyPromiseResolve = resolve;
            readyPromiseReject = reject;
        });
        var moduleOverrides = {};
        var key;
        for (key in Module) {
            if (Module.hasOwnProperty(key)) {
                moduleOverrides[key] = Module[key];
            }
        }
        var arguments_ = [];
        var thisProgram = "./this.program";
        var quit_ = function (status, toThrow) {
            throw toThrow;
        };
        var ENVIRONMENT_IS_WEB = typeof window === "object";
        var ENVIRONMENT_IS_WORKER = typeof importScripts === "function";
        var ENVIRONMENT_IS_NODE = typeof process === "object" &&
            typeof process.versions === "object" &&
            typeof process.versions.node === "string";
        var scriptDirectory = "";
        function locateFile(path) {
            if (Module["locateFile"]) {
                return Module["locateFile"](path, scriptDirectory);
            }
            return scriptDirectory + path;
        }
        var read_, readAsync, readBinary;
        function logExceptionOnExit(e) {
            if (e instanceof ExitStatus)
                return;
            var toLog = e;
            err("exiting due to exception: " + toLog);
        }
        var nodeFS;
        var nodePath;
        if (ENVIRONMENT_IS_NODE) {
            if (ENVIRONMENT_IS_WORKER) {
                scriptDirectory = require("path").dirname(scriptDirectory) + "/";
            }
            else {
                scriptDirectory = __dirname + "/";
            }
            read_ = function shell_read(filename, binary) {
                if (!nodeFS)
                    nodeFS = require("fs");
                if (!nodePath)
                    nodePath = require("path");
                filename = nodePath["normalize"](filename);
                return nodeFS["readFileSync"](filename, binary ? null : "utf8");
            };
            readBinary = function readBinary(filename) {
                var ret = read_(filename, true);
                if (!ret.buffer) {
                    ret = new Uint8Array(ret);
                }
                assert(ret.buffer);
                return ret;
            };
            readAsync = function readAsync(filename, onload, onerror) {
                if (!nodeFS)
                    nodeFS = require("fs");
                if (!nodePath)
                    nodePath = require("path");
                filename = nodePath["normalize"](filename);
                nodeFS["readFile"](filename, function (err, data) {
                    if (err)
                        onerror(err);
                    else
                        onload(data.buffer);
                });
            };
            if (process["argv"].length > 1) {
                thisProgram = process["argv"][1].replace(/\\/g, "/");
            }
            arguments_ = process["argv"].slice(2);
            process["on"]("uncaughtException", function (ex) {
                if (!(ex instanceof ExitStatus)) {
                    throw ex;
                }
            });
            process["on"]("unhandledRejection", function (reason) {
                throw reason;
            });
            quit_ = function (status, toThrow) {
                if (keepRuntimeAlive()) {
                    process["exitCode"] = status;
                    throw toThrow;
                }
                logExceptionOnExit(toThrow);
                process["exit"](status);
            };
            Module["inspect"] = function () {
                return "[Emscripten Module object]";
            };
        }
        else if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
            if (ENVIRONMENT_IS_WORKER) {
                scriptDirectory = self.location.href;
            }
            else if (typeof document !== "undefined" && document.currentScript) {
                scriptDirectory = document.currentScript.src;
            }
            if (_scriptDir) {
                scriptDirectory = _scriptDir;
            }
            if (scriptDirectory.indexOf("blob:") !== 0) {
                scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
            }
            else {
                scriptDirectory = "";
            }
            {
                read_ = function (url) {
                    var xhr = new XMLHttpRequest();
                    xhr.open("GET", url, false);
                    xhr.send(null);
                    return xhr.responseText;
                };
                if (ENVIRONMENT_IS_WORKER) {
                    readBinary = function (url) {
                        var xhr = new XMLHttpRequest();
                        xhr.open("GET", url, false);
                        xhr.responseType = "arraybuffer";
                        xhr.send(null);
                        return new Uint8Array(xhr.response);
                    };
                }
                readAsync = function (url, onload, onerror) {
                    var xhr = new XMLHttpRequest();
                    xhr.open("GET", url, true);
                    xhr.responseType = "arraybuffer";
                    xhr.onload = function () {
                        if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) {
                            onload(xhr.response);
                            return;
                        }
                        onerror();
                    };
                    xhr.onerror = onerror;
                    xhr.send(null);
                };
            }
        }
        else ;
        Module["print"] || console.log.bind(console);
        var err = Module["printErr"] || console.warn.bind(console);
        for (key in moduleOverrides) {
            if (moduleOverrides.hasOwnProperty(key)) {
                Module[key] = moduleOverrides[key];
            }
        }
        moduleOverrides = null;
        if (Module["arguments"])
            arguments_ = Module["arguments"];
        if (Module["thisProgram"])
            thisProgram = Module["thisProgram"];
        if (Module["quit"])
            quit_ = Module["quit"];
        var STACK_ALIGN = 16;
        function convertJsFunctionToWasm(func, sig) {
            if (typeof WebAssembly.Function === "function") {
                var typeNames = { i: "i32", j: "i64", f: "f32", d: "f64" };
                var type = {
                    parameters: [],
                    results: sig[0] == "v" ? [] : [typeNames[sig[0]]],
                };
                for (var i = 1; i < sig.length; ++i) {
                    type.parameters.push(typeNames[sig[i]]);
                }
                return new WebAssembly.Function(type, func);
            }
            var typeSection = [1, 0, 1, 96];
            var sigRet = sig.slice(0, 1);
            var sigParam = sig.slice(1);
            var typeCodes = { i: 127, j: 126, f: 125, d: 124 };
            typeSection.push(sigParam.length);
            for (var i = 0; i < sigParam.length; ++i) {
                typeSection.push(typeCodes[sigParam[i]]);
            }
            if (sigRet == "v") {
                typeSection.push(0);
            }
            else {
                typeSection = typeSection.concat([1, typeCodes[sigRet]]);
            }
            typeSection[1] = typeSection.length - 2;
            var bytes = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0].concat(typeSection, [2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0]));
            var module = new WebAssembly.Module(bytes);
            var instance = new WebAssembly.Instance(module, { e: { f: func } });
            var wrappedFunc = instance.exports["f"];
            return wrappedFunc;
        }
        var freeTableIndexes = [];
        var functionsInTableMap;
        function getEmptyTableSlot() {
            if (freeTableIndexes.length) {
                return freeTableIndexes.pop();
            }
            try {
                wasmTable.grow(1);
            }
            catch (err) {
                if (!(err instanceof RangeError)) {
                    throw err;
                }
                throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
            }
            return wasmTable.length - 1;
        }
        function updateTableMap(offset, count) {
            for (var i = offset; i < offset + count; i++) {
                var item = getWasmTableEntry(i);
                if (item) {
                    functionsInTableMap.set(item, i);
                }
            }
        }
        function addFunction(func, sig) {
            if (!functionsInTableMap) {
                functionsInTableMap = new WeakMap();
                updateTableMap(0, wasmTable.length);
            }
            if (functionsInTableMap.has(func)) {
                return functionsInTableMap.get(func);
            }
            var ret = getEmptyTableSlot();
            try {
                setWasmTableEntry(ret, func);
            }
            catch (err) {
                if (!(err instanceof TypeError)) {
                    throw err;
                }
                var wrapped = convertJsFunctionToWasm(func, sig);
                setWasmTableEntry(ret, wrapped);
            }
            functionsInTableMap.set(func, ret);
            return ret;
        }
        var dynamicLibraries = Module["dynamicLibraries"] || [];
        var wasmBinary;
        if (Module["wasmBinary"])
            wasmBinary = Module["wasmBinary"];
        var noExitRuntime = Module["noExitRuntime"] || true;
        if (typeof WebAssembly !== "object") {
            abort("no native wasm support detected");
        }
        var wasmMemory;
        var ABORT = false;
        var EXITSTATUS;
        function assert(condition, text) {
            if (!condition) {
                abort("Assertion failed: " + text);
            }
        }
        function getCFunc(ident) {
            var func = Module["_" + ident];
            assert(func, "Cannot call unknown function " + ident + ", make sure it is exported");
            return func;
        }
        function ccall(ident, returnType, argTypes, args, opts) {
            var toC = {
                string: function (str) {
                    var ret = 0;
                    if (str !== null && str !== undefined && str !== 0) {
                        var len = (str.length << 2) + 1;
                        ret = stackAlloc(len);
                        stringToUTF8(str, ret, len);
                    }
                    return ret;
                },
                array: function (arr) {
                    var ret = stackAlloc(arr.length);
                    writeArrayToMemory(arr, ret);
                    return ret;
                },
            };
            function convertReturnValue(ret) {
                if (returnType === "string")
                    return UTF8ToString(ret);
                if (returnType === "boolean")
                    return Boolean(ret);
                return ret;
            }
            var func = getCFunc(ident);
            var cArgs = [];
            var stack = 0;
            if (args) {
                for (var i = 0; i < args.length; i++) {
                    var converter = toC[argTypes[i]];
                    if (converter) {
                        if (stack === 0)
                            stack = stackSave();
                        cArgs[i] = converter(args[i]);
                    }
                    else {
                        cArgs[i] = args[i];
                    }
                }
            }
            var ret = func.apply(null, cArgs);
            function onDone(ret) {
                if (stack !== 0)
                    stackRestore(stack);
                return convertReturnValue(ret);
            }
            ret = onDone(ret);
            return ret;
        }
        var ALLOC_STACK = 1;
        function allocate(slab, allocator) {
            var ret;
            if (allocator == ALLOC_STACK) {
                ret = stackAlloc(slab.length);
            }
            else {
                ret = _malloc(slab.length);
            }
            if (slab.subarray || slab.slice) {
                HEAPU8.set(slab, ret);
            }
            else {
                HEAPU8.set(new Uint8Array(slab), ret);
            }
            return ret;
        }
        var UTF8Decoder = typeof TextDecoder !== "undefined" ? new TextDecoder("utf8") : undefined;
        function UTF8ArrayToString(heap, idx, maxBytesToRead) {
            var endIdx = idx + maxBytesToRead;
            var endPtr = idx;
            while (heap[endPtr] && !(endPtr >= endIdx))
                ++endPtr;
            if (endPtr - idx > 16 && heap.subarray && UTF8Decoder) {
                return UTF8Decoder.decode(heap.subarray(idx, endPtr));
            }
            else {
                var str = "";
                while (idx < endPtr) {
                    var u0 = heap[idx++];
                    if (!(u0 & 128)) {
                        str += String.fromCharCode(u0);
                        continue;
                    }
                    var u1 = heap[idx++] & 63;
                    if ((u0 & 224) == 192) {
                        str += String.fromCharCode(((u0 & 31) << 6) | u1);
                        continue;
                    }
                    var u2 = heap[idx++] & 63;
                    if ((u0 & 240) == 224) {
                        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
                    }
                    else {
                        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heap[idx++] & 63);
                    }
                    if (u0 < 65536) {
                        str += String.fromCharCode(u0);
                    }
                    else {
                        var ch = u0 - 65536;
                        str += String.fromCharCode(55296 | (ch >> 10), 56320 | (ch & 1023));
                    }
                }
            }
            return str;
        }
        function UTF8ToString(ptr, maxBytesToRead) {
            return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
        }
        function stringToUTF8Array(str, heap, outIdx, maxBytesToWrite) {
            if (!(maxBytesToWrite > 0))
                return 0;
            var startIdx = outIdx;
            var endIdx = outIdx + maxBytesToWrite - 1;
            for (var i = 0; i < str.length; ++i) {
                var u = str.charCodeAt(i);
                if (u >= 55296 && u <= 57343) {
                    var u1 = str.charCodeAt(++i);
                    u = (65536 + ((u & 1023) << 10)) | (u1 & 1023);
                }
                if (u <= 127) {
                    if (outIdx >= endIdx)
                        break;
                    heap[outIdx++] = u;
                }
                else if (u <= 2047) {
                    if (outIdx + 1 >= endIdx)
                        break;
                    heap[outIdx++] = 192 | (u >> 6);
                    heap[outIdx++] = 128 | (u & 63);
                }
                else if (u <= 65535) {
                    if (outIdx + 2 >= endIdx)
                        break;
                    heap[outIdx++] = 224 | (u >> 12);
                    heap[outIdx++] = 128 | ((u >> 6) & 63);
                    heap[outIdx++] = 128 | (u & 63);
                }
                else {
                    if (outIdx + 3 >= endIdx)
                        break;
                    heap[outIdx++] = 240 | (u >> 18);
                    heap[outIdx++] = 128 | ((u >> 12) & 63);
                    heap[outIdx++] = 128 | ((u >> 6) & 63);
                    heap[outIdx++] = 128 | (u & 63);
                }
            }
            heap[outIdx] = 0;
            return outIdx - startIdx;
        }
        function stringToUTF8(str, outPtr, maxBytesToWrite) {
            return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
        }
        function lengthBytesUTF8(str) {
            var len = 0;
            for (var i = 0; i < str.length; ++i) {
                var u = str.charCodeAt(i);
                if (u >= 55296 && u <= 57343)
                    u = (65536 + ((u & 1023) << 10)) | (str.charCodeAt(++i) & 1023);
                if (u <= 127)
                    ++len;
                else if (u <= 2047)
                    len += 2;
                else if (u <= 65535)
                    len += 3;
                else
                    len += 4;
            }
            return len;
        }
        function allocateUTF8OnStack(str) {
            var size = lengthBytesUTF8(str) + 1;
            var ret = stackAlloc(size);
            stringToUTF8Array(str, HEAP8, ret, size);
            return ret;
        }
        function writeArrayToMemory(array, buffer) {
            HEAP8.set(array, buffer);
        }
        var buffer, HEAP8, HEAPU8, HEAP32;
        function updateGlobalBufferAndViews(buf) {
            buffer = buf;
            Module["HEAP8"] = HEAP8 = new Int8Array(buf);
            Module["HEAP16"] = new Int16Array(buf);
            Module["HEAP32"] = HEAP32 = new Int32Array(buf);
            Module["HEAPU8"] = HEAPU8 = new Uint8Array(buf);
            Module["HEAPU16"] = new Uint16Array(buf);
            Module["HEAPU32"] = new Uint32Array(buf);
            Module["HEAPF32"] = new Float32Array(buf);
            Module["HEAPF64"] = new Float64Array(buf);
        }
        var INITIAL_MEMORY = Module["INITIAL_MEMORY"] || 16777216;
        if (Module["wasmMemory"]) {
            wasmMemory = Module["wasmMemory"];
        }
        else {
            wasmMemory = new WebAssembly.Memory({
                initial: INITIAL_MEMORY / 65536,
                maximum: INITIAL_MEMORY / 65536,
            });
        }
        if (wasmMemory) {
            buffer = wasmMemory.buffer;
        }
        INITIAL_MEMORY = buffer.byteLength;
        updateGlobalBufferAndViews(buffer);
        var wasmTable = new WebAssembly.Table({ initial: 1, element: "anyfunc" });
        var __ATPRERUN__ = [];
        var __ATINIT__ = [];
        var __ATMAIN__ = [];
        var __ATPOSTRUN__ = [];
        var runtimeInitialized = false;
        var runtimeKeepaliveCounter = 0;
        function keepRuntimeAlive() {
            return noExitRuntime || runtimeKeepaliveCounter > 0;
        }
        function preRun() {
            if (Module["preRun"]) {
                if (typeof Module["preRun"] == "function")
                    Module["preRun"] = [Module["preRun"]];
                while (Module["preRun"].length) {
                    addOnPreRun(Module["preRun"].shift());
                }
            }
            callRuntimeCallbacks(__ATPRERUN__);
        }
        function initRuntime() {
            runtimeInitialized = true;
            callRuntimeCallbacks(__ATINIT__);
        }
        function preMain() {
            callRuntimeCallbacks(__ATMAIN__);
        }
        function postRun() {
            if (Module["postRun"]) {
                if (typeof Module["postRun"] == "function")
                    Module["postRun"] = [Module["postRun"]];
                while (Module["postRun"].length) {
                    addOnPostRun(Module["postRun"].shift());
                }
            }
            callRuntimeCallbacks(__ATPOSTRUN__);
        }
        function addOnPreRun(cb) {
            __ATPRERUN__.unshift(cb);
        }
        function addOnInit(cb) {
            __ATINIT__.unshift(cb);
        }
        function addOnPostRun(cb) {
            __ATPOSTRUN__.unshift(cb);
        }
        var runDependencies = 0;
        var dependenciesFulfilled = null;
        function addRunDependency(id) {
            runDependencies++;
            if (Module["monitorRunDependencies"]) {
                Module["monitorRunDependencies"](runDependencies);
            }
        }
        function removeRunDependency(id) {
            runDependencies--;
            if (Module["monitorRunDependencies"]) {
                Module["monitorRunDependencies"](runDependencies);
            }
            if (runDependencies == 0) {
                if (dependenciesFulfilled) {
                    var callback = dependenciesFulfilled;
                    dependenciesFulfilled = null;
                    callback();
                }
            }
        }
        Module["preloadedImages"] = {};
        Module["preloadedAudios"] = {};
        Module["preloadedWasm"] = {};
        function abort(what) {
            {
                if (Module["onAbort"]) {
                    Module["onAbort"](what);
                }
            }
            what = "Aborted(" + what + ")";
            err(what);
            ABORT = true;
            EXITSTATUS = 1;
            what += ". Build with -s ASSERTIONS=1 for more info.";
            var e = new WebAssembly.RuntimeError(what);
            readyPromiseReject(e);
            throw e;
        }
        var dataURIPrefix = "data:application/octet-stream;base64,";
        function isDataURI(filename) {
            return filename.startsWith(dataURIPrefix);
        }
        function isFileURI(filename) {
            return filename.startsWith("file://");
        }
        var wasmBinaryFile;
        wasmBinaryFile = "talib.wasm";
        if (!isDataURI(wasmBinaryFile)) {
            wasmBinaryFile = locateFile(wasmBinaryFile);
        }
        function getBinary(file) {
            try {
                if (file == wasmBinaryFile && wasmBinary) {
                    return new Uint8Array(wasmBinary);
                }
                if (readBinary) {
                    return readBinary(file);
                }
                else {
                    throw "both async and sync fetching of the wasm failed";
                }
            }
            catch (err) {
                abort(err);
            }
        }
        function getBinaryPromise() {
            if (!wasmBinary && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER)) {
                if (typeof fetch === "function" && !isFileURI(wasmBinaryFile)) {
                    return fetch(wasmBinaryFile, { credentials: "same-origin" })
                        .then(function (response) {
                        if (!response["ok"]) {
                            throw ("failed to load wasm binary file at '" + wasmBinaryFile + "'");
                        }
                        return response["arrayBuffer"]();
                    })
                        .catch(function () {
                        return getBinary(wasmBinaryFile);
                    });
                }
                else {
                    if (readAsync) {
                        return new Promise(function (resolve, reject) {
                            readAsync(wasmBinaryFile, function (response) {
                                resolve(new Uint8Array(response));
                            }, reject);
                        });
                    }
                }
            }
            return Promise.resolve().then(function () {
                return getBinary(wasmBinaryFile);
            });
        }
        function createWasm() {
            var info = {
                env: asmLibraryArg,
                wasi_snapshot_preview1: asmLibraryArg,
                "GOT.mem": new Proxy(asmLibraryArg, GOTHandler),
                "GOT.func": new Proxy(asmLibraryArg, GOTHandler),
            };
            function receiveInstance(instance, module) {
                var exports = instance.exports;
                exports = relocateExports(exports, 1024);
                Module["asm"] = exports;
                var metadata = getDylinkMetadata(module);
                if (metadata.neededDynlibs) {
                    dynamicLibraries = metadata.neededDynlibs.concat(dynamicLibraries);
                }
                mergeLibSymbols(exports);
                addOnInit(Module["asm"]["__wasm_call_ctors"]);
                removeRunDependency();
            }
            addRunDependency();
            function receiveInstantiationResult(result) {
                receiveInstance(result["instance"], result["module"]);
            }
            function instantiateArrayBuffer(receiver) {
                return getBinaryPromise()
                    .then(function (binary) {
                    return WebAssembly.instantiate(binary, info);
                })
                    .then(function (instance) {
                    return instance;
                })
                    .then(receiver, function (reason) {
                    err("failed to asynchronously prepare wasm: " + reason);
                    abort(reason);
                });
            }
            function instantiateAsync() {
                if (!wasmBinary &&
                    typeof WebAssembly.instantiateStreaming === "function" &&
                    !isDataURI(wasmBinaryFile) &&
                    !isFileURI(wasmBinaryFile) &&
                    typeof fetch === "function") {
                    return fetch(wasmBinaryFile, { credentials: "same-origin" }).then(function (response) {
                        var result = WebAssembly.instantiateStreaming(response, info);
                        return result.then(receiveInstantiationResult, function (reason) {
                            err("wasm streaming compile failed: " + reason);
                            err("falling back to ArrayBuffer instantiation");
                            return instantiateArrayBuffer(receiveInstantiationResult);
                        });
                    });
                }
                else {
                    return instantiateArrayBuffer(receiveInstantiationResult);
                }
            }
            if (Module["instantiateWasm"]) {
                try {
                    var exports = Module["instantiateWasm"](info, receiveInstance);
                    return exports;
                }
                catch (e) {
                    err("Module.instantiateWasm callback failed with error: " + e);
                    return false;
                }
            }
            instantiateAsync().catch(readyPromiseReject);
            return {};
        }
        var GOT = {};
        var GOTHandler = {
            get: function (obj, symName) {
                if (!GOT[symName]) {
                    GOT[symName] = new WebAssembly.Global({
                        value: "i32",
                        mutable: true,
                    });
                }
                return GOT[symName];
            },
        };
        function callRuntimeCallbacks(callbacks) {
            while (callbacks.length > 0) {
                var callback = callbacks.shift();
                if (typeof callback == "function") {
                    callback(Module);
                    continue;
                }
                var func = callback.func;
                if (typeof func === "number") {
                    if (callback.arg === undefined) {
                        getWasmTableEntry(func)();
                    }
                    else {
                        getWasmTableEntry(func)(callback.arg);
                    }
                }
                else {
                    func(callback.arg === undefined ? null : callback.arg);
                }
            }
        }
        function getDylinkMetadata(binary) {
            var offset = 0;
            var end = 0;
            function getU8() {
                return binary[offset++];
            }
            function getLEB() {
                var ret = 0;
                var mul = 1;
                while (1) {
                    var byte = binary[offset++];
                    ret += (byte & 127) * mul;
                    mul *= 128;
                    if (!(byte & 128))
                        break;
                }
                return ret;
            }
            function getString() {
                var len = getLEB();
                offset += len;
                return UTF8ArrayToString(binary, offset - len, len);
            }
            var name = "dylink.0";
            if (binary instanceof WebAssembly.Module) {
                var dylinkSection = WebAssembly.Module.customSections(binary, name);
                if (dylinkSection.length === 0) {
                    name = "dylink";
                    dylinkSection = WebAssembly.Module.customSections(binary, name);
                }
                assert(dylinkSection.length != 0, "need dylink section");
                binary = new Uint8Array(dylinkSection[0]);
                end = binary.length;
            }
            else {
                var int32View = new Uint32Array(new Uint8Array(binary.subarray(0, 24)).buffer);
                assert(int32View[0] == 1836278016, "need to see wasm magic number");
                assert(binary[8] === 0, "need the dylink section to be first");
                offset = 9;
                var section_size = getLEB();
                end = offset + section_size;
                name = getString();
            }
            var customSection = { neededDynlibs: [], tlsExports: {} };
            if (name == "dylink") {
                customSection.memorySize = getLEB();
                customSection.memoryAlign = getLEB();
                customSection.tableSize = getLEB();
                customSection.tableAlign = getLEB();
                var neededDynlibsCount = getLEB();
                for (var i = 0; i < neededDynlibsCount; ++i) {
                    var name = getString();
                    customSection.neededDynlibs.push(name);
                }
            }
            else {
                assert(name === "dylink.0");
                var WASM_DYLINK_MEM_INFO = 1;
                var WASM_DYLINK_NEEDED = 2;
                var WASM_DYLINK_EXPORT_INFO = 3;
                var WASM_SYMBOL_TLS = 256;
                while (offset < end) {
                    var subsectionType = getU8();
                    var subsectionSize = getLEB();
                    if (subsectionType === WASM_DYLINK_MEM_INFO) {
                        customSection.memorySize = getLEB();
                        customSection.memoryAlign = getLEB();
                        customSection.tableSize = getLEB();
                        customSection.tableAlign = getLEB();
                    }
                    else if (subsectionType === WASM_DYLINK_NEEDED) {
                        var neededDynlibsCount = getLEB();
                        for (var i = 0; i < neededDynlibsCount; ++i) {
                            var name = getString();
                            customSection.neededDynlibs.push(name);
                        }
                    }
                    else if (subsectionType === WASM_DYLINK_EXPORT_INFO) {
                        var count = getLEB();
                        while (count--) {
                            var name = getString();
                            var flags = getLEB();
                            if (flags & WASM_SYMBOL_TLS) {
                                customSection.tlsExports[name] = 1;
                            }
                        }
                    }
                    else {
                        offset += subsectionSize;
                    }
                }
            }
            assert(offset == end);
            return customSection;
        }
        function getWasmTableEntry(funcPtr) {
            return wasmTable.get(funcPtr);
        }
        function handleException(e) {
            if (e instanceof ExitStatus || e == "unwind") {
                return EXITSTATUS;
            }
            quit_(1, e);
        }
        function asmjsMangle(x) {
            var unmangledSymbols = ["stackAlloc", "stackSave", "stackRestore"];
            return x.indexOf("dynCall_") == 0 || unmangledSymbols.includes(x)
                ? x
                : "_" + x;
        }
        function mergeLibSymbols(exports, libName) {
            for (var sym in exports) {
                if (!exports.hasOwnProperty(sym)) {
                    continue;
                }
                if (!asmLibraryArg.hasOwnProperty(sym)) {
                    asmLibraryArg[sym] = exports[sym];
                }
                var module_sym = asmjsMangle(sym);
                if (!Module.hasOwnProperty(module_sym)) {
                    Module[module_sym] = exports[sym];
                }
            }
        }
        var LDSO = { loadedLibsByName: {}, loadedLibsByHandle: {} };
        function dynCallLegacy(sig, ptr, args) {
            var f = Module["dynCall_" + sig];
            return args && args.length
                ? f.apply(null, [ptr].concat(args))
                : f.call(null, ptr);
        }
        function dynCall(sig, ptr, args) {
            if (sig.includes("j")) {
                return dynCallLegacy(sig, ptr, args);
            }
            return getWasmTableEntry(ptr).apply(null, args);
        }
        function createInvokeFunction(sig) {
            return function () {
                var sp = stackSave();
                try {
                    return dynCall(sig, arguments[0], Array.prototype.slice.call(arguments, 1));
                }
                catch (e) {
                    stackRestore(sp);
                    if (e !== e + 0 && e !== "longjmp")
                        throw e;
                    _setThrew(1, 0);
                }
            };
        }
        var ___heap_base = 5247776;
        Module["___heap_base"] = ___heap_base;
        function getMemory(size) {
            if (runtimeInitialized)
                return _malloc(size);
            var ret = ___heap_base;
            var end = (ret + size + 15) & -16;
            ___heap_base = end;
            GOT["__heap_base"].value = end;
            return ret;
        }
        function isInternalSym(symName) {
            return [
                "__cpp_exception",
                "__c_longjmp",
                "__wasm_apply_data_relocs",
                "__dso_handle",
                "__tls_size",
                "__tls_align",
                "__set_stack_limits",
                "emscripten_tls_init",
                "__wasm_init_tls",
                "__wasm_call_ctors",
            ].includes(symName);
        }
        function updateGOT(exports, replace) {
            for (var symName in exports) {
                if (isInternalSym(symName)) {
                    continue;
                }
                var value = exports[symName];
                if (symName.startsWith("orig$")) {
                    symName = symName.split("$")[1];
                    replace = true;
                }
                if (!GOT[symName]) {
                    GOT[symName] = new WebAssembly.Global({
                        value: "i32",
                        mutable: true,
                    });
                }
                if (replace || GOT[symName].value == 0) {
                    if (typeof value === "function") {
                        GOT[symName].value = addFunction(value);
                    }
                    else if (typeof value === "number") {
                        GOT[symName].value = value;
                    }
                    else if (typeof value === "bigint") {
                        GOT[symName].value = Number(value);
                    }
                    else {
                        err("unhandled export type for `" + symName + "`: " + typeof value);
                    }
                }
            }
        }
        function relocateExports(exports, memoryBase, replace) {
            var relocated = {};
            for (var e in exports) {
                var value = exports[e];
                if (typeof value === "object") {
                    value = value.value;
                }
                if (typeof value === "number") {
                    value += memoryBase;
                }
                relocated[e] = value;
            }
            updateGOT(relocated, replace);
            return relocated;
        }
        function resolveGlobalSymbol(symName, direct) {
            var sym;
            if (direct) {
                sym = asmLibraryArg["orig$" + symName];
            }
            if (!sym) {
                sym = asmLibraryArg[symName];
            }
            if (!sym) {
                sym = Module[asmjsMangle(symName)];
            }
            if (!sym && symName.startsWith("invoke_")) {
                sym = createInvokeFunction(symName.split("_")[1]);
            }
            return sym;
        }
        function alignMemory(size, alignment) {
            return Math.ceil(size / alignment) * alignment;
        }
        function loadWebAssemblyModule(binary, flags, handle) {
            var metadata = getDylinkMetadata(binary);
            function loadModule() {
                {
                    var memAlign = Math.pow(2, metadata.memoryAlign);
                    memAlign = Math.max(memAlign, STACK_ALIGN);
                    var memoryBase = metadata.memorySize
                        ? alignMemory(getMemory(metadata.memorySize + memAlign), memAlign)
                        : 0;
                    var tableBase = metadata.tableSize ? wasmTable.length : 0;
                }
                var tableGrowthNeeded = tableBase + metadata.tableSize - wasmTable.length;
                if (tableGrowthNeeded > 0) {
                    wasmTable.grow(tableGrowthNeeded);
                }
                var moduleExports;
                function resolveSymbol(sym) {
                    var resolved = resolveGlobalSymbol(sym, false);
                    if (!resolved) {
                        resolved = moduleExports[sym];
                    }
                    return resolved;
                }
                var proxyHandler = {
                    get: function (stubs, prop) {
                        switch (prop) {
                            case "__memory_base":
                                return memoryBase;
                            case "__table_base":
                                return tableBase;
                        }
                        if (prop in asmLibraryArg) {
                            return asmLibraryArg[prop];
                        }
                        if (!(prop in stubs)) {
                            var resolved;
                            stubs[prop] = function () {
                                if (!resolved)
                                    resolved = resolveSymbol(prop);
                                return resolved.apply(null, arguments);
                            };
                        }
                        return stubs[prop];
                    },
                };
                var proxy = new Proxy({}, proxyHandler);
                var info = {
                    "GOT.mem": new Proxy({}, GOTHandler),
                    "GOT.func": new Proxy({}, GOTHandler),
                    env: proxy,
                    wasi_snapshot_preview1: proxy,
                };
                function postInstantiation(instance) {
                    updateTableMap(tableBase, metadata.tableSize);
                    moduleExports = relocateExports(instance.exports, memoryBase);
                    if (!flags.allowUndefined) {
                        reportUndefinedSymbols();
                    }
                    var init = moduleExports["__wasm_call_ctors"];
                    if (init) {
                        if (runtimeInitialized) {
                            init();
                        }
                        else {
                            __ATINIT__.push(init);
                        }
                    }
                    return moduleExports;
                }
                if (flags.loadAsync) {
                    if (binary instanceof WebAssembly.Module) {
                        var instance = new WebAssembly.Instance(binary, info);
                        return Promise.resolve(postInstantiation(instance));
                    }
                    return WebAssembly.instantiate(binary, info).then(function (result) {
                        return postInstantiation(result.instance);
                    });
                }
                var module = binary instanceof WebAssembly.Module
                    ? binary
                    : new WebAssembly.Module(binary);
                var instance = new WebAssembly.Instance(module, info);
                return postInstantiation(instance);
            }
            if (flags.loadAsync) {
                return metadata.neededDynlibs
                    .reduce(function (chain, dynNeeded) {
                    return chain.then(function () {
                        return loadDynamicLibrary(dynNeeded, flags);
                    });
                }, Promise.resolve())
                    .then(function () {
                    return loadModule();
                });
            }
            metadata.neededDynlibs.forEach(function (dynNeeded) {
                loadDynamicLibrary(dynNeeded, flags);
            });
            return loadModule();
        }
        function loadDynamicLibrary(lib, flags, handle) {
            if (lib == "__main__" && !LDSO.loadedLibsByName[lib]) {
                LDSO.loadedLibsByName[lib] = {
                    refcount: Infinity,
                    name: "__main__",
                    module: Module["asm"],
                    global: true,
                };
            }
            flags = flags || { global: true, nodelete: true };
            var dso = LDSO.loadedLibsByName[lib];
            if (dso) {
                if (flags.global && !dso.global) {
                    dso.global = true;
                    if (dso.module !== "loading") {
                        mergeLibSymbols(dso.module);
                    }
                }
                if (flags.nodelete && dso.refcount !== Infinity) {
                    dso.refcount = Infinity;
                }
                dso.refcount++;
                return flags.loadAsync ? Promise.resolve(true) : true;
            }
            dso = {
                refcount: flags.nodelete ? Infinity : 1,
                name: lib,
                module: "loading",
                global: flags.global,
            };
            LDSO.loadedLibsByName[lib] = dso;
            function loadLibData(libFile) {
                if (flags.fs && flags.fs.findObject(libFile)) {
                    var libData = flags.fs.readFile(libFile, { encoding: "binary" });
                    if (!(libData instanceof Uint8Array)) {
                        libData = new Uint8Array(libData);
                    }
                    return flags.loadAsync ? Promise.resolve(libData) : libData;
                }
                if (flags.loadAsync) {
                    return new Promise(function (resolve, reject) {
                        readAsync(libFile, function (data) {
                            resolve(new Uint8Array(data));
                        }, reject);
                    });
                }
                if (!readBinary) {
                    throw new Error(libFile +
                        ": file not found, and synchronous loading of external files is not available");
                }
                return readBinary(libFile);
            }
            function getLibModule() {
                if (Module["preloadedWasm"] !== undefined &&
                    Module["preloadedWasm"][lib] !== undefined) {
                    var libModule = Module["preloadedWasm"][lib];
                    return flags.loadAsync ? Promise.resolve(libModule) : libModule;
                }
                if (flags.loadAsync) {
                    return loadLibData(lib).then(function (libData) {
                        return loadWebAssemblyModule(libData, flags);
                    });
                }
                return loadWebAssemblyModule(loadLibData(lib), flags);
            }
            function moduleLoaded(libModule) {
                if (dso.global) {
                    mergeLibSymbols(libModule);
                }
                dso.module = libModule;
            }
            if (flags.loadAsync) {
                return getLibModule().then(function (libModule) {
                    moduleLoaded(libModule);
                    return true;
                });
            }
            moduleLoaded(getLibModule());
            return true;
        }
        function reportUndefinedSymbols() {
            for (var symName in GOT) {
                if (GOT[symName].value == 0) {
                    var value = resolveGlobalSymbol(symName, true);
                    if (typeof value === "function") {
                        GOT[symName].value = addFunction(value, value.sig);
                    }
                    else if (typeof value === "number") {
                        GOT[symName].value = value;
                    }
                    else {
                        assert(false, "bad export type for `" + symName + "`: " + typeof value);
                    }
                }
            }
        }
        function preloadDylibs() {
            if (!dynamicLibraries.length) {
                reportUndefinedSymbols();
                return;
            }
            addRunDependency();
            dynamicLibraries
                .reduce(function (chain, lib) {
                return chain.then(function () {
                    return loadDynamicLibrary(lib, {
                        loadAsync: true,
                        global: true,
                        nodelete: true,
                        allowUndefined: true,
                    });
                });
            }, Promise.resolve())
                .then(function () {
                reportUndefinedSymbols();
                removeRunDependency();
            });
        }
        function setWasmTableEntry(idx, func) {
            wasmTable.set(idx, func);
        }
        var ___memory_base = new WebAssembly.Global({ value: "i32", mutable: false }, 1024);
        var ___stack_pointer = new WebAssembly.Global({ value: "i32", mutable: true }, 5247776);
        new WebAssembly.Global({ value: "i32", mutable: false }, 1);
        function abortOnCannotGrowMemory(requestedSize) {
            abort("OOM");
        }
        function _emscripten_resize_heap(requestedSize) {
            HEAPU8.length;
            abortOnCannotGrowMemory();
        }
        var asmLibraryArg = {
            __heap_base: ___heap_base,
            __indirect_function_table: wasmTable,
            __memory_base: ___memory_base,
            __stack_pointer: ___stack_pointer,
            emscripten_resize_heap: _emscripten_resize_heap,
            memory: wasmMemory,
        };
        createWasm();
        (Module["___wasm_call_ctors"] = function () {
            return (Module["___wasm_call_ctors"] =
                Module["asm"]["__wasm_call_ctors"]).apply(null, arguments);
        });
        (Module["_TA_ACCBANDS"] = function () {
            return (Module["_TA_ACCBANDS"] =
                Module["asm"]["TA_ACCBANDS"]).apply(null, arguments);
        });
        var _malloc = (Module["_malloc"] = function () {
            return (_malloc = Module["_malloc"] = Module["asm"]["malloc"]).apply(null, arguments);
        });
        (Module["_free"] = function () {
            return (Module["_free"] = Module["asm"]["free"]).apply(null, arguments);
        });
        (Module["_TA_SMA"] = function () {
            return (Module["_TA_SMA"] = Module["asm"]["TA_SMA"]).apply(null, arguments);
        });
        (Module["_TA_ACOS"] = function () {
            return (Module["_TA_ACOS"] = Module["asm"]["TA_ACOS"]).apply(null, arguments);
        });
        (Module["_TA_AD"] = function () {
            return (Module["_TA_AD"] = Module["asm"]["TA_AD"]).apply(null, arguments);
        });
        (Module["_TA_ADD"] = function () {
            return (Module["_TA_ADD"] = Module["asm"]["TA_ADD"]).apply(null, arguments);
        });
        (Module["_TA_ADOSC"] = function () {
            return (Module["_TA_ADOSC"] =
                Module["asm"]["TA_ADOSC"]).apply(null, arguments);
        });
        (Module["_TA_ADX"] = function () {
            return (Module["_TA_ADX"] = Module["asm"]["TA_ADX"]).apply(null, arguments);
        });
        (Module["_TA_ADXR"] = function () {
            return (Module["_TA_ADXR"] = Module["asm"]["TA_ADXR"]).apply(null, arguments);
        });
        (Module["_TA_APO"] = function () {
            return (Module["_TA_APO"] = Module["asm"]["TA_APO"]).apply(null, arguments);
        });
        (Module["_TA_MA"] = function () {
            return (Module["_TA_MA"] = Module["asm"]["TA_MA"]).apply(null, arguments);
        });
        (Module["_TA_AROON"] = function () {
            return (Module["_TA_AROON"] =
                Module["asm"]["TA_AROON"]).apply(null, arguments);
        });
        (Module["_TA_AROONOSC"] = function () {
            return (Module["_TA_AROONOSC"] =
                Module["asm"]["TA_AROONOSC"]).apply(null, arguments);
        });
        (Module["_TA_ASIN"] = function () {
            return (Module["_TA_ASIN"] = Module["asm"]["TA_ASIN"]).apply(null, arguments);
        });
        (Module["_TA_ATAN"] = function () {
            return (Module["_TA_ATAN"] = Module["asm"]["TA_ATAN"]).apply(null, arguments);
        });
        (Module["_TA_ATR"] = function () {
            return (Module["_TA_ATR"] = Module["asm"]["TA_ATR"]).apply(null, arguments);
        });
        (Module["_TA_TRANGE"] = function () {
            return (Module["_TA_TRANGE"] =
                Module["asm"]["TA_TRANGE"]).apply(null, arguments);
        });
        (Module["_TA_AVGDEV"] = function () {
            return (Module["_TA_AVGDEV"] =
                Module["asm"]["TA_AVGDEV"]).apply(null, arguments);
        });
        (Module["_TA_AVGPRICE"] = function () {
            return (Module["_TA_AVGPRICE"] =
                Module["asm"]["TA_AVGPRICE"]).apply(null, arguments);
        });
        (Module["_TA_BBANDS"] = function () {
            return (Module["_TA_BBANDS"] =
                Module["asm"]["TA_BBANDS"]).apply(null, arguments);
        });
        (Module["_TA_STDDEV"] = function () {
            return (Module["_TA_STDDEV"] =
                Module["asm"]["TA_STDDEV"]).apply(null, arguments);
        });
        (Module["_TA_BETA"] = function () {
            return (Module["_TA_BETA"] = Module["asm"]["TA_BETA"]).apply(null, arguments);
        });
        (Module["_TA_BOP"] = function () {
            return (Module["_TA_BOP"] = Module["asm"]["TA_BOP"]).apply(null, arguments);
        });
        (Module["_TA_CCI"] = function () {
            return (Module["_TA_CCI"] = Module["asm"]["TA_CCI"]).apply(null, arguments);
        });
        (Module["_TA_CDL2CROWS"] = function () {
            return (Module["_TA_CDL2CROWS"] =
                Module["asm"]["TA_CDL2CROWS"]).apply(null, arguments);
        });
        (Module["_TA_CDL3BLACKCROWS"] = function () {
            return (Module["_TA_CDL3BLACKCROWS"] =
                Module["asm"]["TA_CDL3BLACKCROWS"]).apply(null, arguments);
        });
        (Module["_TA_CDL3INSIDE"] = function () {
            return (Module["_TA_CDL3INSIDE"] =
                Module["asm"]["TA_CDL3INSIDE"]).apply(null, arguments);
        });
        (Module["_TA_CDL3LINESTRIKE"] = function () {
            return (Module["_TA_CDL3LINESTRIKE"] =
                Module["asm"]["TA_CDL3LINESTRIKE"]).apply(null, arguments);
        });
        (Module["_TA_CDL3OUTSIDE"] = function () {
            return (Module["_TA_CDL3OUTSIDE"] =
                Module["asm"]["TA_CDL3OUTSIDE"]).apply(null, arguments);
        });
        (Module["_TA_CDL3STARSINSOUTH"] = function () {
            return (Module["_TA_CDL3STARSINSOUTH"] =
                Module["asm"]["TA_CDL3STARSINSOUTH"]).apply(null, arguments);
        });
        (Module["_TA_CDL3WHITESOLDIERS"] = function () {
            return (Module["_TA_CDL3WHITESOLDIERS"] =
                Module["asm"]["TA_CDL3WHITESOLDIERS"]).apply(null, arguments);
        });
        (Module["_TA_CDLABANDONEDBABY"] = function () {
            return (Module["_TA_CDLABANDONEDBABY"] =
                Module["asm"]["TA_CDLABANDONEDBABY"]).apply(null, arguments);
        });
        (Module["_TA_CDLADVANCEBLOCK"] = function () {
            return (Module["_TA_CDLADVANCEBLOCK"] =
                Module["asm"]["TA_CDLADVANCEBLOCK"]).apply(null, arguments);
        });
        (Module["_TA_CDLBELTHOLD"] = function () {
            return (Module["_TA_CDLBELTHOLD"] =
                Module["asm"]["TA_CDLBELTHOLD"]).apply(null, arguments);
        });
        (Module["_TA_CDLBREAKAWAY"] = function () {
            return (Module["_TA_CDLBREAKAWAY"] =
                Module["asm"]["TA_CDLBREAKAWAY"]).apply(null, arguments);
        });
        (Module["_TA_CDLCLOSINGMARUBOZU"] =
            function () {
                return (Module["_TA_CDLCLOSINGMARUBOZU"] =
                    Module["asm"]["TA_CDLCLOSINGMARUBOZU"]).apply(null, arguments);
            });
        (Module["_TA_CDLCONCEALBABYSWALL"] =
            function () {
                return (Module["_TA_CDLCONCEALBABYSWALL"] =
                    Module["asm"]["TA_CDLCONCEALBABYSWALL"]).apply(null, arguments);
            });
        (Module["_TA_CDLCOUNTERATTACK"] = function () {
            return (Module["_TA_CDLCOUNTERATTACK"] =
                Module["asm"]["TA_CDLCOUNTERATTACK"]).apply(null, arguments);
        });
        (Module["_TA_CDLDARKCLOUDCOVER"] = function () {
            return (Module["_TA_CDLDARKCLOUDCOVER"] =
                Module["asm"]["TA_CDLDARKCLOUDCOVER"]).apply(null, arguments);
        });
        (Module["_TA_CDLDOJI"] = function () {
            return (Module["_TA_CDLDOJI"] =
                Module["asm"]["TA_CDLDOJI"]).apply(null, arguments);
        });
        (Module["_TA_CDLDOJISTAR"] = function () {
            return (Module["_TA_CDLDOJISTAR"] =
                Module["asm"]["TA_CDLDOJISTAR"]).apply(null, arguments);
        });
        (Module["_TA_CDLDRAGONFLYDOJI"] = function () {
            return (Module["_TA_CDLDRAGONFLYDOJI"] =
                Module["asm"]["TA_CDLDRAGONFLYDOJI"]).apply(null, arguments);
        });
        (Module["_TA_CDLENGULFING"] = function () {
            return (Module["_TA_CDLENGULFING"] =
                Module["asm"]["TA_CDLENGULFING"]).apply(null, arguments);
        });
        (Module["_TA_CDLEVENINGDOJISTAR"] =
            function () {
                return (Module["_TA_CDLEVENINGDOJISTAR"] =
                    Module["asm"]["TA_CDLEVENINGDOJISTAR"]).apply(null, arguments);
            });
        (Module["_TA_CDLEVENINGSTAR"] = function () {
            return (Module["_TA_CDLEVENINGSTAR"] =
                Module["asm"]["TA_CDLEVENINGSTAR"]).apply(null, arguments);
        });
        (Module["_TA_CDLGAPSIDESIDEWHITE"] =
            function () {
                return (Module["_TA_CDLGAPSIDESIDEWHITE"] =
                    Module["asm"]["TA_CDLGAPSIDESIDEWHITE"]).apply(null, arguments);
            });
        (Module["_TA_CDLGRAVESTONEDOJI"] = function () {
            return (Module["_TA_CDLGRAVESTONEDOJI"] =
                Module["asm"]["TA_CDLGRAVESTONEDOJI"]).apply(null, arguments);
        });
        (Module["_TA_CDLHAMMER"] = function () {
            return (Module["_TA_CDLHAMMER"] =
                Module["asm"]["TA_CDLHAMMER"]).apply(null, arguments);
        });
        (Module["_TA_CDLHANGINGMAN"] = function () {
            return (Module["_TA_CDLHANGINGMAN"] =
                Module["asm"]["TA_CDLHANGINGMAN"]).apply(null, arguments);
        });
        (Module["_TA_CDLHARAMI"] = function () {
            return (Module["_TA_CDLHARAMI"] =
                Module["asm"]["TA_CDLHARAMI"]).apply(null, arguments);
        });
        (Module["_TA_CDLHARAMICROSS"] = function () {
            return (Module["_TA_CDLHARAMICROSS"] =
                Module["asm"]["TA_CDLHARAMICROSS"]).apply(null, arguments);
        });
        (Module["_TA_CDLHIGHWAVE"] = function () {
            return (Module["_TA_CDLHIGHWAVE"] =
                Module["asm"]["TA_CDLHIGHWAVE"]).apply(null, arguments);
        });
        (Module["_TA_CDLHIKKAKE"] = function () {
            return (Module["_TA_CDLHIKKAKE"] =
                Module["asm"]["TA_CDLHIKKAKE"]).apply(null, arguments);
        });
        (Module["_TA_CDLHIKKAKEMOD"] = function () {
            return (Module["_TA_CDLHIKKAKEMOD"] =
                Module["asm"]["TA_CDLHIKKAKEMOD"]).apply(null, arguments);
        });
        (Module["_TA_CDLHOMINGPIGEON"] = function () {
            return (Module["_TA_CDLHOMINGPIGEON"] =
                Module["asm"]["TA_CDLHOMINGPIGEON"]).apply(null, arguments);
        });
        (Module["_TA_CDLIDENTICAL3CROWS"] =
            function () {
                return (Module["_TA_CDLIDENTICAL3CROWS"] =
                    Module["asm"]["TA_CDLIDENTICAL3CROWS"]).apply(null, arguments);
            });
        (Module["_TA_CDLINNECK"] = function () {
            return (Module["_TA_CDLINNECK"] =
                Module["asm"]["TA_CDLINNECK"]).apply(null, arguments);
        });
        (Module["_TA_CDLINVERTEDHAMMER"] = function () {
            return (Module["_TA_CDLINVERTEDHAMMER"] =
                Module["asm"]["TA_CDLINVERTEDHAMMER"]).apply(null, arguments);
        });
        (Module["_TA_CDLKICKINGBYLENGTH"] =
            function () {
                return (Module["_TA_CDLKICKINGBYLENGTH"] =
                    Module["asm"]["TA_CDLKICKINGBYLENGTH"]).apply(null, arguments);
            });
        (Module["_TA_CDLKICKING"] = function () {
            return (Module["_TA_CDLKICKING"] =
                Module["asm"]["TA_CDLKICKING"]).apply(null, arguments);
        });
        (Module["_TA_CDLLADDERBOTTOM"] = function () {
            return (Module["_TA_CDLLADDERBOTTOM"] =
                Module["asm"]["TA_CDLLADDERBOTTOM"]).apply(null, arguments);
        });
        (Module["_TA_CDLLONGLEGGEDDOJI"] = function () {
            return (Module["_TA_CDLLONGLEGGEDDOJI"] =
                Module["asm"]["TA_CDLLONGLEGGEDDOJI"]).apply(null, arguments);
        });
        (Module["_TA_CDLLONGLINE"] = function () {
            return (Module["_TA_CDLLONGLINE"] =
                Module["asm"]["TA_CDLLONGLINE"]).apply(null, arguments);
        });
        (Module["_TA_CDLMARUBOZU"] = function () {
            return (Module["_TA_CDLMARUBOZU"] =
                Module["asm"]["TA_CDLMARUBOZU"]).apply(null, arguments);
        });
        (Module["_TA_CDLMATCHINGLOW"] = function () {
            return (Module["_TA_CDLMATCHINGLOW"] =
                Module["asm"]["TA_CDLMATCHINGLOW"]).apply(null, arguments);
        });
        (Module["_TA_CDLMATHOLD"] = function () {
            return (Module["_TA_CDLMATHOLD"] =
                Module["asm"]["TA_CDLMATHOLD"]).apply(null, arguments);
        });
        (Module["_TA_CDLMORNINGDOJISTAR"] =
            function () {
                return (Module["_TA_CDLMORNINGDOJISTAR"] =
                    Module["asm"]["TA_CDLMORNINGDOJISTAR"]).apply(null, arguments);
            });
        (Module["_TA_CDLMORNINGSTAR"] = function () {
            return (Module["_TA_CDLMORNINGSTAR"] =
                Module["asm"]["TA_CDLMORNINGSTAR"]).apply(null, arguments);
        });
        (Module["_TA_CDLONNECK"] = function () {
            return (Module["_TA_CDLONNECK"] =
                Module["asm"]["TA_CDLONNECK"]).apply(null, arguments);
        });
        (Module["_TA_CDLPIERCING"] = function () {
            return (Module["_TA_CDLPIERCING"] =
                Module["asm"]["TA_CDLPIERCING"]).apply(null, arguments);
        });
        (Module["_TA_CDLRICKSHAWMAN"] = function () {
            return (Module["_TA_CDLRICKSHAWMAN"] =
                Module["asm"]["TA_CDLRICKSHAWMAN"]).apply(null, arguments);
        });
        (Module["_TA_CDLRISEFALL3METHODS"] =
            function () {
                return (Module["_TA_CDLRISEFALL3METHODS"] =
                    Module["asm"]["TA_CDLRISEFALL3METHODS"]).apply(null, arguments);
            });
        (Module["_TA_CDLSEPARATINGLINES"] =
            function () {
                return (Module["_TA_CDLSEPARATINGLINES"] =
                    Module["asm"]["TA_CDLSEPARATINGLINES"]).apply(null, arguments);
            });
        (Module["_TA_CDLSHOOTINGSTAR"] = function () {
            return (Module["_TA_CDLSHOOTINGSTAR"] =
                Module["asm"]["TA_CDLSHOOTINGSTAR"]).apply(null, arguments);
        });
        (Module["_TA_CDLSHORTLINE"] = function () {
            return (Module["_TA_CDLSHORTLINE"] =
                Module["asm"]["TA_CDLSHORTLINE"]).apply(null, arguments);
        });
        (Module["_TA_CDLSPINNINGTOP"] = function () {
            return (Module["_TA_CDLSPINNINGTOP"] =
                Module["asm"]["TA_CDLSPINNINGTOP"]).apply(null, arguments);
        });
        (Module["_TA_CDLSTALLEDPATTERN"] = function () {
            return (Module["_TA_CDLSTALLEDPATTERN"] =
                Module["asm"]["TA_CDLSTALLEDPATTERN"]).apply(null, arguments);
        });
        (Module["_TA_CDLSTICKSANDWICH"] = function () {
            return (Module["_TA_CDLSTICKSANDWICH"] =
                Module["asm"]["TA_CDLSTICKSANDWICH"]).apply(null, arguments);
        });
        (Module["_TA_CDLTAKURI"] = function () {
            return (Module["_TA_CDLTAKURI"] =
                Module["asm"]["TA_CDLTAKURI"]).apply(null, arguments);
        });
        (Module["_TA_CDLTASUKIGAP"] = function () {
            return (Module["_TA_CDLTASUKIGAP"] =
                Module["asm"]["TA_CDLTASUKIGAP"]).apply(null, arguments);
        });
        (Module["_TA_CDLTHRUSTING"] = function () {
            return (Module["_TA_CDLTHRUSTING"] =
                Module["asm"]["TA_CDLTHRUSTING"]).apply(null, arguments);
        });
        (Module["_TA_CDLTRISTAR"] = function () {
            return (Module["_TA_CDLTRISTAR"] =
                Module["asm"]["TA_CDLTRISTAR"]).apply(null, arguments);
        });
        (Module["_TA_CDLUNIQUE3RIVER"] = function () {
            return (Module["_TA_CDLUNIQUE3RIVER"] =
                Module["asm"]["TA_CDLUNIQUE3RIVER"]).apply(null, arguments);
        });
        (Module["_TA_CDLUPSIDEGAP2CROWS"] =
            function () {
                return (Module["_TA_CDLUPSIDEGAP2CROWS"] =
                    Module["asm"]["TA_CDLUPSIDEGAP2CROWS"]).apply(null, arguments);
            });
        (Module["_TA_CDLXSIDEGAP3METHODS"] =
            function () {
                return (Module["_TA_CDLXSIDEGAP3METHODS"] =
                    Module["asm"]["TA_CDLXSIDEGAP3METHODS"]).apply(null, arguments);
            });
        (Module["_TA_CEIL"] = function () {
            return (Module["_TA_CEIL"] = Module["asm"]["TA_CEIL"]).apply(null, arguments);
        });
        (Module["_TA_CMO"] = function () {
            return (Module["_TA_CMO"] = Module["asm"]["TA_CMO"]).apply(null, arguments);
        });
        (Module["_TA_CORREL"] = function () {
            return (Module["_TA_CORREL"] =
                Module["asm"]["TA_CORREL"]).apply(null, arguments);
        });
        (Module["_TA_COS"] = function () {
            return (Module["_TA_COS"] = Module["asm"]["TA_COS"]).apply(null, arguments);
        });
        (Module["_TA_COSH"] = function () {
            return (Module["_TA_COSH"] = Module["asm"]["TA_COSH"]).apply(null, arguments);
        });
        (Module["_TA_DEMA"] = function () {
            return (Module["_TA_DEMA"] = Module["asm"]["TA_DEMA"]).apply(null, arguments);
        });
        (Module["_TA_DIV"] = function () {
            return (Module["_TA_DIV"] = Module["asm"]["TA_DIV"]).apply(null, arguments);
        });
        (Module["_TA_DX"] = function () {
            return (Module["_TA_DX"] = Module["asm"]["TA_DX"]).apply(null, arguments);
        });
        (Module["_TA_EMA"] = function () {
            return (Module["_TA_EMA"] = Module["asm"]["TA_EMA"]).apply(null, arguments);
        });
        (Module["_TA_EXP"] = function () {
            return (Module["_TA_EXP"] = Module["asm"]["TA_EXP"]).apply(null, arguments);
        });
        (Module["_TA_FLOOR"] = function () {
            return (Module["_TA_FLOOR"] =
                Module["asm"]["TA_FLOOR"]).apply(null, arguments);
        });
        (Module["_TA_HT_DCPERIOD"] = function () {
            return (Module["_TA_HT_DCPERIOD"] =
                Module["asm"]["TA_HT_DCPERIOD"]).apply(null, arguments);
        });
        (Module["_TA_HT_DCPHASE"] = function () {
            return (Module["_TA_HT_DCPHASE"] =
                Module["asm"]["TA_HT_DCPHASE"]).apply(null, arguments);
        });
        (Module["_TA_HT_PHASOR"] = function () {
            return (Module["_TA_HT_PHASOR"] =
                Module["asm"]["TA_HT_PHASOR"]).apply(null, arguments);
        });
        (Module["_TA_HT_SINE"] = function () {
            return (Module["_TA_HT_SINE"] =
                Module["asm"]["TA_HT_SINE"]).apply(null, arguments);
        });
        (Module["_TA_HT_TRENDLINE"] = function () {
            return (Module["_TA_HT_TRENDLINE"] =
                Module["asm"]["TA_HT_TRENDLINE"]).apply(null, arguments);
        });
        (Module["_TA_HT_TRENDMODE"] = function () {
            return (Module["_TA_HT_TRENDMODE"] =
                Module["asm"]["TA_HT_TRENDMODE"]).apply(null, arguments);
        });
        (Module["_TA_IMI"] = function () {
            return (Module["_TA_IMI"] = Module["asm"]["TA_IMI"]).apply(null, arguments);
        });
        (Module["_TA_KAMA"] = function () {
            return (Module["_TA_KAMA"] = Module["asm"]["TA_KAMA"]).apply(null, arguments);
        });
        (Module["_TA_LINEARREG_ANGLE"] = function () {
            return (Module["_TA_LINEARREG_ANGLE"] =
                Module["asm"]["TA_LINEARREG_ANGLE"]).apply(null, arguments);
        });
        (Module["_TA_LINEARREG"] = function () {
            return (Module["_TA_LINEARREG"] =
                Module["asm"]["TA_LINEARREG"]).apply(null, arguments);
        });
        (Module["_TA_LINEARREG_INTERCEPT"] =
            function () {
                return (Module["_TA_LINEARREG_INTERCEPT"] =
                    Module["asm"]["TA_LINEARREG_INTERCEPT"]).apply(null, arguments);
            });
        (Module["_TA_LINEARREG_SLOPE"] = function () {
            return (Module["_TA_LINEARREG_SLOPE"] =
                Module["asm"]["TA_LINEARREG_SLOPE"]).apply(null, arguments);
        });
        (Module["_TA_LN"] = function () {
            return (Module["_TA_LN"] = Module["asm"]["TA_LN"]).apply(null, arguments);
        });
        (Module["_TA_LOG10"] = function () {
            return (Module["_TA_LOG10"] =
                Module["asm"]["TA_LOG10"]).apply(null, arguments);
        });
        (Module["_TA_WMA"] = function () {
            return (Module["_TA_WMA"] = Module["asm"]["TA_WMA"]).apply(null, arguments);
        });
        (Module["_TA_TEMA"] = function () {
            return (Module["_TA_TEMA"] = Module["asm"]["TA_TEMA"]).apply(null, arguments);
        });
        (Module["_TA_TRIMA"] = function () {
            return (Module["_TA_TRIMA"] =
                Module["asm"]["TA_TRIMA"]).apply(null, arguments);
        });
        (Module["_TA_MAMA"] = function () {
            return (Module["_TA_MAMA"] = Module["asm"]["TA_MAMA"]).apply(null, arguments);
        });
        (Module["_TA_T3"] = function () {
            return (Module["_TA_T3"] = Module["asm"]["TA_T3"]).apply(null, arguments);
        });
        (Module["_TA_MACD"] = function () {
            return (Module["_TA_MACD"] = Module["asm"]["TA_MACD"]).apply(null, arguments);
        });
        (Module["_TA_MACDEXT"] = function () {
            return (Module["_TA_MACDEXT"] =
                Module["asm"]["TA_MACDEXT"]).apply(null, arguments);
        });
        (Module["_TA_MACDFIX"] = function () {
            return (Module["_TA_MACDFIX"] =
                Module["asm"]["TA_MACDFIX"]).apply(null, arguments);
        });
        (Module["_TA_MAVP"] = function () {
            return (Module["_TA_MAVP"] = Module["asm"]["TA_MAVP"]).apply(null, arguments);
        });
        (Module["_TA_MAX"] = function () {
            return (Module["_TA_MAX"] = Module["asm"]["TA_MAX"]).apply(null, arguments);
        });
        (Module["_TA_MAXINDEX"] = function () {
            return (Module["_TA_MAXINDEX"] =
                Module["asm"]["TA_MAXINDEX"]).apply(null, arguments);
        });
        (Module["_TA_MEDPRICE"] = function () {
            return (Module["_TA_MEDPRICE"] =
                Module["asm"]["TA_MEDPRICE"]).apply(null, arguments);
        });
        (Module["_TA_MFI"] = function () {
            return (Module["_TA_MFI"] = Module["asm"]["TA_MFI"]).apply(null, arguments);
        });
        (Module["_TA_MIDPOINT"] = function () {
            return (Module["_TA_MIDPOINT"] =
                Module["asm"]["TA_MIDPOINT"]).apply(null, arguments);
        });
        (Module["_TA_MIDPRICE"] = function () {
            return (Module["_TA_MIDPRICE"] =
                Module["asm"]["TA_MIDPRICE"]).apply(null, arguments);
        });
        (Module["_TA_MIN"] = function () {
            return (Module["_TA_MIN"] = Module["asm"]["TA_MIN"]).apply(null, arguments);
        });
        (Module["_TA_MININDEX"] = function () {
            return (Module["_TA_MININDEX"] =
                Module["asm"]["TA_MININDEX"]).apply(null, arguments);
        });
        (Module["_TA_MINMAX"] = function () {
            return (Module["_TA_MINMAX"] =
                Module["asm"]["TA_MINMAX"]).apply(null, arguments);
        });
        (Module["_TA_MINMAXINDEX"] = function () {
            return (Module["_TA_MINMAXINDEX"] =
                Module["asm"]["TA_MINMAXINDEX"]).apply(null, arguments);
        });
        (Module["_TA_MINUS_DI"] = function () {
            return (Module["_TA_MINUS_DI"] =
                Module["asm"]["TA_MINUS_DI"]).apply(null, arguments);
        });
        (Module["_TA_MINUS_DM"] = function () {
            return (Module["_TA_MINUS_DM"] =
                Module["asm"]["TA_MINUS_DM"]).apply(null, arguments);
        });
        (Module["_TA_MOM"] = function () {
            return (Module["_TA_MOM"] = Module["asm"]["TA_MOM"]).apply(null, arguments);
        });
        (Module["_TA_MULT"] = function () {
            return (Module["_TA_MULT"] = Module["asm"]["TA_MULT"]).apply(null, arguments);
        });
        (Module["_TA_NATR"] = function () {
            return (Module["_TA_NATR"] = Module["asm"]["TA_NATR"]).apply(null, arguments);
        });
        (Module["_TA_OBV"] = function () {
            return (Module["_TA_OBV"] = Module["asm"]["TA_OBV"]).apply(null, arguments);
        });
        (Module["_TA_PLUS_DI"] = function () {
            return (Module["_TA_PLUS_DI"] =
                Module["asm"]["TA_PLUS_DI"]).apply(null, arguments);
        });
        (Module["_TA_PLUS_DM"] = function () {
            return (Module["_TA_PLUS_DM"] =
                Module["asm"]["TA_PLUS_DM"]).apply(null, arguments);
        });
        (Module["_TA_PPO"] = function () {
            return (Module["_TA_PPO"] = Module["asm"]["TA_PPO"]).apply(null, arguments);
        });
        (Module["_TA_ROC"] = function () {
            return (Module["_TA_ROC"] = Module["asm"]["TA_ROC"]).apply(null, arguments);
        });
        (Module["_TA_ROCP"] = function () {
            return (Module["_TA_ROCP"] = Module["asm"]["TA_ROCP"]).apply(null, arguments);
        });
        (Module["_TA_ROCR100"] = function () {
            return (Module["_TA_ROCR100"] =
                Module["asm"]["TA_ROCR100"]).apply(null, arguments);
        });
        (Module["_TA_ROCR"] = function () {
            return (Module["_TA_ROCR"] = Module["asm"]["TA_ROCR"]).apply(null, arguments);
        });
        (Module["_TA_RSI"] = function () {
            return (Module["_TA_RSI"] = Module["asm"]["TA_RSI"]).apply(null, arguments);
        });
        (Module["_TA_SAR"] = function () {
            return (Module["_TA_SAR"] = Module["asm"]["TA_SAR"]).apply(null, arguments);
        });
        (Module["_TA_SAREXT"] = function () {
            return (Module["_TA_SAREXT"] =
                Module["asm"]["TA_SAREXT"]).apply(null, arguments);
        });
        (Module["_TA_SIN"] = function () {
            return (Module["_TA_SIN"] = Module["asm"]["TA_SIN"]).apply(null, arguments);
        });
        (Module["_TA_SINH"] = function () {
            return (Module["_TA_SINH"] = Module["asm"]["TA_SINH"]).apply(null, arguments);
        });
        (Module["_TA_SQRT"] = function () {
            return (Module["_TA_SQRT"] = Module["asm"]["TA_SQRT"]).apply(null, arguments);
        });
        (Module["_TA_STOCH"] = function () {
            return (Module["_TA_STOCH"] =
                Module["asm"]["TA_STOCH"]).apply(null, arguments);
        });
        (Module["_TA_STOCHF"] = function () {
            return (Module["_TA_STOCHF"] =
                Module["asm"]["TA_STOCHF"]).apply(null, arguments);
        });
        (Module["_TA_STOCHRSI"] = function () {
            return (Module["_TA_STOCHRSI"] =
                Module["asm"]["TA_STOCHRSI"]).apply(null, arguments);
        });
        (Module["_TA_SUB"] = function () {
            return (Module["_TA_SUB"] = Module["asm"]["TA_SUB"]).apply(null, arguments);
        });
        (Module["_TA_SUM"] = function () {
            return (Module["_TA_SUM"] = Module["asm"]["TA_SUM"]).apply(null, arguments);
        });
        (Module["_TA_TAN"] = function () {
            return (Module["_TA_TAN"] = Module["asm"]["TA_TAN"]).apply(null, arguments);
        });
        (Module["_TA_TANH"] = function () {
            return (Module["_TA_TANH"] = Module["asm"]["TA_TANH"]).apply(null, arguments);
        });
        (Module["_TA_TRIX"] = function () {
            return (Module["_TA_TRIX"] = Module["asm"]["TA_TRIX"]).apply(null, arguments);
        });
        (Module["_TA_TSF"] = function () {
            return (Module["_TA_TSF"] = Module["asm"]["TA_TSF"]).apply(null, arguments);
        });
        (Module["_TA_TYPPRICE"] = function () {
            return (Module["_TA_TYPPRICE"] =
                Module["asm"]["TA_TYPPRICE"]).apply(null, arguments);
        });
        (Module["_TA_ULTOSC"] = function () {
            return (Module["_TA_ULTOSC"] =
                Module["asm"]["TA_ULTOSC"]).apply(null, arguments);
        });
        (Module["_TA_VAR"] = function () {
            return (Module["_TA_VAR"] = Module["asm"]["TA_VAR"]).apply(null, arguments);
        });
        (Module["_TA_WCLPRICE"] = function () {
            return (Module["_TA_WCLPRICE"] =
                Module["asm"]["TA_WCLPRICE"]).apply(null, arguments);
        });
        (Module["_TA_WILLR"] = function () {
            return (Module["_TA_WILLR"] =
                Module["asm"]["TA_WILLR"]).apply(null, arguments);
        });
        var stackSave = (Module["stackSave"] = function () {
            return (stackSave = Module["stackSave"] =
                Module["asm"]["stackSave"]).apply(null, arguments);
        });
        var stackRestore = (Module["stackRestore"] = function () {
            return (stackRestore = Module["stackRestore"] =
                Module["asm"]["stackRestore"]).apply(null, arguments);
        });
        var stackAlloc = (Module["stackAlloc"] = function () {
            return (stackAlloc = Module["stackAlloc"] =
                Module["asm"]["stackAlloc"]).apply(null, arguments);
        });
        var _setThrew = (Module["_setThrew"] = function () {
            return (_setThrew = Module["_setThrew"] =
                Module["asm"]["setThrew"]).apply(null, arguments);
        });
        Module["ccall"] = ccall;
        Module["allocate"] = allocate;
        var calledRun;
        function ExitStatus(status) {
            this.name = "ExitStatus";
            this.message = "Program terminated with exit(" + status + ")";
            this.status = status;
        }
        dependenciesFulfilled = function runCaller() {
            if (!calledRun)
                run();
            if (!calledRun)
                dependenciesFulfilled = runCaller;
        };
        function callMain(args) {
            var entryFunction = Module["_main"];
            if (!entryFunction)
                return;
            args = args || [];
            var argc = args.length + 1;
            var argv = stackAlloc((argc + 1) * 4);
            HEAP32[argv >> 2] = allocateUTF8OnStack(thisProgram);
            for (var i = 1; i < argc; i++) {
                HEAP32[(argv >> 2) + i] = allocateUTF8OnStack(args[i - 1]);
            }
            HEAP32[(argv >> 2) + argc] = 0;
            try {
                var ret = entryFunction(argc, argv);
                exit(ret, true);
                return ret;
            }
            catch (e) {
                return handleException(e);
            }
            finally {
            }
        }
        var dylibsLoaded = false;
        function run(args) {
            args = args || arguments_;
            if (runDependencies > 0) {
                return;
            }
            if (!dylibsLoaded) {
                preloadDylibs();
                dylibsLoaded = true;
                if (runDependencies > 0) {
                    return;
                }
            }
            preRun();
            if (runDependencies > 0) {
                return;
            }
            function doRun() {
                if (calledRun)
                    return;
                calledRun = true;
                Module["calledRun"] = true;
                if (ABORT)
                    return;
                initRuntime();
                preMain();
                readyPromiseResolve(Module);
                if (Module["onRuntimeInitialized"])
                    Module["onRuntimeInitialized"]();
                if (shouldRunNow)
                    callMain(args);
                postRun();
            }
            if (Module["setStatus"]) {
                Module["setStatus"]("Running...");
                setTimeout(function () {
                    setTimeout(function () {
                        Module["setStatus"]("");
                    }, 1);
                    doRun();
                }, 1);
            }
            else {
                doRun();
            }
        }
        Module["run"] = run;
        function exit(status, implicit) {
            EXITSTATUS = status;
            procExit(status);
        }
        function procExit(code) {
            EXITSTATUS = code;
            if (!keepRuntimeAlive()) {
                if (Module["onExit"])
                    Module["onExit"](code);
                ABORT = true;
            }
            quit_(code, new ExitStatus(code));
        }
        if (Module["preInit"]) {
            if (typeof Module["preInit"] == "function")
                Module["preInit"] = [Module["preInit"]];
            while (Module["preInit"].length > 0) {
                Module["preInit"].pop()();
            }
        }
        var shouldRunNow = true;
        if (Module["noInitialRun"])
            shouldRunNow = false;
        run();
        return __INIT__.ready;
    };
})();
const API = { "ACCBANDS": { "name": "ACCBANDS", "camelCaseName": "accBands", "group": "Overlap Studies", "description": "Acceleration Bands", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 20, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "upperBand", "type": "Double[]", "plotHint": "limit_upper" }, { "name": "middleBand", "type": "Double[]", "plotHint": "line" }, { "name": "lowerBand", "type": "Double[]", "plotHint": "limit_lower" }] }, "ACOS": { "name": "ACOS", "camelCaseName": "acos", "group": "Math Transform", "description": "Vector Trigonometric ACos", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "AD": { "name": "AD", "camelCaseName": "ad", "group": "Volume Indicators", "description": "Chaikin A/D Line", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }, { "name": "volume", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "ADD": { "name": "ADD", "camelCaseName": "add", "group": "Math Operators", "description": "Vector Arithmetic Add", "inputs": [{ "name": "inReal0", "type": "Double[]" }, { "name": "inReal1", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "ADOSC": { "name": "ADOSC", "camelCaseName": "adOsc", "group": "Volume Indicators", "description": "Chaikin A/D Oscillator", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }, { "name": "volume", "type": "Double[]" }], "options": [{ "name": "fastPeriod", "displayName": "Fast Period", "defaultValue": 3, "hint": "Number of period for the fast MA", "type": "Integer", "range": { "min": 2, "max": 100000 } }, { "name": "slowPeriod", "displayName": "Slow Period", "defaultValue": 10, "hint": "Number of period for the slow MA", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "ADX": { "name": "ADX", "camelCaseName": "adx", "group": "Momentum Indicators", "description": "Average Directional Movement Index", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "ADXR": { "name": "ADXR", "camelCaseName": "adxr", "group": "Momentum Indicators", "description": "Average Directional Movement Index Rating", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "APO": { "name": "APO", "camelCaseName": "apo", "group": "Momentum Indicators", "description": "Absolute Price Oscillator", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "fastPeriod", "displayName": "Fast Period", "defaultValue": 12, "hint": "Number of period for the fast MA", "type": "Integer", "range": { "min": 2, "max": 100000 } }, { "name": "slowPeriod", "displayName": "Slow Period", "defaultValue": 26, "hint": "Number of period for the slow MA", "type": "Integer", "range": { "min": 2, "max": 100000 } }, { "name": "MAType", "displayName": "MA Type", "defaultValue": 0, "hint": "Type of Moving Average", "type": "MAType" }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "AROON": { "name": "AROON", "camelCaseName": "aroon", "group": "Momentum Indicators", "description": "Aroon", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "aroonDown", "type": "Double[]", "plotHint": "line_dash" }, { "name": "aroonUp", "type": "Double[]", "plotHint": "line" }] }, "AROONOSC": { "name": "AROONOSC", "camelCaseName": "aroonOsc", "group": "Momentum Indicators", "description": "Aroon Oscillator", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "ASIN": { "name": "ASIN", "camelCaseName": "asin", "group": "Math Transform", "description": "Vector Trigonometric ASin", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "ATAN": { "name": "ATAN", "camelCaseName": "atan", "group": "Math Transform", "description": "Vector Trigonometric ATan", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "ATR": { "name": "ATR", "camelCaseName": "atr", "group": "Volatility Indicators", "description": "Average True Range", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 1, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "AVGDEV": { "name": "AVGDEV", "camelCaseName": "avgDev", "group": "Price Transform", "description": "Average Deviation", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "AVGPRICE": { "name": "AVGPRICE", "camelCaseName": "avgPrice", "group": "Price Transform", "description": "Average Price", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "BBANDS": { "name": "BBANDS", "camelCaseName": "bbands", "group": "Overlap Studies", "description": "Bollinger Bands", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 5, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }, { "name": "nbDevUp", "displayName": "Deviations up", "defaultValue": 2, "hint": "Deviation multiplier for upper band", "type": "Double", "range": { "min": -3e+37, "max": 3e+37 } }, { "name": "nbDevDn", "displayName": "Deviations down", "defaultValue": 2, "hint": "Deviation multiplier for lower band", "type": "Double", "range": { "min": -3e+37, "max": 3e+37 } }, { "name": "MAType", "displayName": "MA Type", "defaultValue": 0, "hint": "Type of Moving Average", "type": "MAType" }], "outputs": [{ "name": "upperBand", "type": "Double[]", "plotHint": "limit_upper" }, { "name": "middleBand", "type": "Double[]", "plotHint": "line" }, { "name": "lowerBand", "type": "Double[]", "plotHint": "limit_lower" }] }, "BETA": { "name": "BETA", "camelCaseName": "beta", "group": "Statistic Functions", "description": "Beta", "inputs": [{ "name": "inReal0", "type": "Double[]" }, { "name": "inReal1", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 5, "hint": "Number of period", "type": "Integer", "range": { "min": 1, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "BOP": { "name": "BOP", "camelCaseName": "bop", "group": "Momentum Indicators", "description": "Balance Of Power", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "CCI": { "name": "CCI", "camelCaseName": "cci", "group": "Momentum Indicators", "description": "Commodity Channel Index", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "CDL2CROWS": { "name": "CDL2CROWS", "camelCaseName": "cdl2Crows", "group": "Pattern Recognition", "description": "Two Crows", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDL3BLACKCROWS": { "name": "CDL3BLACKCROWS", "camelCaseName": "cdl3BlackCrows", "group": "Pattern Recognition", "description": "Three Black Crows", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDL3INSIDE": { "name": "CDL3INSIDE", "camelCaseName": "cdl3Inside", "group": "Pattern Recognition", "description": "Three Inside Up/Down", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDL3LINESTRIKE": { "name": "CDL3LINESTRIKE", "camelCaseName": "cdl3LineStrike", "group": "Pattern Recognition", "description": "Three-Line Strike ", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDL3OUTSIDE": { "name": "CDL3OUTSIDE", "camelCaseName": "cdl3Outside", "group": "Pattern Recognition", "description": "Three Outside Up/Down", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDL3STARSINSOUTH": { "name": "CDL3STARSINSOUTH", "camelCaseName": "cdl3StarsInSouth", "group": "Pattern Recognition", "description": "Three Stars In The South", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDL3WHITESOLDIERS": { "name": "CDL3WHITESOLDIERS", "camelCaseName": "cdl3WhiteSoldiers", "group": "Pattern Recognition", "description": "Three Advancing White Soldiers", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLABANDONEDBABY": { "name": "CDLABANDONEDBABY", "camelCaseName": "cdlAbandonedBaby", "group": "Pattern Recognition", "description": "Abandoned Baby", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [{ "name": "penetration", "displayName": "Penetration", "defaultValue": 0.3, "hint": "Percentage of penetration of a candle within another candle", "type": "Double", "range": { "min": 0, "max": 3e+37 } }], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLADVANCEBLOCK": { "name": "CDLADVANCEBLOCK", "camelCaseName": "cdlAdvanceBlock", "group": "Pattern Recognition", "description": "Advance Block", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLBELTHOLD": { "name": "CDLBELTHOLD", "camelCaseName": "cdlBeltHold", "group": "Pattern Recognition", "description": "Belt-hold", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLBREAKAWAY": { "name": "CDLBREAKAWAY", "camelCaseName": "cdlBreakaway", "group": "Pattern Recognition", "description": "Breakaway", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLCLOSINGMARUBOZU": { "name": "CDLCLOSINGMARUBOZU", "camelCaseName": "cdlClosingMarubozu", "group": "Pattern Recognition", "description": "Closing Marubozu", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLCONCEALBABYSWALL": { "name": "CDLCONCEALBABYSWALL", "camelCaseName": "cdlConcealBabysWall", "group": "Pattern Recognition", "description": "Concealing Baby Swallow", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLCOUNTERATTACK": { "name": "CDLCOUNTERATTACK", "camelCaseName": "cdlCounterAttack", "group": "Pattern Recognition", "description": "Counterattack", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLDARKCLOUDCOVER": { "name": "CDLDARKCLOUDCOVER", "camelCaseName": "cdlDarkCloudCover", "group": "Pattern Recognition", "description": "Dark Cloud Cover", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [{ "name": "penetration", "displayName": "Penetration", "defaultValue": 0.5, "hint": "Percentage of penetration of a candle within another candle", "type": "Double", "range": { "min": 0, "max": 3e+37 } }], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLDOJI": { "name": "CDLDOJI", "camelCaseName": "cdlDoji", "group": "Pattern Recognition", "description": "Doji", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLDOJISTAR": { "name": "CDLDOJISTAR", "camelCaseName": "cdlDojiStar", "group": "Pattern Recognition", "description": "Doji Star", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLDRAGONFLYDOJI": { "name": "CDLDRAGONFLYDOJI", "camelCaseName": "cdlDragonflyDoji", "group": "Pattern Recognition", "description": "Dragonfly Doji", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLENGULFING": { "name": "CDLENGULFING", "camelCaseName": "cdlEngulfing", "group": "Pattern Recognition", "description": "Engulfing Pattern", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLEVENINGDOJISTAR": { "name": "CDLEVENINGDOJISTAR", "camelCaseName": "cdlEveningDojiStar", "group": "Pattern Recognition", "description": "Evening Doji Star", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [{ "name": "penetration", "displayName": "Penetration", "defaultValue": 0.3, "hint": "Percentage of penetration of a candle within another candle", "type": "Double", "range": { "min": 0, "max": 3e+37 } }], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLEVENINGSTAR": { "name": "CDLEVENINGSTAR", "camelCaseName": "cdlEveningStar", "group": "Pattern Recognition", "description": "Evening Star", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [{ "name": "penetration", "displayName": "Penetration", "defaultValue": 0.3, "hint": "Percentage of penetration of a candle within another candle", "type": "Double", "range": { "min": 0, "max": 3e+37 } }], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLGAPSIDESIDEWHITE": { "name": "CDLGAPSIDESIDEWHITE", "camelCaseName": "cdlGapSideSideWhite", "group": "Pattern Recognition", "description": "Up/Down-gap side-by-side white lines", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLGRAVESTONEDOJI": { "name": "CDLGRAVESTONEDOJI", "camelCaseName": "cdlGravestoneDoji", "group": "Pattern Recognition", "description": "Gravestone Doji", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLHAMMER": { "name": "CDLHAMMER", "camelCaseName": "cdlHammer", "group": "Pattern Recognition", "description": "Hammer", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLHANGINGMAN": { "name": "CDLHANGINGMAN", "camelCaseName": "cdlHangingMan", "group": "Pattern Recognition", "description": "Hanging Man", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLHARAMI": { "name": "CDLHARAMI", "camelCaseName": "cdlHarami", "group": "Pattern Recognition", "description": "Harami Pattern", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLHARAMICROSS": { "name": "CDLHARAMICROSS", "camelCaseName": "cdlHaramiCross", "group": "Pattern Recognition", "description": "Harami Cross Pattern", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLHIGHWAVE": { "name": "CDLHIGHWAVE", "camelCaseName": "cdlHignWave", "group": "Pattern Recognition", "description": "High-Wave Candle", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLHIKKAKE": { "name": "CDLHIKKAKE", "camelCaseName": "cdlHikkake", "group": "Pattern Recognition", "description": "Hikkake Pattern", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLHIKKAKEMOD": { "name": "CDLHIKKAKEMOD", "camelCaseName": "cdlHikkakeMod", "group": "Pattern Recognition", "description": "Modified Hikkake Pattern", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLHOMINGPIGEON": { "name": "CDLHOMINGPIGEON", "camelCaseName": "cdlHomingPigeon", "group": "Pattern Recognition", "description": "Homing Pigeon", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLIDENTICAL3CROWS": { "name": "CDLIDENTICAL3CROWS", "camelCaseName": "cdlIdentical3Crows", "group": "Pattern Recognition", "description": "Identical Three Crows", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLINNECK": { "name": "CDLINNECK", "camelCaseName": "cdlInNeck", "group": "Pattern Recognition", "description": "In-Neck Pattern", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLINVERTEDHAMMER": { "name": "CDLINVERTEDHAMMER", "camelCaseName": "cdlInvertedHammer", "group": "Pattern Recognition", "description": "Inverted Hammer", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLKICKING": { "name": "CDLKICKING", "camelCaseName": "cdlKicking", "group": "Pattern Recognition", "description": "Kicking", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLKICKINGBYLENGTH": { "name": "CDLKICKINGBYLENGTH", "camelCaseName": "cdlKickingByLength", "group": "Pattern Recognition", "description": "Kicking - bull/bear determined by the longer marubozu", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLLADDERBOTTOM": { "name": "CDLLADDERBOTTOM", "camelCaseName": "cdlLadderBottom", "group": "Pattern Recognition", "description": "Ladder Bottom", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLLONGLEGGEDDOJI": { "name": "CDLLONGLEGGEDDOJI", "camelCaseName": "cdlLongLeggedDoji", "group": "Pattern Recognition", "description": "Long Legged Doji", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLLONGLINE": { "name": "CDLLONGLINE", "camelCaseName": "cdlLongLine", "group": "Pattern Recognition", "description": "Long Line Candle", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLMARUBOZU": { "name": "CDLMARUBOZU", "camelCaseName": "cdlMarubozu", "group": "Pattern Recognition", "description": "Marubozu", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLMATCHINGLOW": { "name": "CDLMATCHINGLOW", "camelCaseName": "cdlMatchingLow", "group": "Pattern Recognition", "description": "Matching Low", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLMATHOLD": { "name": "CDLMATHOLD", "camelCaseName": "cdlMatHold", "group": "Pattern Recognition", "description": "Mat Hold", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [{ "name": "penetration", "displayName": "Penetration", "defaultValue": 0.5, "hint": "Percentage of penetration of a candle within another candle", "type": "Double", "range": { "min": 0, "max": 3e+37 } }], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLMORNINGDOJISTAR": { "name": "CDLMORNINGDOJISTAR", "camelCaseName": "cdlMorningDojiStar", "group": "Pattern Recognition", "description": "Morning Doji Star", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [{ "name": "penetration", "displayName": "Penetration", "defaultValue": 0.3, "hint": "Percentage of penetration of a candle within another candle", "type": "Double", "range": { "min": 0, "max": 3e+37 } }], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLMORNINGSTAR": { "name": "CDLMORNINGSTAR", "camelCaseName": "cdlMorningStar", "group": "Pattern Recognition", "description": "Morning Star", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [{ "name": "penetration", "displayName": "Penetration", "defaultValue": 0.3, "hint": "Percentage of penetration of a candle within another candle", "type": "Double", "range": { "min": 0, "max": 3e+37 } }], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLONNECK": { "name": "CDLONNECK", "camelCaseName": "cdlOnNeck", "group": "Pattern Recognition", "description": "On-Neck Pattern", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLPIERCING": { "name": "CDLPIERCING", "camelCaseName": "cdlPiercing", "group": "Pattern Recognition", "description": "Piercing Pattern", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLRICKSHAWMAN": { "name": "CDLRICKSHAWMAN", "camelCaseName": "cdlRickshawMan", "group": "Pattern Recognition", "description": "Rickshaw Man", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLRISEFALL3METHODS": { "name": "CDLRISEFALL3METHODS", "camelCaseName": "cdlRiseFall3Methods", "group": "Pattern Recognition", "description": "Rising/Falling Three Methods", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLSEPARATINGLINES": { "name": "CDLSEPARATINGLINES", "camelCaseName": "cdlSeperatingLines", "group": "Pattern Recognition", "description": "Separating Lines", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLSHOOTINGSTAR": { "name": "CDLSHOOTINGSTAR", "camelCaseName": "cdlShootingStar", "group": "Pattern Recognition", "description": "Shooting Star", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLSHORTLINE": { "name": "CDLSHORTLINE", "camelCaseName": "cdlShortLine", "group": "Pattern Recognition", "description": "Short Line Candle", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLSPINNINGTOP": { "name": "CDLSPINNINGTOP", "camelCaseName": "cdlSpinningTop", "group": "Pattern Recognition", "description": "Spinning Top", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLSTALLEDPATTERN": { "name": "CDLSTALLEDPATTERN", "camelCaseName": "cdlStalledPattern", "group": "Pattern Recognition", "description": "Stalled Pattern", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLSTICKSANDWICH": { "name": "CDLSTICKSANDWICH", "camelCaseName": "cdlStickSandwhich", "group": "Pattern Recognition", "description": "Stick Sandwich", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLTAKURI": { "name": "CDLTAKURI", "camelCaseName": "cdlTakuri", "group": "Pattern Recognition", "description": "Takuri (Dragonfly Doji with very long lower shadow)", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLTASUKIGAP": { "name": "CDLTASUKIGAP", "camelCaseName": "cdlTasukiGap", "group": "Pattern Recognition", "description": "Tasuki Gap", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLTHRUSTING": { "name": "CDLTHRUSTING", "camelCaseName": "cdlThrusting", "group": "Pattern Recognition", "description": "Thrusting Pattern", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLTRISTAR": { "name": "CDLTRISTAR", "camelCaseName": "cdlTristar", "group": "Pattern Recognition", "description": "Tristar Pattern", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLUNIQUE3RIVER": { "name": "CDLUNIQUE3RIVER", "camelCaseName": "cdlUnique3River", "group": "Pattern Recognition", "description": "Unique 3 River", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLUPSIDEGAP2CROWS": { "name": "CDLUPSIDEGAP2CROWS", "camelCaseName": "cdlUpsideGap2Crows", "group": "Pattern Recognition", "description": "Upside Gap Two Crows", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CDLXSIDEGAP3METHODS": { "name": "CDLXSIDEGAP3METHODS", "camelCaseName": "cdlXSideGap3Methods", "group": "Pattern Recognition", "description": "Upside/Downside Gap Three Methods", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "CEIL": { "name": "CEIL", "camelCaseName": "ceil", "group": "Math Transform", "description": "Vector Ceil", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "CMO": { "name": "CMO", "camelCaseName": "cmo", "group": "Momentum Indicators", "description": "Chande Momentum Oscillator", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "CORREL": { "name": "CORREL", "camelCaseName": "correl", "group": "Statistic Functions", "description": "Pearson's Correlation Coefficient (r)", "inputs": [{ "name": "inReal0", "type": "Double[]" }, { "name": "inReal1", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 30, "hint": "Number of period", "type": "Integer", "range": { "min": 1, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "COS": { "name": "COS", "camelCaseName": "cos", "group": "Math Transform", "description": "Vector Trigonometric Cos", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "COSH": { "name": "COSH", "camelCaseName": "cosh", "group": "Math Transform", "description": "Vector Trigonometric Cosh", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "DEMA": { "name": "DEMA", "camelCaseName": "dema", "group": "Overlap Studies", "description": "Double Exponential Moving Average", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 30, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "DIV": { "name": "DIV", "camelCaseName": "div", "group": "Math Operators", "description": "Vector Arithmetic Div", "inputs": [{ "name": "inReal0", "type": "Double[]" }, { "name": "inReal1", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "DX": { "name": "DX", "camelCaseName": "dx", "group": "Momentum Indicators", "description": "Directional Movement Index", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "EMA": { "name": "EMA", "camelCaseName": "ema", "group": "Overlap Studies", "description": "Exponential Moving Average", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 30, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "EXP": { "name": "EXP", "camelCaseName": "exp", "group": "Math Transform", "description": "Vector Arithmetic Exp", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "FLOOR": { "name": "FLOOR", "camelCaseName": "floor", "group": "Math Transform", "description": "Vector Floor", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "HT_DCPERIOD": { "name": "HT_DCPERIOD", "camelCaseName": "htDcPeriod", "group": "Cycle Indicators", "description": "Hilbert Transform - Dominant Cycle Period", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "HT_DCPHASE": { "name": "HT_DCPHASE", "camelCaseName": "htDcPhase", "group": "Cycle Indicators", "description": "Hilbert Transform - Dominant Cycle Phase", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "HT_PHASOR": { "name": "HT_PHASOR", "camelCaseName": "htPhasor", "group": "Cycle Indicators", "description": "Hilbert Transform - Phasor Components", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [], "outputs": [{ "name": "inPhase", "type": "Double[]", "plotHint": "line" }, { "name": "quadrature", "type": "Double[]", "plotHint": "line_dash" }] }, "HT_SINE": { "name": "HT_SINE", "camelCaseName": "htSine", "group": "Cycle Indicators", "description": "Hilbert Transform - SineWave", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [], "outputs": [{ "name": "sine", "type": "Double[]", "plotHint": "line" }, { "name": "leadSine", "type": "Double[]", "plotHint": "line_dash" }] }, "HT_TRENDLINE": { "name": "HT_TRENDLINE", "camelCaseName": "htTrendline", "group": "Overlap Studies", "description": "Hilbert Transform - Instantaneous Trendline", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "HT_TRENDMODE": { "name": "HT_TRENDMODE", "camelCaseName": "htTrendMode", "group": "Cycle Indicators", "description": "Hilbert Transform - Trend vs Cycle Mode", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "IMI": { "name": "IMI", "camelCaseName": "imi", "group": "Momentum Indicators", "description": "Intraday Momentum Index", "inputs": [{ "name": "open", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "KAMA": { "name": "KAMA", "camelCaseName": "kama", "group": "Overlap Studies", "description": "Kaufman Adaptive Moving Average", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 30, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "LINEARREG": { "name": "LINEARREG", "camelCaseName": "linearReg", "group": "Statistic Functions", "description": "Linear Regression", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "LINEARREG_ANGLE": { "name": "LINEARREG_ANGLE", "camelCaseName": "linearRegAngle", "group": "Statistic Functions", "description": "Linear Regression Angle", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "LINEARREG_INTERCEPT": { "name": "LINEARREG_INTERCEPT", "camelCaseName": "linearRegIntercept", "group": "Statistic Functions", "description": "Linear Regression Intercept", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "LINEARREG_SLOPE": { "name": "LINEARREG_SLOPE", "camelCaseName": "linearRegSlope", "group": "Statistic Functions", "description": "Linear Regression Slope", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "LN": { "name": "LN", "camelCaseName": "ln", "group": "Math Transform", "description": "Vector Log Natural", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "LOG10": { "name": "LOG10", "camelCaseName": "log10", "group": "Math Transform", "description": "Vector Log10", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "MA": { "name": "MA", "camelCaseName": "movingAverage", "group": "Overlap Studies", "description": "Moving average", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 30, "hint": "Number of period", "type": "Integer", "range": { "min": 1, "max": 100000 } }, { "name": "MAType", "displayName": "MA Type", "defaultValue": 0, "hint": "Type of Moving Average", "type": "MAType" }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "MACD": { "name": "MACD", "camelCaseName": "macd", "group": "Momentum Indicators", "description": "Moving Average Convergence/Divergence", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "fastPeriod", "displayName": "Fast Period", "defaultValue": 12, "hint": "Number of period for the fast MA", "type": "Integer", "range": { "min": 2, "max": 100000 } }, { "name": "slowPeriod", "displayName": "Slow Period", "defaultValue": 26, "hint": "Number of period for the slow MA", "type": "Integer", "range": { "min": 2, "max": 100000 } }, { "name": "signalPeriod", "displayName": "Signal Period", "defaultValue": 9, "hint": "Smoothing for the signal line (nb of period)", "type": "Integer", "range": { "min": 1, "max": 100000 } }], "outputs": [{ "name": "MACD", "type": "Double[]", "plotHint": "line" }, { "name": "MACDSignal", "type": "Double[]", "plotHint": "line_dash" }, { "name": "MACDHist", "type": "Double[]", "plotHint": "histogram" }] }, "MACDEXT": { "name": "MACDEXT", "camelCaseName": "macdExt", "group": "Momentum Indicators", "description": "MACD with controllable MA type", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "fastPeriod", "displayName": "Fast Period", "defaultValue": 12, "hint": "Number of period for the fast MA", "type": "Integer", "range": { "min": 2, "max": 100000 } }, { "name": "fastMAType", "displayName": "Fast MA", "defaultValue": 0, "hint": "Type of Moving Average for fast MA", "type": "MAType" }, { "name": "slowPeriod", "displayName": "Slow Period", "defaultValue": 26, "hint": "Number of period for the slow MA", "type": "Integer", "range": { "min": 2, "max": 100000 } }, { "name": "slowMAType", "displayName": "Slow MA", "defaultValue": 0, "hint": "Type of Moving Average for slow MA", "type": "MAType" }, { "name": "signalPeriod", "displayName": "Signal Period", "defaultValue": 9, "hint": "Smoothing for the signal line (nb of period)", "type": "Integer", "range": { "min": 1, "max": 100000 } }, { "name": "signalMAType", "displayName": "Signal MA", "defaultValue": 0, "hint": "Type of Moving Average for signal line", "type": "MAType" }], "outputs": [{ "name": "MACD", "type": "Double[]", "plotHint": "line" }, { "name": "MACDSignal", "type": "Double[]", "plotHint": "line_dash" }, { "name": "MACDHist", "type": "Double[]", "plotHint": "histogram" }] }, "MACDFIX": { "name": "MACDFIX", "camelCaseName": "macdFix", "group": "Momentum Indicators", "description": "Moving Average Convergence/Divergence Fix 12/26", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "signalPeriod", "displayName": "Signal Period", "defaultValue": 9, "hint": "Smoothing for the signal line (nb of period)", "type": "Integer", "range": { "min": 1, "max": 100000 } }], "outputs": [{ "name": "MACD", "type": "Double[]", "plotHint": "line" }, { "name": "MACDSignal", "type": "Double[]", "plotHint": "line_dash" }, { "name": "MACDHist", "type": "Double[]", "plotHint": "histogram" }] }, "MAMA": { "name": "MAMA", "camelCaseName": "mama", "group": "Overlap Studies", "description": "MESA Adaptive Moving Average", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "fastLimit", "displayName": "Fast Limit", "defaultValue": 0.5, "hint": "Upper limit use in the adaptive algorithm", "type": "Double", "range": { "min": 0.01, "max": 0.99 } }, { "name": "slowLimit", "displayName": "Slow Limit", "defaultValue": 0.05, "hint": "Lower limit use in the adaptive algorithm", "type": "Double", "range": { "min": 0.01, "max": 0.99 } }], "outputs": [{ "name": "MAMA", "type": "Double[]", "plotHint": "line" }, { "name": "FAMA", "type": "Double[]", "plotHint": "line_dash" }] }, "MAVP": { "name": "MAVP", "camelCaseName": "movingAverageVariablePeriod", "group": "Overlap Studies", "description": "Moving average with variable period", "inputs": [{ "name": "inReal", "type": "Double[]" }, { "name": "inPeriods", "type": "Double[]" }], "options": [{ "name": "minPeriod", "displayName": "Minimum Period", "defaultValue": 2, "hint": "Value less than minimum will be changed to Minimum period", "type": "Integer", "range": { "min": 2, "max": 100000 } }, { "name": "maxPeriod", "displayName": "Maximum Period", "defaultValue": 30, "hint": "Value higher than maximum will be changed to Maximum period", "type": "Integer", "range": { "min": 2, "max": 100000 } }, { "name": "MAType", "displayName": "MA Type", "defaultValue": 0, "hint": "Type of Moving Average", "type": "MAType" }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "MAX": { "name": "MAX", "camelCaseName": "max", "group": "Math Operators", "description": "Highest value over a specified period", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 30, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "MAXINDEX": { "name": "MAXINDEX", "camelCaseName": "maxIndex", "group": "Math Operators", "description": "Index of highest value over a specified period", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 30, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "MEDPRICE": { "name": "MEDPRICE", "camelCaseName": "medPrice", "group": "Price Transform", "description": "Median Price", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "MFI": { "name": "MFI", "camelCaseName": "mfi", "group": "Momentum Indicators", "description": "Money Flow Index", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }, { "name": "volume", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "MIDPOINT": { "name": "MIDPOINT", "camelCaseName": "midPoint", "group": "Overlap Studies", "description": "MidPoint over period", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "MIDPRICE": { "name": "MIDPRICE", "camelCaseName": "midPrice", "group": "Overlap Studies", "description": "Midpoint Price over period", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "MIN": { "name": "MIN", "camelCaseName": "min", "group": "Math Operators", "description": "Lowest value over a specified period", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 30, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "MININDEX": { "name": "MININDEX", "camelCaseName": "minIndex", "group": "Math Operators", "description": "Index of lowest value over a specified period", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 30, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Integer[]", "plotHint": "line" }] }, "MINMAX": { "name": "MINMAX", "camelCaseName": "minMax", "group": "Math Operators", "description": "Lowest and highest values over a specified period", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 30, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "min", "type": "Double[]", "plotHint": "line" }, { "name": "max", "type": "Double[]", "plotHint": "line" }] }, "MINMAXINDEX": { "name": "MINMAXINDEX", "camelCaseName": "minMaxIndex", "group": "Math Operators", "description": "Indexes of lowest and highest values over a specified period", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 30, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "minIdx", "type": "Integer[]", "plotHint": "line" }, { "name": "maxIdx", "type": "Integer[]", "plotHint": "line" }] }, "MINUS_DI": { "name": "MINUS_DI", "camelCaseName": "minusDI", "group": "Momentum Indicators", "description": "Minus Directional Indicator", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 1, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "MINUS_DM": { "name": "MINUS_DM", "camelCaseName": "minusDM", "group": "Momentum Indicators", "description": "Minus Directional Movement", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 1, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "MOM": { "name": "MOM", "camelCaseName": "mom", "group": "Momentum Indicators", "description": "Momentum", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 10, "hint": "Number of period", "type": "Integer", "range": { "min": 1, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "MULT": { "name": "MULT", "camelCaseName": "mult", "group": "Math Operators", "description": "Vector Arithmetic Mult", "inputs": [{ "name": "inReal0", "type": "Double[]" }, { "name": "inReal1", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "NATR": { "name": "NATR", "camelCaseName": "natr", "group": "Volatility Indicators", "description": "Normalized Average True Range", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 1, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "OBV": { "name": "OBV", "camelCaseName": "obv", "group": "Volume Indicators", "description": "On Balance Volume", "inputs": [{ "name": "inReal", "type": "Double[]" }, { "name": "volume", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "PLUS_DI": { "name": "PLUS_DI", "camelCaseName": "plusDI", "group": "Momentum Indicators", "description": "Plus Directional Indicator", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 1, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "PLUS_DM": { "name": "PLUS_DM", "camelCaseName": "plusDM", "group": "Momentum Indicators", "description": "Plus Directional Movement", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 1, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "PPO": { "name": "PPO", "camelCaseName": "ppo", "group": "Momentum Indicators", "description": "Percentage Price Oscillator", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "fastPeriod", "displayName": "Fast Period", "defaultValue": 12, "hint": "Number of period for the fast MA", "type": "Integer", "range": { "min": 2, "max": 100000 } }, { "name": "slowPeriod", "displayName": "Slow Period", "defaultValue": 26, "hint": "Number of period for the slow MA", "type": "Integer", "range": { "min": 2, "max": 100000 } }, { "name": "MAType", "displayName": "MA Type", "defaultValue": 0, "hint": "Type of Moving Average", "type": "MAType" }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "ROC": { "name": "ROC", "camelCaseName": "roc", "group": "Momentum Indicators", "description": "Rate of change : ((price/prevPrice)-1)*100", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 10, "hint": "Number of period", "type": "Integer", "range": { "min": 1, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "ROCP": { "name": "ROCP", "camelCaseName": "rocP", "group": "Momentum Indicators", "description": "Rate of change Percentage: (price-prevPrice)/prevPrice", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 10, "hint": "Number of period", "type": "Integer", "range": { "min": 1, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "ROCR": { "name": "ROCR", "camelCaseName": "rocR", "group": "Momentum Indicators", "description": "Rate of change ratio: (price/prevPrice)", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 10, "hint": "Number of period", "type": "Integer", "range": { "min": 1, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "ROCR100": { "name": "ROCR100", "camelCaseName": "rocR100", "group": "Momentum Indicators", "description": "Rate of change ratio 100 scale: (price/prevPrice)*100", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 10, "hint": "Number of period", "type": "Integer", "range": { "min": 1, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "RSI": { "name": "RSI", "camelCaseName": "rsi", "group": "Momentum Indicators", "description": "Relative Strength Index", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "SAR": { "name": "SAR", "camelCaseName": "sar", "group": "Overlap Studies", "description": "Parabolic SAR", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }], "options": [{ "name": "acceleration", "displayName": "Acceleration Factor", "defaultValue": 0.02, "hint": "Acceleration Factor used up to the Maximum value", "type": "Double", "range": { "min": 0, "max": 3e+37 } }, { "name": "maximum", "displayName": "AF Maximum", "defaultValue": 0.2, "hint": "Acceleration Factor Maximum value", "type": "Double", "range": { "min": 0, "max": 3e+37 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "SAREXT": { "name": "SAREXT", "camelCaseName": "sarExt", "group": "Overlap Studies", "description": "Parabolic SAR - Extended", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }], "options": [{ "name": "startValue", "displayName": "Start Value", "defaultValue": 0, "hint": "Start value and direction. 0 for Auto, >0 for Long, <0 for Short", "type": "Double", "range": { "min": -3e+37, "max": 3e+37 } }, { "name": "offsetOnReverse", "displayName": "Offset on Reverse", "defaultValue": 0, "hint": "Percent offset added/removed to initial stop on short/long reversal", "type": "Double", "range": { "min": 0, "max": 3e+37 } }, { "name": "accelerationInitLong", "displayName": "AF Init Long", "defaultValue": 0.02, "hint": "Acceleration Factor initial value for the Long direction", "type": "Double", "range": { "min": 0, "max": 3e+37 } }, { "name": "accelerationLong", "displayName": "AF Long", "defaultValue": 0.02, "hint": "Acceleration Factor for the Long direction", "type": "Double", "range": { "min": 0, "max": 3e+37 } }, { "name": "accelerationMaxLong", "displayName": "AF Max Long", "defaultValue": 0.2, "hint": "Acceleration Factor maximum value for the Long direction", "type": "Double", "range": { "min": 0, "max": 3e+37 } }, { "name": "accelerationInitShort", "displayName": "AF Init Short", "defaultValue": 0.02, "hint": "Acceleration Factor initial value for the Short direction", "type": "Double", "range": { "min": 0, "max": 3e+37 } }, { "name": "accelerationShort", "displayName": "AF Short", "defaultValue": 0.02, "hint": "Acceleration Factor for the Short direction", "type": "Double", "range": { "min": 0, "max": 3e+37 } }, { "name": "accelerationMaxShort", "displayName": "AF Max Short", "defaultValue": 0.2, "hint": "Acceleration Factor maximum value for the Short direction", "type": "Double", "range": { "min": 0, "max": 3e+37 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "SIN": { "name": "SIN", "camelCaseName": "sin", "group": "Math Transform", "description": "Vector Trigonometric Sin", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "SINH": { "name": "SINH", "camelCaseName": "sinh", "group": "Math Transform", "description": "Vector Trigonometric Sinh", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "SMA": { "name": "SMA", "camelCaseName": "sma", "group": "Overlap Studies", "description": "Simple Moving Average", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 30, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "SQRT": { "name": "SQRT", "camelCaseName": "sqrt", "group": "Math Transform", "description": "Vector Square Root", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "STDDEV": { "name": "STDDEV", "camelCaseName": "stdDev", "group": "Statistic Functions", "description": "Standard Deviation", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 5, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }, { "name": "nbDev", "displayName": "Deviations", "defaultValue": 1, "hint": "Nb of deviations", "type": "Double", "range": { "min": -3e+37, "max": 3e+37 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "STOCH": { "name": "STOCH", "camelCaseName": "stoch", "group": "Momentum Indicators", "description": "Stochastic", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [{ "name": "fastK_Period", "displayName": "Fast-K Period", "defaultValue": 5, "hint": "Time period for building the Fast-K line", "type": "Integer", "range": { "min": 1, "max": 100000 } }, { "name": "slowK_Period", "displayName": "Slow-K Period", "defaultValue": 3, "hint": "Smoothing for making the Slow-K line. Usually set to 3", "type": "Integer", "range": { "min": 1, "max": 100000 } }, { "name": "slowK_MAType", "displayName": "Slow-K MA", "defaultValue": 0, "hint": "Type of Moving Average for Slow-K", "type": "MAType" }, { "name": "slowD_Period", "displayName": "Slow-D Period", "defaultValue": 3, "hint": "Smoothing for making the Slow-D line", "type": "Integer", "range": { "min": 1, "max": 100000 } }, { "name": "slowD_MAType", "displayName": "Slow-D MA", "defaultValue": 0, "hint": "Type of Moving Average for Slow-D", "type": "MAType" }], "outputs": [{ "name": "slowK", "type": "Double[]", "plotHint": "line_dash" }, { "name": "slowD", "type": "Double[]", "plotHint": "line_dash" }] }, "STOCHF": { "name": "STOCHF", "camelCaseName": "stochF", "group": "Momentum Indicators", "description": "Stochastic Fast", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [{ "name": "fastK_Period", "displayName": "Fast-K Period", "defaultValue": 5, "hint": "Time period for building the Fast-K line", "type": "Integer", "range": { "min": 1, "max": 100000 } }, { "name": "fastD_Period", "displayName": "Fast-D Period", "defaultValue": 3, "hint": "Smoothing for making the Fast-D line. Usually set to 3", "type": "Integer", "range": { "min": 1, "max": 100000 } }, { "name": "fastD_MAType", "displayName": "Fast-D MA", "defaultValue": 0, "hint": "Type of Moving Average for Fast-D", "type": "MAType" }], "outputs": [{ "name": "fastK", "type": "Double[]", "plotHint": "line" }, { "name": "fastD", "type": "Double[]", "plotHint": "line" }] }, "STOCHRSI": { "name": "STOCHRSI", "camelCaseName": "stochRsi", "group": "Momentum Indicators", "description": "Stochastic Relative Strength Index", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }, { "name": "fastK_Period", "displayName": "Fast-K Period", "defaultValue": 5, "hint": "Time period for building the Fast-K line", "type": "Integer", "range": { "min": 1, "max": 100000 } }, { "name": "fastD_Period", "displayName": "Fast-D Period", "defaultValue": 3, "hint": "Smoothing for making the Fast-D line. Usually set to 3", "type": "Integer", "range": { "min": 1, "max": 100000 } }, { "name": "fastD_MAType", "displayName": "Fast-D MA", "defaultValue": 0, "hint": "Type of Moving Average for Fast-D", "type": "MAType" }], "outputs": [{ "name": "fastK", "type": "Double[]", "plotHint": "line" }, { "name": "fastD", "type": "Double[]", "plotHint": "line" }] }, "SUB": { "name": "SUB", "camelCaseName": "sub", "group": "Math Operators", "description": "Vector Arithmetic Substraction", "inputs": [{ "name": "inReal0", "type": "Double[]" }, { "name": "inReal1", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "SUM": { "name": "SUM", "camelCaseName": "sum", "group": "Math Operators", "description": "Summation", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 30, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "T3": { "name": "T3", "camelCaseName": "t3", "group": "Overlap Studies", "description": "Triple Exponential Moving Average (T3)", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 5, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }, { "name": "VFactor", "displayName": "Volume Factor", "defaultValue": 0.7, "hint": "Volume Factor", "type": "Double", "range": { "min": 0, "max": 1 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "TAN": { "name": "TAN", "camelCaseName": "tan", "group": "Math Transform", "description": "Vector Trigonometric Tan", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "TANH": { "name": "TANH", "camelCaseName": "tanh", "group": "Math Transform", "description": "Vector Trigonometric Tanh", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "TEMA": { "name": "TEMA", "camelCaseName": "tema", "group": "Overlap Studies", "description": "Triple Exponential Moving Average", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 30, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "TRANGE": { "name": "TRANGE", "camelCaseName": "trueRange", "group": "Volatility Indicators", "description": "True Range", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "TRIMA": { "name": "TRIMA", "camelCaseName": "trima", "group": "Overlap Studies", "description": "Triangular Moving Average", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 30, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "TRIX": { "name": "TRIX", "camelCaseName": "trix", "group": "Momentum Indicators", "description": "1-day Rate-Of-Change (ROC) of a Triple Smooth EMA", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 30, "hint": "Number of period", "type": "Integer", "range": { "min": 1, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "TSF": { "name": "TSF", "camelCaseName": "tsf", "group": "Statistic Functions", "description": "Time Series Forecast", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "TYPPRICE": { "name": "TYPPRICE", "camelCaseName": "typPrice", "group": "Price Transform", "description": "Typical Price", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "ULTOSC": { "name": "ULTOSC", "camelCaseName": "ultOsc", "group": "Momentum Indicators", "description": "Ultimate Oscillator", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [{ "name": "timePeriod1", "displayName": "First Period", "defaultValue": 7, "hint": "Number of bars for 1st period.", "type": "Integer", "range": { "min": 1, "max": 100000 } }, { "name": "timePeriod2", "displayName": "Second Period", "defaultValue": 14, "hint": "Number of bars fro 2nd period", "type": "Integer", "range": { "min": 1, "max": 100000 } }, { "name": "timePeriod3", "displayName": "Third Period", "defaultValue": 28, "hint": "Number of bars for 3rd period", "type": "Integer", "range": { "min": 1, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "VAR": { "name": "VAR", "camelCaseName": "variance", "group": "Statistic Functions", "description": "Variance", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 5, "hint": "Number of period", "type": "Integer", "range": { "min": 1, "max": 100000 } }, { "name": "nbDev", "displayName": "Deviations", "defaultValue": 1, "hint": "Nb of deviations", "type": "Double", "range": { "min": -3e+37, "max": 3e+37 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "WCLPRICE": { "name": "WCLPRICE", "camelCaseName": "wclPrice", "group": "Price Transform", "description": "Weighted Close Price", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "WILLR": { "name": "WILLR", "camelCaseName": "willR", "group": "Momentum Indicators", "description": "Williams' %R", "inputs": [{ "name": "high", "type": "Double[]" }, { "name": "low", "type": "Double[]" }, { "name": "close", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 14, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] }, "WMA": { "name": "WMA", "camelCaseName": "wma", "group": "Overlap Studies", "description": "Weighted Moving Average", "inputs": [{ "name": "inReal", "type": "Double[]" }], "options": [{ "name": "timePeriod", "displayName": "Time Period", "defaultValue": 30, "hint": "Number of period", "type": "Integer", "range": { "min": 2, "max": 100000 } }], "outputs": [{ "name": "output", "type": "Double[]", "plotHint": "line" }] } };
var __INIT__ = __INIT__;
let TA_WASM;
function cArray(Module, size) {
    const offset = Module._malloc(size * 8);
    Module.HEAPF64.set(new Float64Array(size), offset / 8);
    return {
        data: Module.HEAPF64.subarray(offset / 8, offset / 8 + size),
        offset: offset,
    };
}
const TA_RET_CODE = {
    0: 'TA_SUCCESS',
    1: 'TA_LIB_NOT_INITIALIZE',
    2: 'TA_BAD_PARAM',
    3: 'TA_ALLOC_ERR',
    4: 'TA_GROUP_NOT_FOUND',
    5: 'TA_FUNC_NOT_FOUND',
    6: 'TA_INVALID_HANDLE',
    7: 'TA_INVALID_PARAM_HOLDER',
    8: 'TA_INVALID_PARAM_HOLDER_TYPE',
    9: 'TA_INVALID_PARAM_FUNCTION',
    10: 'TA_INPUT_NOT_ALL_INITIALIZE',
    11: 'TA_OUTPUT_NOT_ALL_INITIALIZE',
    12: 'TA_OUT_OF_RANGE_START_INDEX',
    13: 'TA_OUT_OF_RANGE_END_INDEX',
    14: 'TA_INVALID_LIST_TYPE',
    15: 'TA_BAD_OBJECT',
    16: 'TA_NOT_SUPPORTED',
    5000: 'TA_INTERNAL_ERROR',
    [0xffff]: 'TA_UNKNOWN_ERR',
};
function callFunc(api, params) {
    const funcIdent = `TA_${api.name}`;
    if (!TA_WASM)
        throw Error(`${api.name}() called before initialization.`);
    const ccallArgsLen = 2 +
        api.inputs.length +
        api.options.length +
        2 +
        api.outputs.length;
    const argTypesToCcall = new Array(ccallArgsLen).fill('number');
    for (const { name } of api.inputs) {
        if (!Array.isArray(params[name])) {
            if (params[name] === undefined)
                throw Error(`Bad Param: "${name}" is required`);
            throw Error(`Bad Param: "${name}" should be array of number`);
        }
    }
    for (const { name, defaultValue, range } of api.options) {
        if (params[name] === undefined) {
            params[name] = defaultValue;
        }
        else if (range &&
            (params[name] < range.min || params[name] > range.max)) {
            throw Error(`Bad Param: "${name}" out of range (min: ${range.min}, max: ${range.max})`);
        }
    }
    let { startIdx, endIdx } = params;
    if (startIdx === undefined)
        startIdx = 0;
    const reqParamsLen = api.inputs.map(({ name }) => params[name].length);
    if (endIdx === undefined) {
        endIdx = Math.min(...reqParamsLen);
    }
    const argsToCcall = [startIdx, endIdx];
    const arraysToRelease = [];
    api.inputs.forEach(({ name }) => {
        const argArray = cArray(TA_WASM, endIdx - startIdx);
        const paramArray = params[name];
        for (const i in paramArray)
            argArray.data[i] = paramArray[i];
        arraysToRelease.push(argArray);
        argsToCcall.push(argArray.offset);
    });
    api.options.forEach(({ name }) => argsToCcall.push(params[name]));
    argsToCcall.push(0);
    argsToCcall.push(0);
    const outputs = api.outputs.map(({ name }) => {
        const argArray = cArray(TA_WASM, endIdx - startIdx);
        arraysToRelease.push(argArray);
        argsToCcall.push(argArray.offset);
        return { name, array: argArray };
    });
    const retCode = TA_WASM.ccall(funcIdent, 'number', argTypesToCcall, argsToCcall);
    arraysToRelease.forEach((arr) => TA_WASM._free(arr.offset));
    const result = outputs.reduce((result, current) => {
        result[current.name] = Array.from(current.array.data);
        return result;
    }, {});
    if (retCode === 0) {
        return result;
    }
    else {
        throw Error('[C_ERROR] ' + TA_RET_CODE[retCode]);
    }
}
var MAType;
(function (MAType) {
    MAType[MAType["SMA"] = 0] = "SMA";
    MAType[MAType["EMA"] = 1] = "EMA";
    MAType[MAType["WMA"] = 2] = "WMA";
    MAType[MAType["DEMA"] = 3] = "DEMA";
    MAType[MAType["TEMA"] = 4] = "TEMA";
    MAType[MAType["TRIMA"] = 5] = "TRIMA";
    MAType[MAType["KAMA"] = 6] = "KAMA";
    MAType[MAType["MAMA"] = 7] = "MAMA";
    MAType[MAType["T3"] = 8] = "T3";
})(MAType || (MAType = {}));
function init(wasmBinaryFilePath) {
    if (TA_WASM)
        return Promise.resolve(TA_WASM);
    if (wasmBinaryFilePath && typeof wasmBinaryFilePath !== 'string') {
        return Promise.reject(new Error('Invalid argument, "init(wasmBinaryFilePath)" expects a string that specifies the location of wasm binary file'));
    }
    const locateFile = wasmBinaryFilePath ? () => wasmBinaryFilePath : undefined;
    return __INIT__({ locateFile })
        .then((Module) => (TA_WASM = Module))
        .catch((e) => {
        let message = 'TA-Lib WASM runtime init fail.';
        if (e && e.message) {
            message += '\nError: \n' + e.message;
        }
        else {
            message +=
                'Unknown reason. Perhaps you specify the wrong file path to wasm binary?';
        }
        throw new Error(message);
    });
}
let __ACCBANDS_API__ = API['ACCBANDS'];
function ACCBANDS$1(params) {
    return callFunc(__ACCBANDS_API__, params);
}
const accBands = ACCBANDS$1;
let __ACOS_API__ = API['ACOS'];
function ACOS$1(params) {
    return callFunc(__ACOS_API__, params);
}
const acos = ACOS$1;
let __AD_API__ = API['AD'];
function AD$1(params) {
    return callFunc(__AD_API__, params);
}
const ad = AD$1;
let __ADD_API__ = API['ADD'];
function ADD$1(params) {
    return callFunc(__ADD_API__, params);
}
const add = ADD$1;
let __ADOSC_API__ = API['ADOSC'];
function ADOSC$1(params) {
    return callFunc(__ADOSC_API__, params);
}
const adOsc = ADOSC$1;
let __ADX_API__ = API['ADX'];
function ADX$2(params) {
    return callFunc(__ADX_API__, params);
}
const adx = ADX$2;
let __ADXR_API__ = API['ADXR'];
function ADXR$1(params) {
    return callFunc(__ADXR_API__, params);
}
const adxr = ADXR$1;
let __APO_API__ = API['APO'];
function APO$1(params) {
    return callFunc(__APO_API__, params);
}
const apo = APO$1;
let __AROON_API__ = API['AROON'];
function AROON$2(params) {
    return callFunc(__AROON_API__, params);
}
const aroon = AROON$2;
let __AROONOSC_API__ = API['AROONOSC'];
function AROONOSC$1(params) {
    return callFunc(__AROONOSC_API__, params);
}
const aroonOsc = AROONOSC$1;
let __ASIN_API__ = API['ASIN'];
function ASIN$1(params) {
    return callFunc(__ASIN_API__, params);
}
const asin = ASIN$1;
let __ATAN_API__ = API['ATAN'];
function ATAN$1(params) {
    return callFunc(__ATAN_API__, params);
}
const atan = ATAN$1;
let __ATR_API__ = API['ATR'];
function ATR$2(params) {
    return callFunc(__ATR_API__, params);
}
const atr = ATR$2;
let __AVGDEV_API__ = API['AVGDEV'];
function AVGDEV$1(params) {
    return callFunc(__AVGDEV_API__, params);
}
const avgDev = AVGDEV$1;
let __AVGPRICE_API__ = API['AVGPRICE'];
function AVGPRICE$1(params) {
    return callFunc(__AVGPRICE_API__, params);
}
const avgPrice = AVGPRICE$1;
let __BBANDS_API__ = API['BBANDS'];
function BBANDS$1(params) {
    return callFunc(__BBANDS_API__, params);
}
const bbands = BBANDS$1;
let __BETA_API__ = API['BETA'];
function BETA$1(params) {
    return callFunc(__BETA_API__, params);
}
const beta = BETA$1;
let __BOP_API__ = API['BOP'];
function BOP$1(params) {
    return callFunc(__BOP_API__, params);
}
const bop = BOP$1;
let __CCI_API__ = API['CCI'];
function CCI$2(params) {
    return callFunc(__CCI_API__, params);
}
const cci = CCI$2;
let __CDL2CROWS_API__ = API['CDL2CROWS'];
function CDL2CROWS$1(params) {
    return callFunc(__CDL2CROWS_API__, params);
}
const cdl2Crows = CDL2CROWS$1;
let __CDL3BLACKCROWS_API__ = API['CDL3BLACKCROWS'];
function CDL3BLACKCROWS$1(params) {
    return callFunc(__CDL3BLACKCROWS_API__, params);
}
const cdl3BlackCrows = CDL3BLACKCROWS$1;
let __CDL3INSIDE_API__ = API['CDL3INSIDE'];
function CDL3INSIDE$1(params) {
    return callFunc(__CDL3INSIDE_API__, params);
}
const cdl3Inside = CDL3INSIDE$1;
let __CDL3LINESTRIKE_API__ = API['CDL3LINESTRIKE'];
function CDL3LINESTRIKE$1(params) {
    return callFunc(__CDL3LINESTRIKE_API__, params);
}
const cdl3LineStrike = CDL3LINESTRIKE$1;
let __CDL3OUTSIDE_API__ = API['CDL3OUTSIDE'];
function CDL3OUTSIDE$1(params) {
    return callFunc(__CDL3OUTSIDE_API__, params);
}
const cdl3Outside = CDL3OUTSIDE$1;
let __CDL3STARSINSOUTH_API__ = API['CDL3STARSINSOUTH'];
function CDL3STARSINSOUTH$1(params) {
    return callFunc(__CDL3STARSINSOUTH_API__, params);
}
const cdl3StarsInSouth = CDL3STARSINSOUTH$1;
let __CDL3WHITESOLDIERS_API__ = API['CDL3WHITESOLDIERS'];
function CDL3WHITESOLDIERS$1(params) {
    return callFunc(__CDL3WHITESOLDIERS_API__, params);
}
const cdl3WhiteSoldiers = CDL3WHITESOLDIERS$1;
let __CDLABANDONEDBABY_API__ = API['CDLABANDONEDBABY'];
function CDLABANDONEDBABY$1(params) {
    return callFunc(__CDLABANDONEDBABY_API__, params);
}
const cdlAbandonedBaby = CDLABANDONEDBABY$1;
let __CDLADVANCEBLOCK_API__ = API['CDLADVANCEBLOCK'];
function CDLADVANCEBLOCK$1(params) {
    return callFunc(__CDLADVANCEBLOCK_API__, params);
}
const cdlAdvanceBlock = CDLADVANCEBLOCK$1;
let __CDLBELTHOLD_API__ = API['CDLBELTHOLD'];
function CDLBELTHOLD$1(params) {
    return callFunc(__CDLBELTHOLD_API__, params);
}
const cdlBeltHold = CDLBELTHOLD$1;
let __CDLBREAKAWAY_API__ = API['CDLBREAKAWAY'];
function CDLBREAKAWAY$1(params) {
    return callFunc(__CDLBREAKAWAY_API__, params);
}
const cdlBreakaway = CDLBREAKAWAY$1;
let __CDLCLOSINGMARUBOZU_API__ = API['CDLCLOSINGMARUBOZU'];
function CDLCLOSINGMARUBOZU$1(params) {
    return callFunc(__CDLCLOSINGMARUBOZU_API__, params);
}
const cdlClosingMarubozu = CDLCLOSINGMARUBOZU$1;
let __CDLCONCEALBABYSWALL_API__ = API['CDLCONCEALBABYSWALL'];
function CDLCONCEALBABYSWALL$1(params) {
    return callFunc(__CDLCONCEALBABYSWALL_API__, params);
}
const cdlConcealBabysWall = CDLCONCEALBABYSWALL$1;
let __CDLCOUNTERATTACK_API__ = API['CDLCOUNTERATTACK'];
function CDLCOUNTERATTACK$1(params) {
    return callFunc(__CDLCOUNTERATTACK_API__, params);
}
const cdlCounterAttack = CDLCOUNTERATTACK$1;
let __CDLDARKCLOUDCOVER_API__ = API['CDLDARKCLOUDCOVER'];
function CDLDARKCLOUDCOVER$1(params) {
    return callFunc(__CDLDARKCLOUDCOVER_API__, params);
}
const cdlDarkCloudCover = CDLDARKCLOUDCOVER$1;
let __CDLDOJI_API__ = API['CDLDOJI'];
function CDLDOJI$1(params) {
    return callFunc(__CDLDOJI_API__, params);
}
const cdlDoji = CDLDOJI$1;
let __CDLDOJISTAR_API__ = API['CDLDOJISTAR'];
function CDLDOJISTAR$1(params) {
    return callFunc(__CDLDOJISTAR_API__, params);
}
const cdlDojiStar = CDLDOJISTAR$1;
let __CDLDRAGONFLYDOJI_API__ = API['CDLDRAGONFLYDOJI'];
function CDLDRAGONFLYDOJI$1(params) {
    return callFunc(__CDLDRAGONFLYDOJI_API__, params);
}
const cdlDragonflyDoji = CDLDRAGONFLYDOJI$1;
let __CDLENGULFING_API__ = API['CDLENGULFING'];
function CDLENGULFING$1(params) {
    return callFunc(__CDLENGULFING_API__, params);
}
const cdlEngulfing = CDLENGULFING$1;
let __CDLEVENINGDOJISTAR_API__ = API['CDLEVENINGDOJISTAR'];
function CDLEVENINGDOJISTAR$1(params) {
    return callFunc(__CDLEVENINGDOJISTAR_API__, params);
}
const cdlEveningDojiStar = CDLEVENINGDOJISTAR$1;
let __CDLEVENINGSTAR_API__ = API['CDLEVENINGSTAR'];
function CDLEVENINGSTAR$1(params) {
    return callFunc(__CDLEVENINGSTAR_API__, params);
}
const cdlEveningStar = CDLEVENINGSTAR$1;
let __CDLGAPSIDESIDEWHITE_API__ = API['CDLGAPSIDESIDEWHITE'];
function CDLGAPSIDESIDEWHITE$1(params) {
    return callFunc(__CDLGAPSIDESIDEWHITE_API__, params);
}
const cdlGapSideSideWhite = CDLGAPSIDESIDEWHITE$1;
let __CDLGRAVESTONEDOJI_API__ = API['CDLGRAVESTONEDOJI'];
function CDLGRAVESTONEDOJI$1(params) {
    return callFunc(__CDLGRAVESTONEDOJI_API__, params);
}
const cdlGravestoneDoji = CDLGRAVESTONEDOJI$1;
let __CDLHAMMER_API__ = API['CDLHAMMER'];
function CDLHAMMER$1(params) {
    return callFunc(__CDLHAMMER_API__, params);
}
const cdlHammer = CDLHAMMER$1;
let __CDLHANGINGMAN_API__ = API['CDLHANGINGMAN'];
function CDLHANGINGMAN$1(params) {
    return callFunc(__CDLHANGINGMAN_API__, params);
}
const cdlHangingMan = CDLHANGINGMAN$1;
let __CDLHARAMI_API__ = API['CDLHARAMI'];
function CDLHARAMI$1(params) {
    return callFunc(__CDLHARAMI_API__, params);
}
const cdlHarami = CDLHARAMI$1;
let __CDLHARAMICROSS_API__ = API['CDLHARAMICROSS'];
function CDLHARAMICROSS$1(params) {
    return callFunc(__CDLHARAMICROSS_API__, params);
}
const cdlHaramiCross = CDLHARAMICROSS$1;
let __CDLHIGHWAVE_API__ = API['CDLHIGHWAVE'];
function CDLHIGHWAVE$1(params) {
    return callFunc(__CDLHIGHWAVE_API__, params);
}
const cdlHignWave = CDLHIGHWAVE$1;
let __CDLHIKKAKE_API__ = API['CDLHIKKAKE'];
function CDLHIKKAKE$1(params) {
    return callFunc(__CDLHIKKAKE_API__, params);
}
const cdlHikkake = CDLHIKKAKE$1;
let __CDLHIKKAKEMOD_API__ = API['CDLHIKKAKEMOD'];
function CDLHIKKAKEMOD$1(params) {
    return callFunc(__CDLHIKKAKEMOD_API__, params);
}
const cdlHikkakeMod = CDLHIKKAKEMOD$1;
let __CDLHOMINGPIGEON_API__ = API['CDLHOMINGPIGEON'];
function CDLHOMINGPIGEON$1(params) {
    return callFunc(__CDLHOMINGPIGEON_API__, params);
}
const cdlHomingPigeon = CDLHOMINGPIGEON$1;
let __CDLIDENTICAL3CROWS_API__ = API['CDLIDENTICAL3CROWS'];
function CDLIDENTICAL3CROWS$1(params) {
    return callFunc(__CDLIDENTICAL3CROWS_API__, params);
}
const cdlIdentical3Crows = CDLIDENTICAL3CROWS$1;
let __CDLINNECK_API__ = API['CDLINNECK'];
function CDLINNECK$1(params) {
    return callFunc(__CDLINNECK_API__, params);
}
const cdlInNeck = CDLINNECK$1;
let __CDLINVERTEDHAMMER_API__ = API['CDLINVERTEDHAMMER'];
function CDLINVERTEDHAMMER$1(params) {
    return callFunc(__CDLINVERTEDHAMMER_API__, params);
}
const cdlInvertedHammer = CDLINVERTEDHAMMER$1;
let __CDLKICKING_API__ = API['CDLKICKING'];
function CDLKICKING$1(params) {
    return callFunc(__CDLKICKING_API__, params);
}
const cdlKicking = CDLKICKING$1;
let __CDLKICKINGBYLENGTH_API__ = API['CDLKICKINGBYLENGTH'];
function CDLKICKINGBYLENGTH$1(params) {
    return callFunc(__CDLKICKINGBYLENGTH_API__, params);
}
const cdlKickingByLength = CDLKICKINGBYLENGTH$1;
let __CDLLADDERBOTTOM_API__ = API['CDLLADDERBOTTOM'];
function CDLLADDERBOTTOM$1(params) {
    return callFunc(__CDLLADDERBOTTOM_API__, params);
}
const cdlLadderBottom = CDLLADDERBOTTOM$1;
let __CDLLONGLEGGEDDOJI_API__ = API['CDLLONGLEGGEDDOJI'];
function CDLLONGLEGGEDDOJI$1(params) {
    return callFunc(__CDLLONGLEGGEDDOJI_API__, params);
}
const cdlLongLeggedDoji = CDLLONGLEGGEDDOJI$1;
let __CDLLONGLINE_API__ = API['CDLLONGLINE'];
function CDLLONGLINE$1(params) {
    return callFunc(__CDLLONGLINE_API__, params);
}
const cdlLongLine = CDLLONGLINE$1;
let __CDLMARUBOZU_API__ = API['CDLMARUBOZU'];
function CDLMARUBOZU$1(params) {
    return callFunc(__CDLMARUBOZU_API__, params);
}
const cdlMarubozu = CDLMARUBOZU$1;
let __CDLMATCHINGLOW_API__ = API['CDLMATCHINGLOW'];
function CDLMATCHINGLOW$1(params) {
    return callFunc(__CDLMATCHINGLOW_API__, params);
}
const cdlMatchingLow = CDLMATCHINGLOW$1;
let __CDLMATHOLD_API__ = API['CDLMATHOLD'];
function CDLMATHOLD$1(params) {
    return callFunc(__CDLMATHOLD_API__, params);
}
const cdlMatHold = CDLMATHOLD$1;
let __CDLMORNINGDOJISTAR_API__ = API['CDLMORNINGDOJISTAR'];
function CDLMORNINGDOJISTAR$1(params) {
    return callFunc(__CDLMORNINGDOJISTAR_API__, params);
}
const cdlMorningDojiStar = CDLMORNINGDOJISTAR$1;
let __CDLMORNINGSTAR_API__ = API['CDLMORNINGSTAR'];
function CDLMORNINGSTAR$1(params) {
    return callFunc(__CDLMORNINGSTAR_API__, params);
}
const cdlMorningStar = CDLMORNINGSTAR$1;
let __CDLONNECK_API__ = API['CDLONNECK'];
function CDLONNECK$1(params) {
    return callFunc(__CDLONNECK_API__, params);
}
const cdlOnNeck = CDLONNECK$1;
let __CDLPIERCING_API__ = API['CDLPIERCING'];
function CDLPIERCING$1(params) {
    return callFunc(__CDLPIERCING_API__, params);
}
const cdlPiercing = CDLPIERCING$1;
let __CDLRICKSHAWMAN_API__ = API['CDLRICKSHAWMAN'];
function CDLRICKSHAWMAN$1(params) {
    return callFunc(__CDLRICKSHAWMAN_API__, params);
}
const cdlRickshawMan = CDLRICKSHAWMAN$1;
let __CDLRISEFALL3METHODS_API__ = API['CDLRISEFALL3METHODS'];
function CDLRISEFALL3METHODS$1(params) {
    return callFunc(__CDLRISEFALL3METHODS_API__, params);
}
const cdlRiseFall3Methods = CDLRISEFALL3METHODS$1;
let __CDLSEPARATINGLINES_API__ = API['CDLSEPARATINGLINES'];
function CDLSEPARATINGLINES$1(params) {
    return callFunc(__CDLSEPARATINGLINES_API__, params);
}
const cdlSeperatingLines = CDLSEPARATINGLINES$1;
let __CDLSHOOTINGSTAR_API__ = API['CDLSHOOTINGSTAR'];
function CDLSHOOTINGSTAR$1(params) {
    return callFunc(__CDLSHOOTINGSTAR_API__, params);
}
const cdlShootingStar = CDLSHOOTINGSTAR$1;
let __CDLSHORTLINE_API__ = API['CDLSHORTLINE'];
function CDLSHORTLINE$1(params) {
    return callFunc(__CDLSHORTLINE_API__, params);
}
const cdlShortLine = CDLSHORTLINE$1;
let __CDLSPINNINGTOP_API__ = API['CDLSPINNINGTOP'];
function CDLSPINNINGTOP$1(params) {
    return callFunc(__CDLSPINNINGTOP_API__, params);
}
const cdlSpinningTop = CDLSPINNINGTOP$1;
let __CDLSTALLEDPATTERN_API__ = API['CDLSTALLEDPATTERN'];
function CDLSTALLEDPATTERN$1(params) {
    return callFunc(__CDLSTALLEDPATTERN_API__, params);
}
const cdlStalledPattern = CDLSTALLEDPATTERN$1;
let __CDLSTICKSANDWICH_API__ = API['CDLSTICKSANDWICH'];
function CDLSTICKSANDWICH$1(params) {
    return callFunc(__CDLSTICKSANDWICH_API__, params);
}
const cdlStickSandwhich = CDLSTICKSANDWICH$1;
let __CDLTAKURI_API__ = API['CDLTAKURI'];
function CDLTAKURI$1(params) {
    return callFunc(__CDLTAKURI_API__, params);
}
const cdlTakuri = CDLTAKURI$1;
let __CDLTASUKIGAP_API__ = API['CDLTASUKIGAP'];
function CDLTASUKIGAP$1(params) {
    return callFunc(__CDLTASUKIGAP_API__, params);
}
const cdlTasukiGap = CDLTASUKIGAP$1;
let __CDLTHRUSTING_API__ = API['CDLTHRUSTING'];
function CDLTHRUSTING$1(params) {
    return callFunc(__CDLTHRUSTING_API__, params);
}
const cdlThrusting = CDLTHRUSTING$1;
let __CDLTRISTAR_API__ = API['CDLTRISTAR'];
function CDLTRISTAR$1(params) {
    return callFunc(__CDLTRISTAR_API__, params);
}
const cdlTristar = CDLTRISTAR$1;
let __CDLUNIQUE3RIVER_API__ = API['CDLUNIQUE3RIVER'];
function CDLUNIQUE3RIVER$1(params) {
    return callFunc(__CDLUNIQUE3RIVER_API__, params);
}
const cdlUnique3River = CDLUNIQUE3RIVER$1;
let __CDLUPSIDEGAP2CROWS_API__ = API['CDLUPSIDEGAP2CROWS'];
function CDLUPSIDEGAP2CROWS$1(params) {
    return callFunc(__CDLUPSIDEGAP2CROWS_API__, params);
}
const cdlUpsideGap2Crows = CDLUPSIDEGAP2CROWS$1;
let __CDLXSIDEGAP3METHODS_API__ = API['CDLXSIDEGAP3METHODS'];
function CDLXSIDEGAP3METHODS$1(params) {
    return callFunc(__CDLXSIDEGAP3METHODS_API__, params);
}
const cdlXSideGap3Methods = CDLXSIDEGAP3METHODS$1;
let __CEIL_API__ = API['CEIL'];
function CEIL$1(params) {
    return callFunc(__CEIL_API__, params);
}
const ceil = CEIL$1;
let __CMO_API__ = API['CMO'];
function CMO$2(params) {
    return callFunc(__CMO_API__, params);
}
const cmo = CMO$2;
let __CORREL_API__ = API['CORREL'];
function CORREL$1(params) {
    return callFunc(__CORREL_API__, params);
}
const correl = CORREL$1;
let __COS_API__ = API['COS'];
function COS$1(params) {
    return callFunc(__COS_API__, params);
}
const cos = COS$1;
let __COSH_API__ = API['COSH'];
function COSH$1(params) {
    return callFunc(__COSH_API__, params);
}
const cosh = COSH$1;
let __DEMA_API__ = API['DEMA'];
function DEMA$1(params) {
    return callFunc(__DEMA_API__, params);
}
const dema = DEMA$1;
let __DIV_API__ = API['DIV'];
function DIV$1(params) {
    return callFunc(__DIV_API__, params);
}
const div = DIV$1;
let __DX_API__ = API['DX'];
function DX$2(params) {
    return callFunc(__DX_API__, params);
}
const dx = DX$2;
let __EMA_API__ = API['EMA'];
function EMA$2(params) {
    return callFunc(__EMA_API__, params);
}
const ema = EMA$2;
let __EXP_API__ = API['EXP'];
function EXP$1(params) {
    return callFunc(__EXP_API__, params);
}
const exp = EXP$1;
let __FLOOR_API__ = API['FLOOR'];
function FLOOR$1(params) {
    return callFunc(__FLOOR_API__, params);
}
const floor = FLOOR$1;
let __HT_DCPERIOD_API__ = API['HT_DCPERIOD'];
function HT_DCPERIOD$1(params) {
    return callFunc(__HT_DCPERIOD_API__, params);
}
const htDcPeriod = HT_DCPERIOD$1;
let __HT_DCPHASE_API__ = API['HT_DCPHASE'];
function HT_DCPHASE$1(params) {
    return callFunc(__HT_DCPHASE_API__, params);
}
const htDcPhase = HT_DCPHASE$1;
let __HT_PHASOR_API__ = API['HT_PHASOR'];
function HT_PHASOR$1(params) {
    return callFunc(__HT_PHASOR_API__, params);
}
const htPhasor = HT_PHASOR$1;
let __HT_SINE_API__ = API['HT_SINE'];
function HT_SINE$1(params) {
    return callFunc(__HT_SINE_API__, params);
}
const htSine = HT_SINE$1;
let __HT_TRENDLINE_API__ = API['HT_TRENDLINE'];
function HT_TRENDLINE$1(params) {
    return callFunc(__HT_TRENDLINE_API__, params);
}
const htTrendline = HT_TRENDLINE$1;
let __HT_TRENDMODE_API__ = API['HT_TRENDMODE'];
function HT_TRENDMODE$1(params) {
    return callFunc(__HT_TRENDMODE_API__, params);
}
const htTrendMode = HT_TRENDMODE$1;
let __IMI_API__ = API['IMI'];
function IMI$1(params) {
    return callFunc(__IMI_API__, params);
}
const imi = IMI$1;
let __KAMA_API__ = API['KAMA'];
function KAMA$1(params) {
    return callFunc(__KAMA_API__, params);
}
const kama = KAMA$1;
let __LINEARREG_API__ = API['LINEARREG'];
function LINEARREG$1(params) {
    return callFunc(__LINEARREG_API__, params);
}
const linearReg = LINEARREG$1;
let __LINEARREG_ANGLE_API__ = API['LINEARREG_ANGLE'];
function LINEARREG_ANGLE$1(params) {
    return callFunc(__LINEARREG_ANGLE_API__, params);
}
const linearRegAngle = LINEARREG_ANGLE$1;
let __LINEARREG_INTERCEPT_API__ = API['LINEARREG_INTERCEPT'];
function LINEARREG_INTERCEPT$1(params) {
    return callFunc(__LINEARREG_INTERCEPT_API__, params);
}
const linearRegIntercept = LINEARREG_INTERCEPT$1;
let __LINEARREG_SLOPE_API__ = API['LINEARREG_SLOPE'];
function LINEARREG_SLOPE$1(params) {
    return callFunc(__LINEARREG_SLOPE_API__, params);
}
const linearRegSlope = LINEARREG_SLOPE$1;
let __LN_API__ = API['LN'];
function LN$1(params) {
    return callFunc(__LN_API__, params);
}
const ln = LN$1;
let __LOG10_API__ = API['LOG10'];
function LOG10$1(params) {
    return callFunc(__LOG10_API__, params);
}
const log10$1 = LOG10$1;
let __MA_API__ = API['MA'];
function MA$2(params) {
    return callFunc(__MA_API__, params);
}
const movingAverage = MA$2;
let __MACD_API__ = API['MACD'];
function MACD$2(params) {
    return callFunc(__MACD_API__, params);
}
const macd = MACD$2;
let __MACDEXT_API__ = API['MACDEXT'];
function MACDEXT$1(params) {
    return callFunc(__MACDEXT_API__, params);
}
const macdExt = MACDEXT$1;
let __MACDFIX_API__ = API['MACDFIX'];
function MACDFIX$1(params) {
    return callFunc(__MACDFIX_API__, params);
}
const macdFix = MACDFIX$1;
let __MAMA_API__ = API['MAMA'];
function MAMA$1(params) {
    return callFunc(__MAMA_API__, params);
}
const mama = MAMA$1;
let __MAVP_API__ = API['MAVP'];
function MAVP$1(params) {
    return callFunc(__MAVP_API__, params);
}
const movingAverageVariablePeriod = MAVP$1;
let __MAX_API__ = API['MAX'];
function MAX$1(params) {
    return callFunc(__MAX_API__, params);
}
const max = MAX$1;
let __MAXINDEX_API__ = API['MAXINDEX'];
function MAXINDEX$1(params) {
    return callFunc(__MAXINDEX_API__, params);
}
const maxIndex = MAXINDEX$1;
let __MEDPRICE_API__ = API['MEDPRICE'];
function MEDPRICE$1(params) {
    return callFunc(__MEDPRICE_API__, params);
}
const medPrice = MEDPRICE$1;
let __MFI_API__ = API['MFI'];
function MFI$2(params) {
    return callFunc(__MFI_API__, params);
}
const mfi = MFI$2;
let __MIDPOINT_API__ = API['MIDPOINT'];
function MIDPOINT$1(params) {
    return callFunc(__MIDPOINT_API__, params);
}
const midPoint = MIDPOINT$1;
let __MIDPRICE_API__ = API['MIDPRICE'];
function MIDPRICE$1(params) {
    return callFunc(__MIDPRICE_API__, params);
}
const midPrice = MIDPRICE$1;
let __MIN_API__ = API['MIN'];
function MIN$1(params) {
    return callFunc(__MIN_API__, params);
}
const min = MIN$1;
let __MININDEX_API__ = API['MININDEX'];
function MININDEX$1(params) {
    return callFunc(__MININDEX_API__, params);
}
const minIndex = MININDEX$1;
let __MINMAX_API__ = API['MINMAX'];
function MINMAX$1(params) {
    return callFunc(__MINMAX_API__, params);
}
const minMax = MINMAX$1;
let __MINMAXINDEX_API__ = API['MINMAXINDEX'];
function MINMAXINDEX$1(params) {
    return callFunc(__MINMAXINDEX_API__, params);
}
const minMaxIndex = MINMAXINDEX$1;
let __MINUS_DI_API__ = API['MINUS_DI'];
function MINUS_DI$1(params) {
    return callFunc(__MINUS_DI_API__, params);
}
const minusDI = MINUS_DI$1;
let __MINUS_DM_API__ = API['MINUS_DM'];
function MINUS_DM$1(params) {
    return callFunc(__MINUS_DM_API__, params);
}
const minusDM = MINUS_DM$1;
let __MOM_API__ = API['MOM'];
function MOM$1(params) {
    return callFunc(__MOM_API__, params);
}
const mom = MOM$1;
let __MULT_API__ = API['MULT'];
function MULT$1(params) {
    return callFunc(__MULT_API__, params);
}
const mult = MULT$1;
let __NATR_API__ = API['NATR'];
function NATR$1(params) {
    return callFunc(__NATR_API__, params);
}
const natr = NATR$1;
let __OBV_API__ = API['OBV'];
function OBV$2(params) {
    return callFunc(__OBV_API__, params);
}
const obv = OBV$2;
let __PLUS_DI_API__ = API['PLUS_DI'];
function PLUS_DI$1(params) {
    return callFunc(__PLUS_DI_API__, params);
}
const plusDI = PLUS_DI$1;
let __PLUS_DM_API__ = API['PLUS_DM'];
function PLUS_DM$1(params) {
    return callFunc(__PLUS_DM_API__, params);
}
const plusDM = PLUS_DM$1;
let __PPO_API__ = API['PPO'];
function PPO$2(params) {
    return callFunc(__PPO_API__, params);
}
const ppo = PPO$2;
let __ROC_API__ = API['ROC'];
function ROC$2(params) {
    return callFunc(__ROC_API__, params);
}
const roc = ROC$2;
let __ROCP_API__ = API['ROCP'];
function ROCP$1(params) {
    return callFunc(__ROCP_API__, params);
}
const rocP = ROCP$1;
let __ROCR_API__ = API['ROCR'];
function ROCR$1(params) {
    return callFunc(__ROCR_API__, params);
}
const rocR = ROCR$1;
let __ROCR100_API__ = API['ROCR100'];
function ROCR100$1(params) {
    return callFunc(__ROCR100_API__, params);
}
const rocR100 = ROCR100$1;
let __RSI_API__ = API['RSI'];
function RSI$2(params) {
    return callFunc(__RSI_API__, params);
}
const rsi = RSI$2;
let __SAR_API__ = API['SAR'];
function SAR$1(params) {
    return callFunc(__SAR_API__, params);
}
const sar = SAR$1;
let __SAREXT_API__ = API['SAREXT'];
function SAREXT$1(params) {
    return callFunc(__SAREXT_API__, params);
}
const sarExt = SAREXT$1;
let __SIN_API__ = API['SIN'];
function SIN$1(params) {
    return callFunc(__SIN_API__, params);
}
const sin = SIN$1;
let __SINH_API__ = API['SINH'];
function SINH$1(params) {
    return callFunc(__SINH_API__, params);
}
const sinh = SINH$1;
let __SMA_API__ = API['SMA'];
function SMA$2(params) {
    return callFunc(__SMA_API__, params);
}
const sma = SMA$2;
let __SQRT_API__ = API['SQRT'];
function SQRT$1(params) {
    return callFunc(__SQRT_API__, params);
}
const sqrt = SQRT$1;
let __STDDEV_API__ = API['STDDEV'];
function STDDEV$1(params) {
    return callFunc(__STDDEV_API__, params);
}
const stdDev = STDDEV$1;
let __STOCH_API__ = API['STOCH'];
function STOCH$2(params) {
    return callFunc(__STOCH_API__, params);
}
const stoch = STOCH$2;
let __STOCHF_API__ = API['STOCHF'];
function STOCHF$1(params) {
    return callFunc(__STOCHF_API__, params);
}
const stochF = STOCHF$1;
let __STOCHRSI_API__ = API['STOCHRSI'];
function STOCHRSI$2(params) {
    return callFunc(__STOCHRSI_API__, params);
}
const stochRsi = STOCHRSI$2;
let __SUB_API__ = API['SUB'];
function SUB$1(params) {
    return callFunc(__SUB_API__, params);
}
const sub = SUB$1;
let __SUM_API__ = API['SUM'];
function SUM$1(params) {
    return callFunc(__SUM_API__, params);
}
const sum = SUM$1;
let __T3_API__ = API['T3'];
function T3$1(params) {
    return callFunc(__T3_API__, params);
}
const t3 = T3$1;
let __TAN_API__ = API['TAN'];
function TAN$1(params) {
    return callFunc(__TAN_API__, params);
}
const tan = TAN$1;
let __TANH_API__ = API['TANH'];
function TANH$1(params) {
    return callFunc(__TANH_API__, params);
}
const tanh = TANH$1;
let __TEMA_API__ = API['TEMA'];
function TEMA$1(params) {
    return callFunc(__TEMA_API__, params);
}
const tema = TEMA$1;
let __TRANGE_API__ = API['TRANGE'];
function TRANGE$1(params) {
    return callFunc(__TRANGE_API__, params);
}
const trueRange = TRANGE$1;
let __TRIMA_API__ = API['TRIMA'];
function TRIMA$1(params) {
    return callFunc(__TRIMA_API__, params);
}
const trima = TRIMA$1;
let __TRIX_API__ = API['TRIX'];
function TRIX$1(params) {
    return callFunc(__TRIX_API__, params);
}
const trix = TRIX$1;
let __TSF_API__ = API['TSF'];
function TSF$1(params) {
    return callFunc(__TSF_API__, params);
}
const tsf = TSF$1;
let __TYPPRICE_API__ = API['TYPPRICE'];
function TYPPRICE$1(params) {
    return callFunc(__TYPPRICE_API__, params);
}
const typPrice = TYPPRICE$1;
let __ULTOSC_API__ = API['ULTOSC'];
function ULTOSC$1(params) {
    return callFunc(__ULTOSC_API__, params);
}
const ultOsc = ULTOSC$1;
let __VAR_API__ = API['VAR'];
function VAR$1(params) {
    return callFunc(__VAR_API__, params);
}
const variance = VAR$1;
let __WCLPRICE_API__ = API['WCLPRICE'];
function WCLPRICE$1(params) {
    return callFunc(__WCLPRICE_API__, params);
}
const wclPrice = WCLPRICE$1;
let __WILLR_API__ = API['WILLR'];
function WILLR$1(params) {
    return callFunc(__WILLR_API__, params);
}
const willR = WILLR$1;
let __WMA_API__ = API['WMA'];
function WMA$1(params) {
    return callFunc(__WMA_API__, params);
}
const wma = WMA$1;
const TAFuncs = { "ACCBANDS": ACCBANDS$1, "ACOS": ACOS$1, "AD": AD$1, "ADD": ADD$1, "ADOSC": ADOSC$1, "ADX": ADX$2, "ADXR": ADXR$1, "APO": APO$1, "AROON": AROON$2, "AROONOSC": AROONOSC$1, "ASIN": ASIN$1, "ATAN": ATAN$1, "ATR": ATR$2, "AVGDEV": AVGDEV$1, "AVGPRICE": AVGPRICE$1, "BBANDS": BBANDS$1, "BETA": BETA$1, "BOP": BOP$1, "CCI": CCI$2, "CDL2CROWS": CDL2CROWS$1, "CDL3BLACKCROWS": CDL3BLACKCROWS$1, "CDL3INSIDE": CDL3INSIDE$1, "CDL3LINESTRIKE": CDL3LINESTRIKE$1, "CDL3OUTSIDE": CDL3OUTSIDE$1, "CDL3STARSINSOUTH": CDL3STARSINSOUTH$1, "CDL3WHITESOLDIERS": CDL3WHITESOLDIERS$1, "CDLABANDONEDBABY": CDLABANDONEDBABY$1, "CDLADVANCEBLOCK": CDLADVANCEBLOCK$1, "CDLBELTHOLD": CDLBELTHOLD$1, "CDLBREAKAWAY": CDLBREAKAWAY$1, "CDLCLOSINGMARUBOZU": CDLCLOSINGMARUBOZU$1, "CDLCONCEALBABYSWALL": CDLCONCEALBABYSWALL$1, "CDLCOUNTERATTACK": CDLCOUNTERATTACK$1, "CDLDARKCLOUDCOVER": CDLDARKCLOUDCOVER$1, "CDLDOJI": CDLDOJI$1, "CDLDOJISTAR": CDLDOJISTAR$1, "CDLDRAGONFLYDOJI": CDLDRAGONFLYDOJI$1, "CDLENGULFING": CDLENGULFING$1, "CDLEVENINGDOJISTAR": CDLEVENINGDOJISTAR$1, "CDLEVENINGSTAR": CDLEVENINGSTAR$1, "CDLGAPSIDESIDEWHITE": CDLGAPSIDESIDEWHITE$1, "CDLGRAVESTONEDOJI": CDLGRAVESTONEDOJI$1, "CDLHAMMER": CDLHAMMER$1, "CDLHANGINGMAN": CDLHANGINGMAN$1, "CDLHARAMI": CDLHARAMI$1, "CDLHARAMICROSS": CDLHARAMICROSS$1, "CDLHIGHWAVE": CDLHIGHWAVE$1, "CDLHIKKAKE": CDLHIKKAKE$1, "CDLHIKKAKEMOD": CDLHIKKAKEMOD$1, "CDLHOMINGPIGEON": CDLHOMINGPIGEON$1, "CDLIDENTICAL3CROWS": CDLIDENTICAL3CROWS$1, "CDLINNECK": CDLINNECK$1, "CDLINVERTEDHAMMER": CDLINVERTEDHAMMER$1, "CDLKICKING": CDLKICKING$1, "CDLKICKINGBYLENGTH": CDLKICKINGBYLENGTH$1, "CDLLADDERBOTTOM": CDLLADDERBOTTOM$1, "CDLLONGLEGGEDDOJI": CDLLONGLEGGEDDOJI$1, "CDLLONGLINE": CDLLONGLINE$1, "CDLMARUBOZU": CDLMARUBOZU$1, "CDLMATCHINGLOW": CDLMATCHINGLOW$1, "CDLMATHOLD": CDLMATHOLD$1, "CDLMORNINGDOJISTAR": CDLMORNINGDOJISTAR$1, "CDLMORNINGSTAR": CDLMORNINGSTAR$1, "CDLONNECK": CDLONNECK$1, "CDLPIERCING": CDLPIERCING$1, "CDLRICKSHAWMAN": CDLRICKSHAWMAN$1, "CDLRISEFALL3METHODS": CDLRISEFALL3METHODS$1, "CDLSEPARATINGLINES": CDLSEPARATINGLINES$1, "CDLSHOOTINGSTAR": CDLSHOOTINGSTAR$1, "CDLSHORTLINE": CDLSHORTLINE$1, "CDLSPINNINGTOP": CDLSPINNINGTOP$1, "CDLSTALLEDPATTERN": CDLSTALLEDPATTERN$1, "CDLSTICKSANDWICH": CDLSTICKSANDWICH$1, "CDLTAKURI": CDLTAKURI$1, "CDLTASUKIGAP": CDLTASUKIGAP$1, "CDLTHRUSTING": CDLTHRUSTING$1, "CDLTRISTAR": CDLTRISTAR$1, "CDLUNIQUE3RIVER": CDLUNIQUE3RIVER$1, "CDLUPSIDEGAP2CROWS": CDLUPSIDEGAP2CROWS$1, "CDLXSIDEGAP3METHODS": CDLXSIDEGAP3METHODS$1, "CEIL": CEIL$1, "CMO": CMO$2, "CORREL": CORREL$1, "COS": COS$1, "COSH": COSH$1, "DEMA": DEMA$1, "DIV": DIV$1, "DX": DX$2, "EMA": EMA$2, "EXP": EXP$1, "FLOOR": FLOOR$1, "HT_DCPERIOD": HT_DCPERIOD$1, "HT_DCPHASE": HT_DCPHASE$1, "HT_PHASOR": HT_PHASOR$1, "HT_SINE": HT_SINE$1, "HT_TRENDLINE": HT_TRENDLINE$1, "HT_TRENDMODE": HT_TRENDMODE$1, "IMI": IMI$1, "KAMA": KAMA$1, "LINEARREG": LINEARREG$1, "LINEARREG_ANGLE": LINEARREG_ANGLE$1, "LINEARREG_INTERCEPT": LINEARREG_INTERCEPT$1, "LINEARREG_SLOPE": LINEARREG_SLOPE$1, "LN": LN$1, "LOG10": LOG10$1, "MA": MA$2, "MACD": MACD$2, "MACDEXT": MACDEXT$1, "MACDFIX": MACDFIX$1, "MAMA": MAMA$1, "MAVP": MAVP$1, "MAX": MAX$1, "MAXINDEX": MAXINDEX$1, "MEDPRICE": MEDPRICE$1, "MFI": MFI$2, "MIDPOINT": MIDPOINT$1, "MIDPRICE": MIDPRICE$1, "MIN": MIN$1, "MININDEX": MININDEX$1, "MINMAX": MINMAX$1, "MINMAXINDEX": MINMAXINDEX$1, "MINUS_DI": MINUS_DI$1, "MINUS_DM": MINUS_DM$1, "MOM": MOM$1, "MULT": MULT$1, "NATR": NATR$1, "OBV": OBV$2, "PLUS_DI": PLUS_DI$1, "PLUS_DM": PLUS_DM$1, "PPO": PPO$2, "ROC": ROC$2, "ROCP": ROCP$1, "ROCR": ROCR$1, "ROCR100": ROCR100$1, "RSI": RSI$2, "SAR": SAR$1, "SAREXT": SAREXT$1, "SIN": SIN$1, "SINH": SINH$1, "SMA": SMA$2, "SQRT": SQRT$1, "STDDEV": STDDEV$1, "STOCH": STOCH$2, "STOCHF": STOCHF$1, "STOCHRSI": STOCHRSI$2, "SUB": SUB$1, "SUM": SUM$1, "T3": T3$1, "TAN": TAN$1, "TANH": TANH$1, "TEMA": TEMA$1, "TRANGE": TRANGE$1, "TRIMA": TRIMA$1, "TRIX": TRIX$1, "TSF": TSF$1, "TYPPRICE": TYPPRICE$1, "ULTOSC": ULTOSC$1, "VAR": VAR$1, "WCLPRICE": WCLPRICE$1, "WILLR": WILLR$1, "WMA": WMA$1 };

var talib = /*#__PURE__*/Object.freeze({
    __proto__: null,
    ACCBANDS: ACCBANDS$1,
    ACOS: ACOS$1,
    AD: AD$1,
    ADD: ADD$1,
    ADOSC: ADOSC$1,
    ADX: ADX$2,
    ADXR: ADXR$1,
    APO: APO$1,
    AROON: AROON$2,
    AROONOSC: AROONOSC$1,
    ASIN: ASIN$1,
    ATAN: ATAN$1,
    ATR: ATR$2,
    AVGDEV: AVGDEV$1,
    AVGPRICE: AVGPRICE$1,
    BBANDS: BBANDS$1,
    BETA: BETA$1,
    BOP: BOP$1,
    CCI: CCI$2,
    CDL2CROWS: CDL2CROWS$1,
    CDL3BLACKCROWS: CDL3BLACKCROWS$1,
    CDL3INSIDE: CDL3INSIDE$1,
    CDL3LINESTRIKE: CDL3LINESTRIKE$1,
    CDL3OUTSIDE: CDL3OUTSIDE$1,
    CDL3STARSINSOUTH: CDL3STARSINSOUTH$1,
    CDL3WHITESOLDIERS: CDL3WHITESOLDIERS$1,
    CDLABANDONEDBABY: CDLABANDONEDBABY$1,
    CDLADVANCEBLOCK: CDLADVANCEBLOCK$1,
    CDLBELTHOLD: CDLBELTHOLD$1,
    CDLBREAKAWAY: CDLBREAKAWAY$1,
    CDLCLOSINGMARUBOZU: CDLCLOSINGMARUBOZU$1,
    CDLCONCEALBABYSWALL: CDLCONCEALBABYSWALL$1,
    CDLCOUNTERATTACK: CDLCOUNTERATTACK$1,
    CDLDARKCLOUDCOVER: CDLDARKCLOUDCOVER$1,
    CDLDOJI: CDLDOJI$1,
    CDLDOJISTAR: CDLDOJISTAR$1,
    CDLDRAGONFLYDOJI: CDLDRAGONFLYDOJI$1,
    CDLENGULFING: CDLENGULFING$1,
    CDLEVENINGDOJISTAR: CDLEVENINGDOJISTAR$1,
    CDLEVENINGSTAR: CDLEVENINGSTAR$1,
    CDLGAPSIDESIDEWHITE: CDLGAPSIDESIDEWHITE$1,
    CDLGRAVESTONEDOJI: CDLGRAVESTONEDOJI$1,
    CDLHAMMER: CDLHAMMER$1,
    CDLHANGINGMAN: CDLHANGINGMAN$1,
    CDLHARAMI: CDLHARAMI$1,
    CDLHARAMICROSS: CDLHARAMICROSS$1,
    CDLHIGHWAVE: CDLHIGHWAVE$1,
    CDLHIKKAKE: CDLHIKKAKE$1,
    CDLHIKKAKEMOD: CDLHIKKAKEMOD$1,
    CDLHOMINGPIGEON: CDLHOMINGPIGEON$1,
    CDLIDENTICAL3CROWS: CDLIDENTICAL3CROWS$1,
    CDLINNECK: CDLINNECK$1,
    CDLINVERTEDHAMMER: CDLINVERTEDHAMMER$1,
    CDLKICKING: CDLKICKING$1,
    CDLKICKINGBYLENGTH: CDLKICKINGBYLENGTH$1,
    CDLLADDERBOTTOM: CDLLADDERBOTTOM$1,
    CDLLONGLEGGEDDOJI: CDLLONGLEGGEDDOJI$1,
    CDLLONGLINE: CDLLONGLINE$1,
    CDLMARUBOZU: CDLMARUBOZU$1,
    CDLMATCHINGLOW: CDLMATCHINGLOW$1,
    CDLMATHOLD: CDLMATHOLD$1,
    CDLMORNINGDOJISTAR: CDLMORNINGDOJISTAR$1,
    CDLMORNINGSTAR: CDLMORNINGSTAR$1,
    CDLONNECK: CDLONNECK$1,
    CDLPIERCING: CDLPIERCING$1,
    CDLRICKSHAWMAN: CDLRICKSHAWMAN$1,
    CDLRISEFALL3METHODS: CDLRISEFALL3METHODS$1,
    CDLSEPARATINGLINES: CDLSEPARATINGLINES$1,
    CDLSHOOTINGSTAR: CDLSHOOTINGSTAR$1,
    CDLSHORTLINE: CDLSHORTLINE$1,
    CDLSPINNINGTOP: CDLSPINNINGTOP$1,
    CDLSTALLEDPATTERN: CDLSTALLEDPATTERN$1,
    CDLSTICKSANDWICH: CDLSTICKSANDWICH$1,
    CDLTAKURI: CDLTAKURI$1,
    CDLTASUKIGAP: CDLTASUKIGAP$1,
    CDLTHRUSTING: CDLTHRUSTING$1,
    CDLTRISTAR: CDLTRISTAR$1,
    CDLUNIQUE3RIVER: CDLUNIQUE3RIVER$1,
    CDLUPSIDEGAP2CROWS: CDLUPSIDEGAP2CROWS$1,
    CDLXSIDEGAP3METHODS: CDLXSIDEGAP3METHODS$1,
    CEIL: CEIL$1,
    CMO: CMO$2,
    CORREL: CORREL$1,
    COS: COS$1,
    COSH: COSH$1,
    DEMA: DEMA$1,
    DIV: DIV$1,
    DX: DX$2,
    EMA: EMA$2,
    EXP: EXP$1,
    FLOOR: FLOOR$1,
    HT_DCPERIOD: HT_DCPERIOD$1,
    HT_DCPHASE: HT_DCPHASE$1,
    HT_PHASOR: HT_PHASOR$1,
    HT_SINE: HT_SINE$1,
    HT_TRENDLINE: HT_TRENDLINE$1,
    HT_TRENDMODE: HT_TRENDMODE$1,
    IMI: IMI$1,
    KAMA: KAMA$1,
    LINEARREG: LINEARREG$1,
    LINEARREG_ANGLE: LINEARREG_ANGLE$1,
    LINEARREG_INTERCEPT: LINEARREG_INTERCEPT$1,
    LINEARREG_SLOPE: LINEARREG_SLOPE$1,
    LN: LN$1,
    LOG10: LOG10$1,
    MA: MA$2,
    MACD: MACD$2,
    MACDEXT: MACDEXT$1,
    MACDFIX: MACDFIX$1,
    MAMA: MAMA$1,
    get MAType () { return MAType; },
    MAVP: MAVP$1,
    MAX: MAX$1,
    MAXINDEX: MAXINDEX$1,
    MEDPRICE: MEDPRICE$1,
    MFI: MFI$2,
    MIDPOINT: MIDPOINT$1,
    MIDPRICE: MIDPRICE$1,
    MIN: MIN$1,
    MININDEX: MININDEX$1,
    MINMAX: MINMAX$1,
    MINMAXINDEX: MINMAXINDEX$1,
    MINUS_DI: MINUS_DI$1,
    MINUS_DM: MINUS_DM$1,
    MOM: MOM$1,
    MULT: MULT$1,
    NATR: NATR$1,
    OBV: OBV$2,
    PLUS_DI: PLUS_DI$1,
    PLUS_DM: PLUS_DM$1,
    PPO: PPO$2,
    ROC: ROC$2,
    ROCP: ROCP$1,
    ROCR: ROCR$1,
    ROCR100: ROCR100$1,
    RSI: RSI$2,
    SAR: SAR$1,
    SAREXT: SAREXT$1,
    SIN: SIN$1,
    SINH: SINH$1,
    SMA: SMA$2,
    SQRT: SQRT$1,
    STDDEV: STDDEV$1,
    STOCH: STOCH$2,
    STOCHF: STOCHF$1,
    STOCHRSI: STOCHRSI$2,
    SUB: SUB$1,
    SUM: SUM$1,
    T3: T3$1,
    TAFuncs: TAFuncs,
    TAN: TAN$1,
    TANH: TANH$1,
    TEMA: TEMA$1,
    TRANGE: TRANGE$1,
    TRIMA: TRIMA$1,
    TRIX: TRIX$1,
    TSF: TSF$1,
    TYPPRICE: TYPPRICE$1,
    ULTOSC: ULTOSC$1,
    VAR: VAR$1,
    WCLPRICE: WCLPRICE$1,
    WILLR: WILLR$1,
    WMA: WMA$1,
    accBands: accBands,
    acos: acos,
    ad: ad,
    adOsc: adOsc,
    add: add,
    adx: adx,
    adxr: adxr,
    apo: apo,
    aroon: aroon,
    aroonOsc: aroonOsc,
    asin: asin,
    atan: atan,
    atr: atr,
    avgDev: avgDev,
    avgPrice: avgPrice,
    bbands: bbands,
    beta: beta,
    bop: bop,
    cci: cci,
    cdl2Crows: cdl2Crows,
    cdl3BlackCrows: cdl3BlackCrows,
    cdl3Inside: cdl3Inside,
    cdl3LineStrike: cdl3LineStrike,
    cdl3Outside: cdl3Outside,
    cdl3StarsInSouth: cdl3StarsInSouth,
    cdl3WhiteSoldiers: cdl3WhiteSoldiers,
    cdlAbandonedBaby: cdlAbandonedBaby,
    cdlAdvanceBlock: cdlAdvanceBlock,
    cdlBeltHold: cdlBeltHold,
    cdlBreakaway: cdlBreakaway,
    cdlClosingMarubozu: cdlClosingMarubozu,
    cdlConcealBabysWall: cdlConcealBabysWall,
    cdlCounterAttack: cdlCounterAttack,
    cdlDarkCloudCover: cdlDarkCloudCover,
    cdlDoji: cdlDoji,
    cdlDojiStar: cdlDojiStar,
    cdlDragonflyDoji: cdlDragonflyDoji,
    cdlEngulfing: cdlEngulfing,
    cdlEveningDojiStar: cdlEveningDojiStar,
    cdlEveningStar: cdlEveningStar,
    cdlGapSideSideWhite: cdlGapSideSideWhite,
    cdlGravestoneDoji: cdlGravestoneDoji,
    cdlHammer: cdlHammer,
    cdlHangingMan: cdlHangingMan,
    cdlHarami: cdlHarami,
    cdlHaramiCross: cdlHaramiCross,
    cdlHignWave: cdlHignWave,
    cdlHikkake: cdlHikkake,
    cdlHikkakeMod: cdlHikkakeMod,
    cdlHomingPigeon: cdlHomingPigeon,
    cdlIdentical3Crows: cdlIdentical3Crows,
    cdlInNeck: cdlInNeck,
    cdlInvertedHammer: cdlInvertedHammer,
    cdlKicking: cdlKicking,
    cdlKickingByLength: cdlKickingByLength,
    cdlLadderBottom: cdlLadderBottom,
    cdlLongLeggedDoji: cdlLongLeggedDoji,
    cdlLongLine: cdlLongLine,
    cdlMarubozu: cdlMarubozu,
    cdlMatHold: cdlMatHold,
    cdlMatchingLow: cdlMatchingLow,
    cdlMorningDojiStar: cdlMorningDojiStar,
    cdlMorningStar: cdlMorningStar,
    cdlOnNeck: cdlOnNeck,
    cdlPiercing: cdlPiercing,
    cdlRickshawMan: cdlRickshawMan,
    cdlRiseFall3Methods: cdlRiseFall3Methods,
    cdlSeperatingLines: cdlSeperatingLines,
    cdlShootingStar: cdlShootingStar,
    cdlShortLine: cdlShortLine,
    cdlSpinningTop: cdlSpinningTop,
    cdlStalledPattern: cdlStalledPattern,
    cdlStickSandwhich: cdlStickSandwhich,
    cdlTakuri: cdlTakuri,
    cdlTasukiGap: cdlTasukiGap,
    cdlThrusting: cdlThrusting,
    cdlTristar: cdlTristar,
    cdlUnique3River: cdlUnique3River,
    cdlUpsideGap2Crows: cdlUpsideGap2Crows,
    cdlXSideGap3Methods: cdlXSideGap3Methods,
    ceil: ceil,
    cmo: cmo,
    correl: correl,
    cos: cos,
    cosh: cosh,
    dema: dema,
    div: div,
    dx: dx,
    ema: ema,
    exp: exp,
    floor: floor,
    htDcPeriod: htDcPeriod,
    htDcPhase: htDcPhase,
    htPhasor: htPhasor,
    htSine: htSine,
    htTrendMode: htTrendMode,
    htTrendline: htTrendline,
    imi: imi,
    init: init,
    kama: kama,
    linearReg: linearReg,
    linearRegAngle: linearRegAngle,
    linearRegIntercept: linearRegIntercept,
    linearRegSlope: linearRegSlope,
    ln: ln,
    log10: log10$1,
    macd: macd,
    macdExt: macdExt,
    macdFix: macdFix,
    mama: mama,
    max: max,
    maxIndex: maxIndex,
    medPrice: medPrice,
    mfi: mfi,
    midPoint: midPoint,
    midPrice: midPrice,
    min: min,
    minIndex: minIndex,
    minMax: minMax,
    minMaxIndex: minMaxIndex,
    minusDI: minusDI,
    minusDM: minusDM,
    mom: mom,
    movingAverage: movingAverage,
    movingAverageVariablePeriod: movingAverageVariablePeriod,
    mult: mult,
    natr: natr,
    obv: obv,
    plusDI: plusDI,
    plusDM: plusDM,
    ppo: ppo,
    roc: roc,
    rocP: rocP,
    rocR: rocR,
    rocR100: rocR100,
    rsi: rsi,
    sar: sar,
    sarExt: sarExt,
    sin: sin,
    sinh: sinh,
    sma: sma,
    sqrt: sqrt,
    stdDev: stdDev,
    stoch: stoch,
    stochF: stochF,
    stochRsi: stochRsi,
    sub: sub,
    sum: sum,
    t3: t3,
    tan: tan,
    tanh: tanh,
    tema: tema,
    trima: trima,
    trix: trix,
    trueRange: trueRange,
    tsf: tsf,
    typPrice: typPrice,
    ultOsc: ultOsc,
    variance: variance,
    wclPrice: wclPrice,
    willR: willR,
    wma: wma
});

const dataURI = "data:application/wasm;base64,AGFzbQEAAAAAEAhkeWxpbmsuMAEFnB4EAAABkAIcYAl/f39/f39/f38Bf2AHf39/f39/fwF/YAZ/f39/f38Bf2AIf39/f39/f38Bf2AAAX9gAX8Bf2ABfAF8YAt/f39/f39/f39/fwF/YAp/f39/f398f39/AX9gCH9/f398f39/AX9gAX8AYAN8fH8BfGABfAF/YA5/f39/f39/f39/f39/fwF/YAp/f39/f39/f39/AX9gAABgAn9/AX9gAnx/AXxgAnx8AXxgA39/fwF/YAJ8fwF/YAN/f38AYAx/f39/f39/f39/f38Bf2AJf39/fHx/f39/AX9gAn9/AGAMf39/f3x8f39/f39/AX9gD39/f398fHx8fHx8fH9/fwF/YAl/f39/fHx/f38BfwJyBQNlbnYWZW1zY3JpcHRlbl9yZXNpemVfaGVhcAAFA2Vudg9fX3N0YWNrX3BvaW50ZXIDfwEDZW52DV9fbWVtb3J5X2Jhc2UDfwAHR09ULm1lbQtfX2hlYXBfYmFzZQN/AQNlbnYGbWVtb3J5AgGAAoACA9EBzwEKBQYJAwUGEAURCxIGBgMBBQUEEwYEDAQUBgEDAAQEBAQMBAQEFQQLBgEBAQEJFgkBBQEXBwEBAQcCAgMBAgAAAAAAAAAAAAAAAAAAAAAAAAAICAgAAAAAAAAAAAAAAAAABwAAAAAAAAAIAQgAAAAACAAAAAAAAAAIAAIAAAAAAAAAGAUKBAAHAwADCRkHAwEBAgIAAQEHDQIBAgIaGwEBAQAAAwABAAEBAAMCAwEBAwEOAQEBDgIADQcCAgEDAQEBAwICAQEAAgICAgABDw8GEwN/AUHwFgt/AUGUHgt/AUGYHgsH1hOoARFfX3dhc21fY2FsbF9jdG9ycwDPAQtUQV9BQ0NCQU5EUwCIAQZtYWxsb2MAAgRmcmVlAAEGVEFfU01BABAHVEFfQUNPUwB7BVRBX0FEAHMGVEFfQUREAGsIVEFfQURPU0MAYgZUQV9BRFgAHQdUQV9BRFhSAE8GVEFfQVBPAEQFVEFfTUEABQhUQV9BUk9PTgDHAQtUQV9BUk9PTk9TQwC+AQdUQV9BU0lOALcBB1RBX0FUQU4ArAEGVEFfQVRSAKIBCVRBX1RSQU5HRQAPCVRBX0FWR0RFVgCaAQtUQV9BVkdQUklDRQCUAQlUQV9CQkFORFMAjQEJVEFfU1REREVWADAHVEFfQkVUQQCJAQZUQV9CT1AAhwEGVEFfQ0NJAIIBDFRBX0NETDJDUk9XUwCBARFUQV9DREwzQkxBQ0tDUk9XUwCAAQ1UQV9DREwzSU5TSURFAH8RVEFfQ0RMM0xJTkVTVFJJS0UAfg5UQV9DREwzT1VUU0lERQB9E1RBX0NETDNTVEFSU0lOU09VVEgAfBRUQV9DREwzV0hJVEVTT0xESUVSUwB6E1RBX0NETEFCQU5ET05FREJBQlkAeRJUQV9DRExBRFZBTkNFQkxPQ0sAeA5UQV9DRExCRUxUSE9MRAB3D1RBX0NETEJSRUFLQVdBWQB2FVRBX0NETENMT1NJTkdNQVJVQk9aVQB1FlRBX0NETENPTkNFQUxCQUJZU1dBTEwAdBNUQV9DRExDT1VOVEVSQVRUQUNLAHIUVEFfQ0RMREFSS0NMT1VEQ09WRVIAcQpUQV9DRExET0pJAHAOVEFfQ0RMRE9KSVNUQVIAbxNUQV9DRExEUkFHT05GTFlET0pJAG4PVEFfQ0RMRU5HVUxGSU5HAG0VVEFfQ0RMRVZFTklOR0RPSklTVEFSAGwRVEFfQ0RMRVZFTklOR1NUQVIAahZUQV9DRExHQVBTSURFU0lERVdISVRFAGkUVEFfQ0RMR1JBVkVTVE9ORURPSkkAaAxUQV9DRExIQU1NRVIAZxBUQV9DRExIQU5HSU5HTUFOAGYMVEFfQ0RMSEFSQU1JAGURVEFfQ0RMSEFSQU1JQ1JPU1MAZA5UQV9DRExISUdIV0FWRQBjDVRBX0NETEhJS0tBS0UAYRBUQV9DRExISUtLQUtFTU9EAGASVEFfQ0RMSE9NSU5HUElHRU9OAF8VVEFfQ0RMSURFTlRJQ0FMM0NST1dTAF4MVEFfQ0RMSU5ORUNLAF0UVEFfQ0RMSU5WRVJURURIQU1NRVIAXBVUQV9DRExLSUNLSU5HQllMRU5HVEgAWw1UQV9DRExLSUNLSU5HAFoSVEFfQ0RMTEFEREVSQk9UVE9NAFkUVEFfQ0RMTE9OR0xFR0dFRERPSkkAWA5UQV9DRExMT05HTElORQBXDlRBX0NETE1BUlVCT1pVAFYRVEFfQ0RMTUFUQ0hJTkdMT1cAVQ1UQV9DRExNQVRIT0xEAFQVVEFfQ0RMTU9STklOR0RPSklTVEFSAFMRVEFfQ0RMTU9STklOR1NUQVIAUgxUQV9DRExPTk5FQ0sAUQ5UQV9DRExQSUVSQ0lORwBQEVRBX0NETFJJQ0tTSEFXTUFOAE4WVEFfQ0RMUklTRUZBTEwzTUVUSE9EUwBNFVRBX0NETFNFUEFSQVRJTkdMSU5FUwBMElRBX0NETFNIT09USU5HU1RBUgBLD1RBX0NETFNIT1JUTElORQBKEVRBX0NETFNQSU5OSU5HVE9QAEkUVEFfQ0RMU1RBTExFRFBBVFRFUk4ASBNUQV9DRExTVElDS1NBTkRXSUNIAEcMVEFfQ0RMVEFLVVJJAEYPVEFfQ0RMVEFTVUtJR0FQAEUPVEFfQ0RMVEhSVVNUSU5HAEMNVEFfQ0RMVFJJU1RBUgBCElRBX0NETFVOSVFVRTNSSVZFUgBBFVRBX0NETFVQU0lERUdBUDJDUk9XUwBAFlRBX0NETFhTSURFR0FQM01FVEhPRFMAPwdUQV9DRUlMAD4GVEFfQ01PAD0JVEFfQ09SUkVMADwGVEFfQ09TADsHVEFfQ09TSAA6B1RBX0RFTUEAOAZUQV9ESVYAzQEFVEFfRFgAzAEGVEFfRU1BADcGVEFfRVhQAMsBCFRBX0ZMT09SAMoBDlRBX0hUX0RDUEVSSU9EAMkBDVRBX0hUX0RDUEhBU0UAyAEMVEFfSFRfUEhBU09SAMYBClRBX0hUX1NJTkUAxQEPVEFfSFRfVFJFTkRMSU5FAMQBD1RBX0hUX1RSRU5ETU9ERQDDAQZUQV9JTUkAwgEHVEFfS0FNQQA2ElRBX0xJTkVBUlJFR19BTkdMRQDBAQxUQV9MSU5FQVJSRUcAwAEWVEFfTElORUFSUkVHX0lOVEVSQ0VQVAC/ARJUQV9MSU5FQVJSRUdfU0xPUEUAvQEFVEFfTE4AvAEIVEFfTE9HMTAAuwEGVEFfV01BACoHVEFfVEVNQQAtCFRBX1RSSU1BACwHVEFfTUFNQQA0BVRBX1QzAC4HVEFfTUFDRAC6AQpUQV9NQUNERVhUALkBClRBX01BQ0RGSVgAuAEHVEFfTUFWUAC2AQZUQV9NQVgAtQELVEFfTUFYSU5ERVgAtAELVEFfTUVEUFJJQ0UAswEGVEFfTUZJALIBC1RBX01JRFBPSU5UALEBC1RBX01JRFBSSUNFALABBlRBX01JTgCvAQtUQV9NSU5JTkRFWACu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DQELIA4PCyAEIwMoAgAoAoABakEBayEOIAQLIQ8CQCABIA4gACAAIA5IGyIASARAQQAhACAFQQA2AgAMAQsgBSAANgIAIA9BAU0EQCADIABBAWsiBEEDdCIAaisDACEIIAAgAmorAwAhCUEAIQADQCABIARMDQIgByAAQQN0aiAIIAMgBEEBaiIEQQN0IgVqKwMAIgihIgpEAAAAAAAAAAAgAiAFaisDACILIAmhIApjG0QAAAAAAAAAACAKRAAAAAAAAAAAZBs5AwAgAEEBaiEAIAshCQwACwALIAMgACAOayIEQQN0IgBqKwMAIQkgACACaisDACELIA8hAANAIABBAkhFBEAgCCAJIAMgBEEBaiIEQQN0IgVqKwMAIgmhIgygIAggAiAFaisDACIKIAuhIAxjGyAIIAxEAAAAAAAAAABkGyEIIABBAWshACAKIQsMAQsLIA+3IQwgBCEOIwMoAgAoAoABIgUhAANAIAAEQCAIIAggDKOhIgggCSADIA5BAWoiDkEDdCIPaisDACIJoSINoCAIIAIgD2orAwAiCiALoSANYxsgCCANRAAAAAAAAAAAZBshCCAAQQFrIQAgCiELDAELCyAHIAg5AwAgASAEIAVqIgQgASAEShshAUEBIQADQCABIARGDQEgByAAQQN0aiAIIAggDKOhIgggCSADIARBAWoiBEEDdCIFaisDACIJoSINoCAIIAIgBWorAwAiCiALoSANYxsgCCANRAAAAAAAAAAAZBsiCDkDACAAQQFqIQAgCiELDAALAAsgBiAANgIAQQALywsCDnwDfyAAQQBIBEBBDA8LQQ0hGAJAIAFBAEggACABSnINAEECIRggBEUgAkUgA0Vycg0AQQ4hFyAFQYCAgIB4RwRAIAUiF0ECa0GejQZLDQELIAhFDQACQCABIwMoAgAiGSgCPCAXQQF0akEBayIFIAAgACAFSBsiAEgEQEEAIRcgBkEANgIADAELIAYgADYCACADIAAgBWsiAEEDdCIFaisDACEKIAIgBWorAwAhCSAXQQFrIgYhGANAIAQgAEEDdGorAwAhECAYQQBMBEAgF7chEQNAIBdBAEoEQCAMIAwgEaOhIQwgDiAOIBGjoSEOIAIgAEEBaiIAQQN0IgVqKwMAIg8gCaEhCQJAIAogAyAFaisDACILoSIKRAAAAAAAAAAAZEUg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IBUgDRsgBCAJaisDAKGgIRULIABBAWohACAgIBWgISAMAQsLBUQAAAAAAAAAACEVAkACQAJAAkAgCygCzAIOAwABAgMLIAUgAEEDdCIJaisDACACIAlqKwMAoZkhFQwCCyADIABBA3QiCWorAwAgBCAJaisDAKEhFQwBCyADIABBA3QiCWorAwAgBSAJaisDACIVIAIgCWorAwAiFiAVIBZmIg0boSAWIBUgDRsgBCAJaisDAKGgIRULIABBAWohACAfIBWgIR8MAQsLBUQAAAAAAAAAACEVAkACQAJAAkAgCygC7AEOAwABAgMLIAUgAEEDdCIJaisDACACIAlqKwMAoZkhFQwCCyADIABBA3QiCWorAwAgBCAJaisDAKEhFQwBCyADIABBA3QiCWorAwAgBSAJaisDACIVIAIgCWorAwAiFiAVIBZmIg0boSAWIBUgDRsgBCAJaisDAKGgIRULIABBAWohACAeIBWgIR4MAQsLCwv1BwIHfAl/IABBAEgEQEEMDwsCf0ENIAFBAEggACABSnINABpBAiAIRSACRSADRXIgBEUgBUVycnINABogASMDKAIAKAKYA0ECaiIQIAAgACAQSBsiE0gEQCAGQQA2AgAgB0EANgIAQQAPCyATIwMoAgAiFSgCmANrIhQhAAN/IAAgE04Ef0QAAAAAAAAAQEQAAAAAAADwPyAVKAKUAyISQQJGGyEOIAEgE2tBAWohFkEAIQAgEyEQA0AgCCAAQQJ0agJ/AkAgBSAQQQJrQQN0IgFqKwMAIgogASACaisDACILZiIXDQAgBSAQQQFrQQN0IhFqKwMAIAIgEWorAwBmRQ0AIAUgEEEDdCIYaisDACIMIAIgGGorAwBmDQAgBCARaisDACAKZEUNACAVKwOgAyEPAkAgFSgCmAMiEQRAIA0gEbejIQkMAQtEAAAAAAAAAAAhCQJAAkACQCASDgMAAQIDCyAKIAuhmSEJDAILIAEgA2orAwAgASAEaisDAKEhCQwBCyABIANqKwMAIAuhIAogASAEaisDAKGgIQkLIAwgCiAPIAmiIA6joGVFDQBB5AAgDCAKIA8CfCANIBG3oyARDQAaAkACQAJAIBIOAgABAgsgCiALoZkMAgsgASADaisDACABIARqKwMAoQwBC0QAAAAAAAAAACASQQJHDQAaIAEgA2orAwAgC6Eg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QQALNgIARAAAAAAAAAAAIRpEAAAAAAAAAAAhHEQAAAAAAAAAACEgAkACQAJAAkAgCw4DAAECAwsgBSARQQN0QRBrIgFqKwMAIAEgAmorAwChmSEgIAUgAEEDdEEQayIBaisDACABIAJqKwMAoZkhHAwCCyADIBFBA3RBEGsiAWorAwAgASAEaisDAKEhICADIABBA3RBEGsiAWorAwAgASAEaisDAKEhHAwBCyADIBFBA3RBEGsiAWorAwAgASAFaisDACIZIAEgAmorAwAiGCAYIBllIgkboSAYIBkgCRsgASAEaisDAKGgISAgAyAAQQN0QRBrIgFqKwMAIAEgBWorAwAiGSABIAJqKwMAIhggGCAZZSIJG6EgGCAZIAkbIAEgBGorAwChoCEcC0QAAAAAAAAAACEhAkACQAJAAkAgEw4DAAECAwsgBSAOQQN0QRBrIgFqKwMAIAEgAmorAwChmSEhIAUgAEEDdEEQayIBaisDACABIAJqKwMAoZkhGgwCCyADIA5BA3RBEGsiAWorAwAgASAEaisDAKEhISADIABBA3RBEGsiAWorAwAgASAEaisDAKEhGgwBCyADIA5BA3RBEGsiAWorAwAgASAFaisDACIZIAEgAmorAwAiGCAYIBllIgkboSAYIBkgCRsgASAEaisDAKGgISEgAyAAQQN0QRBrIgFqKwMAIAEgBWorAwAiGSABIAJqKwMAIhggGCAZZSIJG6EgGCAZIAkbIAEgBGorAwChoCEaC0QAAAAAAAAAACEfRAAAAAAAAAAAIRhEAAAAAAAAAAAhIwJAAkACQAJAIAsOAwIBAAMLIAMgEUEDdEEIayIBaisDACABIAVqKwMAIhkgASACaisDACIYIBggGWUiCRuhIBggGSAJGyABIARqKwMAoaAhIyADIABBA3RBCGsiAWorAwAgASAFaisDACIZIAEgAmorAwAiGCAYIBllIgkboSAYIBkgCRsgASAEaisDAKGgIRgMAgsgAyARQQN0QQhrIgFqKwMAIAEgBGorAwChISMgAyAAQQN0QQhrIgFqKwMAIAEgBGorAwChIRgMAQsgBSARQQN0QQhrIgFqKwMAIAEgAmorAwChmSEjIAUgAEEDdEEIayIBaisDACABIAJqKwMAoZkhGAtEAAAAAAAAAAAhGQJAAkACQAJAIBMOAwIBAAMLIAMgDkEDdEEIayIBaisDACABIAVqKwMAIhkgASACaisDACIbIBkgG2YiCRuhIBsgGSAJGyABIARqKwMAoaAhGSADIABBA3RBCGsiAWorAwAgASAFaisDACIbIAEgAmorAwAiHyAbIB9mIgkboSAfIBsgCRsgASAEaisDAKGgIR8MAgsgAyAOQQN0QQhrIgFqKwMAIAEgBGorAwChIRkgAyAAQQN0QQhrIgFqKwMAIAEgBGorAwChIR8MAQsgBSAOQQN0QQhrIgFqKwMAIAEgAmorAwChmSEZIAUgAEEDdEEIayIBaisDACABIAJqKwMAoZkhHwtEAAAAAAAAAAAhJEQAAAAAAAAAACEiRAAAAAAAAAAAIRsCQAJAAkACQCAVDgMCAQADCyADIBJBA3QiAWorAwAgASAFaisDACIbIAEgAmorAwAiIiAbICJmIgkboSAiIBsgCRsgASAEaisDAKGgIRsgAyAAQQN0IgFqKwMAIAEgBWorAwAiIiABIAJqKwMAIiUgIiAlZiIJG6EgJSAiIAkbIAEgBGorAwChoCEiDAILIAMgEkEDdCIBaisDACABIARqKwMAoSEbIAMgAEEDdCIBaisDACABIARqKwMAoSEiDAELIAUgEkEDdCIBaisDACABIAJqKwMAoZkhGyAFIABBA3QiAWorAwAgASACaisDAKGZISILIBwgIKEhHCAaICGhISAgGCAjoSEhIB8gGaEhHyAUQQFqIRQgIiAboSEbRAAAAAAAAAAAIRoCQAJAAkACQCAWDgMAAQIDCyAFIApBA3RBCGsiAWorAwAgASACaisDAKGZIRogBSAAQQN0QQhrIgFqKwMAIAEgAmorAwChmSEkDAILIAMgCkEDdEEIayIBaisDACABIARqKwMAoSEaIAMgAEEDdEEIayIBaisDACABIARqKwMAoSEkDAELIAMgCkEDdEEIayIBaisDACABIAVqKwMAIhkgASACaisDACIYIBggGWUiCRuhIBggGSAJGyABIARqKwMAoaAhGiADIABBA3RBCGsiAWorAwAgASAFaisDACIZIAEgAmorAwAiGCAYIBllIgkboSAYIBkgCRsgASAEaisDAKGgISQLICYgHKAhJiAeICCgIR4gJyAhoCEnICkgH6AhKSAoIBugISggDkEBaiEOIApBAWohCiASQQFqIRIgEUEBaiERIABBAWohACAdICQgGqGgIR0gFCAXRw0ACyAHIBc2AgAgBiANNgIAQQAFRAAAAAAAAAAAIRpEAAAAAAAAAAAhHAJAAkACQAJAIAwoAuQCDgMAAQIDCyAFIABBA3QiCUEIayILaisDACACIAtqKwMAoZkhHCAFIAlBEGsiCWorAwAgAiAJaisDAKGZIRoMAgsgAyAAQQN0IglBCGsiC2orAwAgBCALaisDAKEhHCADIAlBEGsiCWorAwAgBCAJaisDAKEhGgwBCyADIABBA3QiC0EIayIJaisDACAFIAlqKwMAIhkgAiAJaisDACIYIBggGWUiDxuhIBggGSAPGyAEIAlqKwMAoaAhHCADIAtBEGsiCWorAwAgBSAJaisDACIZIAIgCWorAwAiGCAYIBllIgsboSAYIBkgCxsgBCAJaisDAKGgIRoLIABBAWohACAcICmgISkgHiAaoCEeDAELCwVEAAAAAAAAAAAhHgJAAkACQAJAIAwoAswCDgMAAQIDCyAFIABBA3RBCGsiCWorAwAgAiAJaisDAKGZIR4MAgsgAyAAQQN0QQhrIglqKwMAIAQgCWorAwChIR4MAQsgAyAAQQN0QQhrIglqKwMAIAUgCWorAwAiGSACIAlqKwMAIhggGCAZZSILG6EgGCAZIAsbIAQgCWorAwChoCEeCyAAQQFqIQAgHSAeoCEdDAELCwVEAAAAAAAAAAAhHQJAAkACQAJAIAwoAtQBDgMAAQIDCyAFIABBA3QiCWorAwAgAiAJaisDAKGZIR0MAgsgAyAAQQN0IglqKwMAIAQgCWorAwChIR0MAQsgAyAAQQN0IglqKwMAIAUgCWorAwAiGSACIAlqKwMAIhggGCAZZSILG6EgGCAZIAsbIAQgCWorAwChoCEdCyAAQQFqIQAgKCAdoCEoDAELCwVEAAAAAAAAAAAhHUQAAAAAAAAAACEeAkACQAJAAkAgDCgCpAEOAwABAgMLIAUgAEEDdCIKQQhrIgtqKwMAIAIgC2orAwChmSEeIAUgCkEQayIKaisDACACIApqKwMAoZkhHQwCCyADIABBA3QiCkEIayILaisDACAEIAtqKwMAoSEeIAMgCkEQayIKaisDACAEIApqKwMAoSEdDAELIAMgAEEDdCILQQhrIgpqKwMAIAUgCmorAwAiGSACIApqKwMAIhggGCAZZSIPG6EgGCAZIA8bIAQgCmorAwChoCEeIAMgC0EQayIKaisDACAFIApqKwMAIhkgAiAKaisDACIYIBggGWUiCxuhIBggGSALGyAEIApqKwMAoaAhHQsgAEEBaiEAIB4gJ6AhJyAmIB2gISYMAQsLCwv2BgIIfwh8IABBAEgEQEEMDwsCf0ENIAFBAEggACABSnINABpBAiAIRSACRSADRXIgBEUgBUVycnINABogASMDKAIAKALYASIJIAAgACAJSBsiD0gEQCAGQQA2AgAgB0EANgIAQQAPCyAPIwMoAgAiDigC2AEiC2siDSEAA38gACAPTgR/RAAAAAAAAABARAAAAAAAAPA/IA4oAtQBIhBBAkYbIRcgACABIAAgAUobIABrQQFqIQwgDisD4AEhGEEAIQEDQCAFIABBA3QiCmorAwAiEyACIApqKwMAIhShmSESAkAgCwRAIBYgC7ejIREMAQsgEiERAkACQAJAIBAOAwMAAQILIAMgCmorAwAgBCAKaisDAKEhEQwCCyADIApqKwMAIBMgFCATIBRmIgkboSAUIBMgCRsgBCAKaisDAKGgIREMAQtEAAAAAAAAAAAhEQtBACELAkAgEiAYIBGiIBejY0UNACADIApqKwMAIBMgFCATIBRmIgkboSASZEUNACAUIBMgCRsgBCAKaisDAKEgEmRFDQBB5ABBnH8gCRshCwsgCCABQQJ0aiALNgIAIAFBAWohAUQAAAAAAAAAACERRAAAAAAAAAAAIRUCQAJAAkACQCAQDgMCAAEDCyADIA1BA3QiCWorAwAgBCAJaisDAKEhFSADIApqKwMAIAQgCmorAwChIREMAgsgAyAKaisDACATIBQgEyAUZiIJG6EgFCATIAkbIAQgCmorAwChoCERIAMgDUEDdCILaisDACAFIAtqKwMAIhUgAiALaisDACISIBIgFWUiCRuhIBIgFSAJGyAEIAtqKwMAoaAhFQwBCyAFIA1BA3QiCWorAwAgAiAJaisDAKGZIRUgEiERCyABIAxHBEAgAEEBaiEAIA1BAWohDSAWIBEgFaGgIRYgDigC2AEhCwwBCwsgByAMNgIAIAYgDzYCAEEABUQAAAAAAAAAACERAkACQAJAAkAgDigC1AEOAwABAgMLIAUgAEEDdCIJaisDACACIAlqKwMAoZkhEQwCCyADIABBA3QiCWorAwAg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A3QiCkEQayIBaisDACABIAVqKwMAIhkgASACaisDACIYIBggGWUiCRuhIBggGSAJGyABIARqKwMAoaAgAyAQQQN0IglBEGsiAWorAwAgASAFaisDACIZIAEgAmorAwAiGCAYIBllIg4boSAYIBkgDhsgASAEaisDAKGgoSEYIAMgCkEYayIBaisDACABIAVqKwMAIhkgASACaisDACIaIBkgGmYiDhuhIBogGSAOGyABIARqKwMAoaAgAyAJQRhrIgFqKwMAIAEgBWorAwAiGSABIAJqKwMAIhogGSAaZiIOG6EgGiAZIA4bIAEgBGorAwChoKEhGSADIAlBCGsiAWorAwAgASAFaisDACIaIAEgAmorAwAiHCAaIBxmIgkboSAcIBogCRsgASAEaisDAKGgIRwgAyAKQQhrIgFqKwMAIAEgBWorAwAiGiABIAJqKwMAIhsgGiAbZiIKG6EgGyAaIAobIAEgBGorAwChoCEaCyATQQFqIRNEAAAAAAAAAAAhG0QAAAAAAAAAACEdAkACQAJAAkAgEQ4DAAECAwsgBSAMQQN0IgFqKwMAIAEgAmorAwChmSEdIAUgAEEDdCIBaisDACABIAJqKwMAoZkhGwwCCyADIAxBA3QiAWorAwAgASAEaisDAKEhHSADIABBA3QiAWorAwAgASAEaisDAKEhGwwBCyADIAxBA3QiAWorAwAgASAFaisDACIbIAEgAmorAwAiHSAbIB1mIgoboSAdIBsgChsgASAEaisDAKGgIR0gAyAAQQN0IgFqKwMAIAEgBWorAwAiGyABIAJqKwMAIh4gGyAeZiIKG6EgHiAbIAobIAEgBGorAwChoCEbCyATIBRHBEAgICAXIBahoCEgICYgGKAhJiAlIBmgISUgJyAaIByhoCEnIABBAWohACAQQQFqIRAgDEEBaiEMIB8gGyAdoaAhHyAPKAKoASEKDAELCyAHIBQ2AgAgBiANNgIAQQAFRAAAAAAAAAAAIRhEAAAAAAAAAAAhFwJAAkACQAJAIA8oAqQBDgMAAQIDCyAFIABBA3QiC2orAwAgAiALaisDAKGZIRcgBSALQSBrIgtqKwMAIAIgC2orAwChmSEYDAILIAMgAEEDdCILaisDACAEIAtqKwMAoSEXIAMgC0EgayILaisDACAEIAtqKwMAoSEYDAELIAMgAEEDdCIL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IBhmIgoboSAYIBYgChsgBCAJaisDAKGgIRQgAyAPQQN0IgpqKwMAIAUgCmorAwAiGiACIApqKwMAIhsgGiAbZiIQG6EgGyAaIBAbIAQgCmorAwChoCEaDAELIAUgD0EDdCIKaisDACACIApqKwMAoZkhGiAVIRQLIAFBAWohAUQAAAAAAAAAACEbAkACQAJAAkAgDQ4DAgABAwsgAyAMQQN0IgpqKwMAIAQgCmorAwChIRsgAyAJaisDACAEIAlqKwMAoSEXDAILIAMgCWorAwAgFiAYIBYgGGYiChuhIBggFiAKGyAEIAlqKwMAoaAhFyADIAxBA3QiCWorAwAgBSAJaisDACIVIAIgCWorAwAiFiAVIBZmIgoboSAWIBUgChsgBCAJaisDAKGgIRsMAQsgBSAMQQN0IglqKwMAIAIgCWorAwChmSEbIBUhFwsgASATRwRAIBwgFCAaoaAhHCAAQQFqIQAgD0EBaiEPIAxBAWohDCAZIBcgG6GgIRkgCygCqAEhCgwBCwsgByATNgIAIAYgDjYCAEEABUQAAAAAAAAAACEVAkACQAJAAkAgCygCtAIOAwABAgMLIAUgAEEDdCIJaisDACACIAlqKwMAoZkhFQwCCyADIABBA3QiCWorAwAgBCAJaisDAKEhFQwBCyADIABBA3QiCWorAwAgBSAJaisDACIVIAIgCWorAwAiFCAUIBVlIg0boSAUIBUgDRsgBCAJaisDAKGgIRULIABBAWohACAZIBWgIRkMAQsLBUQAAAAAAAAAACEZAkACQAJAAkAgCygCpAEOAwABAgMLIAUgAEEDdCIJaisDACACIAlqKwMAoZkhGQwCCyADIABBA3QiCWorAwAgBCAJaisDAKEhGQwBCyADIABBA3QiCWorAwAgBSAJaisDACIVIAIgCWorAwAiFCAUIBVlIg0boSAUIBUgDRsgBCAJaisDAKGgIRkLIABBAWohACAcIBmgIRwMAQsLCwubDAILfw58IABBAEgEQEEMDwsCf0ENIAFBAEggACABSnINABpBAiAIRSACRSADRXIgBEUgBUVycnINABogASMDKAIAIgkoAvABIgsgCSgCiAIiCSAJIAtIGyIJIAAgACAJSBsiDkgEQCAGQQA2AgAgB0EANgIAQQAPCyMDKAIAIgsoAogCIQwgDiALKALwASIKayIPIQAD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AwAgGKGgC6IgHqOhZkUNACAhIBYgHAJ8IBkgCrejIAoNABoCQAJAAkAgCw4CAAECCyAWIBehmQwCCyADIAlqKwMAICWhDAELRAAAAAAAAAAAIAtBAkcNABogHSADIAlqKwMAIBehoAuiIB6joGVFDQBBnH8gISAWIBwCfCAZIAq3oyAKDQAaAkACQAJAIAsOAgABAgsgFiAXoZkMAgsgAyAJaisDACAloQwBC0QAAAAAAAAAACALQQJHDQAaIB0gAyAJaisDACAXoaALoiAeo6FmDQEaC0EACzYCAEQAAAAAAAAAACEURAAAAAAAAAAAIRdEAAAAAAAAAAAhFkQAAAAAAAAAACEVRAAAAAAAAAAAIRgCQAJAAkACQCARDgMAAQIDCyAFIABBA3QiAUEIayIJaisDACACIAlqKwMAoZkgBSAQQQN0IglBCGsiCmorAwAgAiAKaisDAKGZoSEXIAUgAUEQayIKaisDACACIApqKwMAoZkgBSAJQRBrIgpqKwMAIAIgCmorAwChmaEhFiAFIAlqKwMAIAIgCWorAwChmSEYIAEgBWorAwAgASACaisDAKGZIRUMAgsgAyAAQQN0IgFBCGsiCWorAwAgBCAJaisDAKEgAyAQQQN0IglBCGsiCmorAwAgBCAKaisDAKGhIRcgAyABQRBrIgpqKwMAIAQgCmorAwChIAMgCUEQayIKaisDACAEIApqKwMAoaEhFiADIAlqKwMAIAQgCWorAwChIRggASADaisDACABIARqKwMAoSEVDAELIAMgAEEDdCIBQQhrIglqKwMAIAUgCWorAwAiFiACIAlqKwMAIhcgFiAXZiIKG6EgFyAWIAobIAQgCWorAwChoCADIBBBA3QiCUEIayIKaisDACAFIApqKwMAIhYgAiAKaisDACIXIBYgF2YiDRuhIBcgFiANGyAEIApqKwMAoaChIRcgAyABQRBrIgpqKwMAIAUgCmorAwAiFiACIApqKwMAIhUgFSAWZSING6EgFSAWIA0bIAQgCmorAwChoCADIAlBEGsiCmorAwAgBSAKaisDACIWIAIgCmorAwAiFSAVIBZlIg0boSAVIBYgDRsgBCAKaisDAKGgoSEWIAMgCWorAwAgBSAJaisDACIVIAIgCWorAwAiGCAVIBhmIgoboSAYIBUgChsgBCAJaisDAKGgIRggASADaisDACABIAVqKwMAIhUgASACaisDACIbIBUgG2YiCRuhIBsgFSAJGyABIARqKwMAoaAhFQsgFSAYoSEdRAAAAAAAAAAAIRVEAAAAAAAAAAAhGAJAAkACQAJAIAsOAwABAgMLIAUgAEEDdCIBQRBrIglqKwMAIAIgCWorAwChmSAFIA9BA3QiCUEQayIKaisDACACIApqKwMAoZmhIRQgBSAJQQhrIglqKwMAIAIgCWorAwChmSEYIAUgAUEIayIBaisDACABIAJqKwMAoZkhFQwCCyADIABBA3QiAUEQayIJaisDACAEIAlqKwMAoSADIA9BA3QiCUEQayIKaisDACAEIApqKwMAoaEhFCADIAlBCGsiCWorAwAgBCAJaisDAKEhGCADIAFBCGsiAWorAwAgASAEaisDAKEhFQwBCyADIABBA3QiCUEQayIBaisDACABIAVqKwMAIhQgASACaisDACIVIBQgFWYiChuhIBUgFCAKGyABIARqKwMAoaAgAyAPQQN0IgpBEGsiAWorAwAgASAFaisDACIUIAEgAmorAwAiFSAUIBVmIg0boSAVIBQgDRsgASAEaisDAKGgoSEUIAMgCkEIayIBaisDACABIAVqKwMAIhUgASACaisDACIYIBUgGGYiChuhIBggFSAKGyABIARqKwMAoaAhGCADIAlBCGsiAWorAwAgASAFaisDACIVIAEgAmorAwAiGyAVIBtmIgkboSAbIBUgCRsgASAEaisDAKGgIRULICAgF6AhICAfIBagIR8gIiAdoCEiIA9BAWohDyAQQQFqIRAgAEEBaiEAIBogFKAhGiAZIBUgGKGgIRkgE0EBaiITIBJHDQALIAcgEjYCACAGIAw2AgBBAAVEAAAAAAAAAAAhFEQAAAAAAAAAACEXAkACQAJAAkAgDigClAMOAwABAgMLIAUgAEEDdCILQQhrIglqKwMAIAIgCWorAwChmSEXIAUgC0EQayILaisDACACIAtqKwMAoZkhFAwCCyADIABBA3QiC0EIayIJaisDACAEIAlqKwMAoSEXIAMgC0EQayILaisDACAEIAtqKwMAoSEUDAELIAMgAEEDdCIJQQhrIgtqKwMAIAUgC2orAwAiFCACIAtqKwMAIhYgFCAWZiIKG6EgFiAUIAobIAQgC2orAwChoCEXIAMgCUEQayILaisDACAF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ACEXAkACQAJAAkAgCygCzAIOAwABAgMLIAUgAEEDdCIKaisDACACIApqKwMAoZkhFwwCCyADIABBA3QiCmorAwAgBCAKaisDAKEhFwwBCyADIABBA3QiCmorAwAgBSAKaisDACIXIAIgCmorAwAiGCAXIBhmIhAboSAYIBcgEBsgBCAKaisDAKGgIRcLIABBAWohACAiIBegISIMAQsLBUQAAAAAAAAAACEXAkACQAJAAkAgCygChAIOAwABAgMLIAUgAEEDdCIKaisDACACIApqKwMAoZkhFwwCCyADIABBA3QiCmorAwAgBCAKaisDAKEhFwwBCyADIABBA3QiCmorAwAgBSAKaisDACIXIAIgCmorAwAiGCAXIBhmIhAboSAYIBcgEBsgBCAKaisDAKGgIRcLIABBAWohACAhIBegISEMAQsLBUQAAAAAAAAAACEXAkACQAJAAkAgCygC1AEOAwABAgMLIAUgAEEDdCIOaisDACACIA5qKwMAoZkhFwwCCyADIABBA3QiDmorAwAgBCAOaisDAKEhFwwBCyADIABBA3QiDmorAwAgBSAOaisDACIXIAIgDmorAwAiGCAXIBhmIhEboSAYIBcgERsgBCAOaisDAKGgIRcLIABBAWohACAgIBegISAMAQsLIQwLIAwLmBUCDn8TfCAAQQBIBEBBDA8LQQ0hDAJAIAFBAEggACABSnINAEECIQwgCEUgAkUgA0VyIARFIAVFcnJyDQAgARAhIgwgACAAIAxIGyIMSARAIAZBADYCACAHQQA2AgBBAA8LIAwjAygCACILKALQAmshEiALKALoAiENIAsoAogCIQogDCALKALYASIJayITIQADfyAAIAxOBH8gDEEBayERIAwgCmsiDiEAA38gACAMTgR/IBIhAAN/IAAgDE4EfyARIA1rIgohAAN/IAAgEU4Ef0QAAAAAAAAAQEQAAAAAAADwPyALKALkAiIRQQJGGyElRAAAAAAAAABARAAAAAAAAPA/IAsoAswCIhBBAkYbISZEAAAAAAAAAEBEAAAAAAAA8D8gCygChAIiFEECRhshJ0QAAAAAAAAAQEQAAAAAAADwPyALKALUASIVQQJGGyEoIAEgDGtBAWohFiALKwPgASEpQQAhDSAMIQADQCAFIABBA3QiAWorAwAiGSABIAJqKwMAIhqhmSEXAkAg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oWMNARoLQQALNgIAIABBAWohAEQAAAAAAAAAACELRAAAAAAAAAAAIQoCQAJAAkACQCAXDgMAAQIDCyAFIBVBA3RBCGsiAWorAwAgASACaisDAKGZIQogDSAOoZkhCwwCCyADIBJqKwMAIAQgEmorAwChIQsgAyAVQQN0QQhrIgFqKwMAIAEgBGorAwChIQoMAQsgAyASaisDACANIA4gExuhIA4gDSATGyAEIBJqKwMAoaAhCyADIBVBA3RBCGsiE2orAwAgBSATaisDACIKIAIgE2orAwAiDCAKIAxmIgEboSAMIAogARsgBCATaisDAKGgIQoLIBVBAWohFSARQQFqIREgBiALIAqhoCEGIAAgGEcNAAsgCCAYNgIAIAcgFDYCAEEABUQAAAAAAAAAACELAkACQAJAAkAgFigCpAEOAwABAgMLIAUgAEEDdEEIayIRaisDACACIBFqKwMAoZkhCwwCCyADIABBA3RBCGsiEWorAwAgBCARaisDAKEhCwwBCyADIABBA3RBCGsiE2orAwAgBSATaisDACIKIAIgE2orAwAiDCAKIAxmIhEboSAMIAogERsgBCATaisDAKGgIQsLIABBAWohACAGIAugIQYMAQsLIRELIBELzhACDH8OfCAAQQBIBEBBDA8LQQ0hCgJAIAFBAEggACABSnINAEECIQogCEUgAkUgA0VyIARFIAVFcnJyDQAgARATIg0gACAAIA1IGyINSARAIAZBADYCACAHQQA2AgBBAA8LIwMoAgAiDigCqAEhCSANIA4oApgDayIQIQADfyAAIA1OBH9EAAAAAAAAAAAhGiANIAlrIhEhAAN/IAAgDU4Ef0QAAAAAAAAAQEQAAAAAAADwPyAOKAKUAyITQQJGGyEhRAAAAAAAAABARAAAAAAAAPA/IA4oAqQBIhRBAkYbISIgASANa0EBaiEPQQAhACANIQoDQCAIIABBAnRqAn9BAEEBQX8gBSAKQQFrQQN0IglqKwMAIhkgAiAJaisDACIbZiILG0F/QQEgBSAKQQN0IgxqKwMAIhwgAiAMaisDACIeZiISG0cNABogGSAboZkhFiAOKwOwASEgAkAgDigCqAEiAQRAIBogAbejIRUMAQsgFiEVAkACQAJAIBQOAwMAAQILIAMgCWorAwAgBCAJaisDAKEhFQwCCyADIAlqKwMAIBkg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AAAAACEvAkACQAJAAkAgEg4DAAECAwsgBSAQQQN0QRBrIglqKwMAIAIgCWorAwChmSEvIAUgAEEDdEEQayIJaisDACACIAlqKwMAoZkhHQwCCyADIBBBA3RBEGsiCWorAwAgBCAJaisDAKEhLyADIABBA3RBEGsiCWorAwAgBCAJaisDAKEhHQwBCyADIBBBA3RBEGsiCWorAwAgBSAJaisDACIdIAIgCWorAwAiICAdICBmIgoboSAgIB0gChsgBCAJaisDAKGgIS8gAyAAQQN0QRBrIglqKwMAIAUgCWorAwAiHSACIAlqKwMAIiAgHSAgZiIKG6EgICAdIAobIAQgCWorAwChoCEdC0QAAAAAAAAAACEhRAAAAAAAAAAAISBEAAAAAAAAAAAhMAJAAkACQAJAIBUOAwIBAAMLIAMgC0EDdEEIayIJaisDACAFIAlqKwMAIiAgAiAJaisDACIwICAgMGYiChuhIDAgICAKGyAEIAlqKwMAoaAhMCADIABBA3RBCGsiCWorAwAgBSAJaisDACIgIAIgCWorAwAiLiAgIC5mIgoboSAuICAgChsgBCAJaisDAKGgISAMAgsgAyALQQN0QQhrIglqKwMAIAQgCWorAwChITAgAyAAQQN0QQhrIglqKwMAIAQgCWorAwChISAMAQsgBSALQQN0QQhrIglqKwMAIAIgCWorAwChmSEwIAUgAEEDdEEIayIJaisDACACIAlqKwMAoZkhIAtEAAAAAAAAAAAhLgJAAkACQAJAIBIOAwIBAAMLIAMgEEEDdEEIayIJaisDACAFIAlqKwMAIiEgAiAJaisDACIuICEgLmYiChuhIC4gISAKGyAEIAlqKwMAoaAhLiADIABBA3RBCGsiCWorAwAgBSAJaisDACIhIAIgCWorAwAiOSAhIDlmIgoboSA5ICEgChsgBCAJaisDAKGgISEMAgsgAyAQQQN0QQhrIglqKwMAIAQgCWorAwChIS4gAyAAQQN0QQhrIglqKwMAIAQgCWorAwChISEMAQsgBSAQQQN0QQhrIglqKwMAIAIgCWorAwChmSEuIAUgAEEDdEEIayIJaisDACACIAlqKwMAoZkhIQsgJCAfoSEfIB4gIqEhIiAnIC2hIScgHSAvoSEtICAgMKEhICAYQQFqIRggISAuoSEhRAAAAAAAAAAAISREAAAAAAAAAAAhHgJAAkACQAJAIBoOAwIBAAMLIAEgA2orAwAgKiArIBwboSArICogHBsgASAEaisDAKGgISQgAyARQQN0QRBrIgFqKwMAIAEgBWorAwAiHSABIAJqKwMAIh4gHSAeZiIJG6EgHiAdIAkbIAEgBGorAwChoCEeDAILIAEgA2orAwAgASAEaisDAKEhJCADIBFBA3RBEGsiAWorAwAgASAEaisDAKEhHgwBCyAFIBFBA3RBEGsiAWorAwAgASACaisDAKGZIR4gKiAroZkhJAsgNCAmoCE0IDEgLKAhMSAzIB+gITMgNSAioCE1ICkgJ6AhKSAlIC2gISUgMiAgoCEyICggIaAhKCARQQFqIREgC0EBaiELIBBBAWohECATQQFqIRMgFEEBaiEUIABBAWohACAjICQgHqGgISMgGCAbRw0ACyAHIBs2AgAgBiAONgIAQQAFRAAAAAAAAAAAIR4CQAJAAkACQCANKAKkAQ4DAAECAwsgBSAAQQN0QRBrIglqKwMAIAIgCWorAwChmSEeDAILIAMgAEEDdEEQayIJaisDACAEIAlqKwMAoSEeDAELIAMgAEEDdEEQayIJaisDACAFIAlqKwMAIh0gAiAJaisDACIeIB0gHmYiEhuhIB4gHSASGyAEIAlqKwMAoaAhHgsgAEEBaiEAICMgHqAhIwwBCwsFRAAAAAAAAAAAISNEAAAAAAAAAAAhHgJAAkACQAJAIA0oAvwCDgMAAQIDCyAFIABBA3QiCUEIayIKaisDACACIApqKwMAoZkhHiAFIAlBEGsiCWorAwAgAiAJaisDAKGZISMMAgsgAyAAQQN0IglBCGsiCmorAwAgBCAKaisDAKEhHiADIAlBEGsiCWorAwAgBCAJaisDAKEhIwwBCyADIABBA3QiCkEIayIJaisDACAFIAlqKwMAIh0gAiAJaisDACIeIB0gHmYiERuhIB4gHSARGyAEIAlqKwMAoaAhHiADIApBEGsiCWorAwAgBSAJaisDACIdIAIgCWorAwAiHyAdIB9mIgoboSAfIB0gChsgBCAJaisDAKGgISMLIABBAWohACAeIDKgITIgKSAjoCEpDAELCwVEAAAAAAAAAAAhI0QAAAAAAAAAACEpAkACQAJAAkAgDSgC5AIOAwABAgMLIAUgAEEDdCIJQQhrIgpqKwMAIAIgCmorAwChmSEpIAUgCUEQayIJaisDACACIAlqKwMAoZkhIwwCCyADIABBA3QiCUEIayIKaisDACAEIApqKwMAoSEpIAMgCUEQayIJaisDACAEIAlqKwMAoSEjDAELIAMgAEEDdCIKQQhrIglqKwMAIAUgCWorAwAiHSACIAlqKwMAIh4gHSAeZiIRG6EgHiAdIBEbIAQgCWorAwChoCEpIAMgCkEQayIJaisDACAFIAlqKwMAIh0gAiAJaisDACIeIB0gHmYiChuhIB4gHSAKGyAEIAlqKwMAoaAhIwsgAEEBaiEAICkgKKAhKCAlICOgISUMAQsLBUQAAAAAAAAAACElAkACQAJAAkAgDSgChAIOAwABAgMLIAUgAEEDdCIJaisDACACIAlqKwMAoZkhJQwCCyADIABBA3QiCWorAwAgBCAJaisDAKEhJQwBCyADIABBA3QiCWorAwAgBSAJaisDACIdIAIgCWorAwAiHiAdIB5mIhAboSAeIB0gEBsgBCAJaisDAKGgISULIABBAWohACAlIDWgITUMAQsLBUQAAAAAAAAAACElRAAAAAAAAAAAIShEAAAAAAAAAAAhIwJAAkACQAJAIA0oArQCDgMAAQIDCyAFIABBA3QiC2orAwAgAiALaisDAKGZISMgBSALQQhrIglqKwMAIAIgCWorAwChmSElIAUgC0EQayILaisDACACIAtqKwMAoZkhKAwCCyADIABBA3QiC2orAwAgBCALaisDAKEhIyADIAtBCGsiCWorAwAgBCAJaisDAKEhJSADIAtBEGsiC2orAwAgBCALaisDAKEhKAwBCyADIABBA3QiC2orAwAgBSALaisDACIdIAIgC2orAwAiHiAdIB5mIgkboSAeIB0gCRsgBCALaisDAKGgISMgAyALQQhrIglqKwMAIAUgCWorAwAiHSACIAlqKwMAIh4gHSAeZiIRG6EgHiAdIBEbIAQgCWorAwChoCElIAMgC0EQayILaisDACAFIAtqKwMAIh0gAiALaisDACIeIB0gHmYiCRuhIB4gHSAJGyAEIAtqKwMAoaAhKAsgAEEBaiEAICMgM6AhMyA0ICWgITQgMSAooCExDAELCwsLgxMCDn8PfCAAQQBIBEBBDA8LQQ0hCwJAIAFBAEggACABSnINAEECIQsgAkUgA0VyIARFIAVFcnINAEQzMzMz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IBtmIhAboSAbIBkgEBsgBCAKaisDAKGgoSEZIAMgCWorAwAgBSAJaisDACIbIAIgCWorAwAiGiAaIBtlIgoboSAaIBsgChsgBCAJaisDAKGgIR8gASADaisDACABIAVqKwMAIhsgASACaisDACIaIBogG2UiCRuhIBogGyAJGyABIARqKwMAoaAhGwtEAAAAAAAAAAAhIQJAAkACQAJAIBEOAwABAgMLIAUgC0EDdEEQayIBaisDACABIAJqKwMAoZkhISAFIABBA3RBEGsiAWorAwAgASACaisDAKGZIRgMAgsgAyALQQN0QRBrIgFqKwMAIAEgBGorAwChISEgAyAAQQN0QRBrIgFqKwMAIAEgBGorAwChIRgMAQsgAyALQQN0QRBrIgFqKwMAIAEgBWorAwAiGCABIAJqKwMAIhogGCAaZiIJG6EgGiAYIAkbIAEgBGorAwChoCEhIAMgAEEDdEEQayIBaisDACABIAVqKwMAIhggASACaisDACIaIBggGmYiCRuhIBogGCAJGyABIARqKwMAoaAhGAtEAAAAAAAAAAAhHUQAAAAAAAAAACEcRAAAAAAAAAAAISMCQAJAAkACQCATDgMAAQIDCyAFIA9BA3RBEGsiAWorAwAgASACaisDAKGZISMgBSAAQQN0QRBrIgFqKwMAIAEgAmorAwChmSEcDAILIAMgD0EDdEEQayIBaisDACABIARqKwMAoSEjIAMgAEEDdEEQayIBaisDACABIARqKwMAoSEcDAELIAMgD0EDdEEQayIBaisDACABIAVqKwMAIhogASACaisDACIcIBogHGYiCRuhIBwgGiAJGyABIARqKwMAoaAhIyADIABBA3RBEGsiAWorAwAgASAFaisDACIaIAEgAmorAwAiHCAaIBxmIgkboSAcIBogCRsgASAEaisDAKGgIRwLRAAAAAAAAAAAISgCQAJAAkACQCARDgMCAQADCyADIAtBA3RBCGsiAWorAwAgASAFaisDACIaIAEgAmorAwAiHSAaIB1mIgkboSAdIBogCRsgASAEaisDAKGgISggAyAAQQN0QQhrIgFqKwMAIAEgBWorAwAiGiABIAJqKwMAIh0gGiAdZiIJG6EgHSAaIAkbIAEgBGorAwChoCEdDAILIAMgC0EDdEEIayIBaisDACABIARqKwMAoSEoIAMgAEEDdEEIayIBaisDACABIARqKwMAoSEdDAELIAUgC0EDdEEIayIBaisDACABIAJqKwMAoZkhKCAFIABBA3RBCGsiAWorAwAgASACaisDAKGZIR0LRAAAAAAAAAAAISlEAAAAAAAAAAAhGkQAAAAAAAAAACEiAkACQAJAAkAgEw4DAgEAAwsgAyAPQQN0QQhrIgFqKwMAIAEgBWorAwAiGiABIAJqKwMAIiIgGiAiZiIJG6EgIiAaIAkbIAEgBGorAwChoCEiIAMgAEEDdEEIayIBaisDACABIAVqKwMAIhogASACaisDACIqIBogKmYiCRuhICogGiAJGyABIARqKwMAoaAhGgwCCyADIA9BA3RBCGsiAWorAwAgASAEaisDAKEhIiADIABBA3RBCGsiAWorAwAgASAEaisDAKEhGgwBCyAFIA9BA3RBCGsiAWorAwAgASACaisDAKGZISIgBSAAQQN0QQhrIgFqKwMAIAEgAmorAwChmSEaCyAbIB+hIR8gGCAhoSEhIBwgI6EhHCAdICihIR0gFUEBaiEVIBogIqEhI0QAAAAAAAAAACEYAkACQAJAAkAgFg4DAgEAAwsgAyANQQN0IgFqKwMAIAEgBWorAwAiGCABIAJqKwMAIhsgGCAbZiIJG6EgGyAYIAkbIAEgBGorAwChoCEYIAMgAEEDdCIBaisDACABIAVqKwMAIhsgASACaisDACIaIBogG2UiCRuhIBogGyAJGyABIARqKwMAoaAhKQwCCyADIA1BA3QiAWorAwAgASAEaisDAKEhGCADIABBA3QiAWorAwAgASAEaisDAKEhKQwBCyAFIA1BA3QiAWorAwAgASACaisDAKGZIRggBSAAQQN0IgFqKwMAIAEgAmorAwChmSEpCyAsICCgISwgKyAZoCErIC0gH6AhLSAeICGgIR4gJSAcoCElICYgHaAhJiAkICOgISQgDUEBaiENIAtBAWohCyAPQQFqIQ8gEkEBaiESIABBAWohACAnICkgGKGgIScgFSAXRw0ACyAHIBc2AgAgBiAONgIAQQAFRAAAAAAAAAAAIRgCQAJAAkACQCAMKALUAQ4DAAECAwsgBSAAQQN0IglqKwMAIAIgCWorAwChmSEYDAILIAMgAEEDdCIJaisDACAEIAlqKwMAoSEYDAELIAMgAEEDdCIJaisDACAFIAlqKwMAIhggAiAJaisDACIZIBggGWYiChuhIBkgGCAKGyAEIAlqKwMAoaAhGAsgAEEBaiEAICcgGKAhJwwBCwsFRAAAAAAAAAAAISdEAAAAAAAAAAAhGAJAAkACQAJAIAwoAvwCDgMAAQIDCyAFIABBA3QiCUEIayINaisDACACIA1qKwMAoZkhGCAFIAlBEGsiCWorAwAgAiAJaisDAKGZIScMAgsgAyAAQQN0IglBCGsiDWorAwAgBCANaisDAKEhGCADIAlBEGsiCWorAwAgBCAJaisDAKEhJwwBCyADIABBA3QiDUEIayIJaisDACAFIAlqKwMAIhggAiAJaisDACIZIBggGWYiERuhIBkgGCARGyAEIAlqKwMAoaAhGCADIA1BEGsiCWorAwAgBSAJaisDACIZIAIgCWorAwAiGyAZIBtmIg0boSAbIBkgDRsgBCAJaisDAKGgIScLIABBAWohACAYICagISYgHiAnoCEeDAELCwVEAAAAAAAAAAAhHkQAAAAAAAAAACEmAkACQAJAAkAgDCgC5AIOAwABAgMLIAUgAEEDdCIJQQhrIg1qKwMAIAIgDWorAwChmSEmIAUgCUEQayIJaisDACACIAlqKwMAoZkhHgwCCyADIABBA3QiCUEIayINaisDACAEIA1qKwMAoSEmIAMgCUEQayIJaisDACAEIAlqKwMAoSEeDAELIAMgAEEDdCINQQhrIglqKwMAIAUgCWorAwAiGCACIAlqKwMAIhkgGCAZZiIRG6EgGSAYIBEbIAQgCWorAwChoCEmIAMgDUEQayIJaisDACAFIAlqKwMAIhggAiAJaisDACIZIBggGWYiDRuhIBkgGCANGyAEIAlqKwMAoaAhHgsgAEEBaiEAICYgJKAhJCAlIB6gISUMAQsLBUQAAAAAAAAAACElRAAAAAAAAAAAISREAAAAAAAAAAAhHgJAAkACQAJAIAwoAswCDgMAAQIDCyAFIABBA3QiC2orAwAgAiALaisDAKGZIR4gBSALQQhrIg9qKwMAIAIgD2orAwChmSElIAUgC0EQayILaisDACACIAtqKwMAoZkhJAwCCyADIABBA3QiC2orAwAgBCALaisDAKEhHiADIAtBCGsiD2orAwAgBCAPaisDAKEhJSADIAtBEGsiC2orAwAgBCALaisDAKEhJAwBCyADIABBA3QiC2or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aisDAKGZIRIMAgsgAyAAQQN0IgFBCGsiCWorAwAgBCAJaisDAKEgAyAOQQN0IglBCGsiCmorAwAgBCAKaisDAKGhIRQgAyABQRBrIgpqKwMAIAQgCmorAwChIAMgCUEQayIKaisDACAEIApqKwMAoaEhEyADIAlqKwMAIAQgCWorAwChIRUgASADaisDACABIARqKwMAoSESDAELIAMgAEEDdCIBQQhrIglqKwMAIAUgCWorAwAiEiACIAlqKwMAIhQgEiAUZiIKG6EgFCASIAobIAQgCWorAwChoCADIA5BA3QiCUEIayIKaisDACAFIApqKwMAIhIgAiAKaisDACIUIBIgFGYiDxuhIBQgEiAPGyAEIApqKwMAoaChIRQgAyABQRBrIgpqKwMAIAUgCmorAwAiEiACIApqKwMAIhMgEiATZiIPG6EgEyASIA8bIAQgCmorAwChoCADIAlBEGsiCmorAwAgBSAKaisDACISIAIgCmorAwAiEyASIBNmIg8boSATIBIgDxsgBCAKaisDAKGgoSETIAMgCWorAwAgBSAJaisDACISIAIgCWorAwAiFSASIBVmIgoboSAVIBIgChsgBCAJaisDAKGgIRUgASADaisDACABIAVqKwMAIhIgASACaisDACIWIBIgFmYiCRuhIBYgEiAJGyABIARqKwMAoaAhEgsgDkEBaiEOIABBAWohACAYIBSgIRggGSAToCEZIBcgEiAVoaAhFyALQQFqIgsgEUcNAAsgByARNgIAIAYgDDYCAEEABUQAAAAAAAAAACEURAAAAAAAAAAAIRNEAAAAAAAAAAAhEgJAAkACQAJAIBAoAswCDgMAAQIDCyAFIABBA3QiC2orAwAgAiALaisDAKGZIRIgBSALQQhrIglqKwMAIAIgCWorAwChmSEUIAUgC0EQayILaisDACACIAtqKwMAoZkhEwwCCyADIABBA3QiC2orAwAgBCALaisDAKEhEiADIAtBCGsiCWorAwAgBCAJaisDAKEhFCADIAtBEGsiC2orAwAgBCALaisDAKEhEwwBCyADIABBA3QiC2orAwAgBSALaisDACISIAIgC2orAwAiFCASIBRmIgkboSAUIBIgCRsgBCALaisDAKGgIRIgAyALQQhrIglqKwMAIAUgCWorAwAiFCACIAlqKwMAIhMgEyAUZSING6Eg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";

const initialEmptyState = "initialEmptyState";
const defaultTitle = "Empty";
const defaultConfig = {
    id: undefined,
    title: defaultTitle,
    symbol: defaultTitle,
    width: TX_MAXW,
    height: TX_MAXH,
    utils: {},
    tools: {},
    timeFrame: "1m",
    range: {
        startTS: undefined,
    },
    theme: defaultTheme,
    watermark: {
        display: false,
        text: defaultTitle
    },
    trades: {
        display: true,
        displayInfo: true
    },
    precision: MAX_CRYPTO_PRECISION,
    isCrypto: true,
    logs: false,
    infos: true,
    warnings: true,
    highLow: false,
    errors: true,
    stream: {},
    maxCandleUpdate: 250,
    talib,
    wasm: dataURI,
    state: {},
    stateInheritPrevious: true,
    callbacks: {}
};

class Axis {
    #core;
    #parent;
    #chart;
    constructor(parent) {
        this.#parent = parent;
        this.#core = this.#parent.core;
        this.#chart = this.#core.Chart;
    }
    get core() { return this.#core; }
    get chart() { return this.#chart; }
    get parent() { return this.#parent; }
    get theme() { return this.#core.theme; }
    get width() { return this.#chart.width; }
    get height() { return this.#chart.height; }
    get data() { return this.#chart.data; }
    get range() { return this.#chart.range; }
    get yDigits() { return this.#chart.yAxisDigits; }
}

function getRandomIntBetween(min, max) {
    min = Math.ceil(min) + 1;
    max = Math.floor(max);
    return Math.floor(Math.random() * (max - min) + min);
}
function countDigits(value) {
    const digits = {};
    digits.value = value;
    digits.sign = (!value) ? false : true;
    digits.integers = numDigits(value);
    digits.decimals = precision(value);
    digits.total = digits.integers + digits.decimals;
    return digits;
}
function numDigits(value) {
    return (Math.log10((value ^ (value >> 31)) - (value >> 31)) | 0) + 1;
}
function bRound(n, d = 0) {
    var x = n * Math.pow(10, d);
    var r = Math.round(x);
    var br = (((((x > 0) ? x : (-x)) % 1) === 0.5) ? (((0 === (r % 2))) ? r : (r - 1)) : r);
    return br / Math.pow(10, d);
}
function precision(value) {
    if (typeof value !== "number")
        value = parseFloat(value);
    if (isNaN(value))
        return 0;
    if (!isFinite(value))
        return 0;
    var e = 1, p = 0;
    while (Math.round(value * e) / e !== value) {
        e *= 10;
        if (e === Infinity)
            break;
        p++;
    }
    return p;
}
function limitPrecision(value, precision) {
    if (value == 0)
        return "0";
    const digits = countDigits(value);
    if (isInteger(precision))
        return `${new Number(digits.value).toFixed(precision)}`;
    let { sign: s, integers: i, decimals: d, value: v } = digits;
    precision = (isNaN(precision)) ? MAX_CRYPTO_PRECISION : precision;
    d = limit(d, 0, precision);
    v = new Number(v).toFixed(d);
    let x = `${v}`, r = "", c = 0, f = 0;
    s = (s) ? 0 : 1;
    if (s > 0) {
        r += "-";
        c++;
    }
    if (i == 0) {
        r += "0";
        c++;
    }
    else {
        r += x.slice(c, i);
        c += i;
    }
    if (d != 0) {
        r += `${x.slice(c)}`;
        if (i <= 1) {
            f = d;
        }
        else if (i > 3) {
            f = 2;
        }
        else if (i >= 2) {
            f = 3;
        }
    }
    r = Number.parseFloat(r).toFixed(f);
    return r;
}
function log10(value) {
    return Math.log(value) / Math.log(10);
}
function limit(val, min, max) {
    return Math.min(max, Math.max(min, val));
}
function decimalToHex(decimal) {
    const unsigned = Math.abs(decimal);
    const hex = unsigned.toString(16);
    return hex.length % 2 === 0 ? hex : "0" + hex;
}

class Range {
    #id;
    #core;
    #state;
    #worker;
    #init;
    #indexed;
    #interval;
    #intervalStr;
    #indexStart;
    #indexEnd;
    #secondaryMaxMin;
    #old;
    #initialCnt;
    #limitFuture;
    #limitPast;
    #minCandles;
    #maxCandles;
    #yAxisBounds;
    constructor(start, end, config) {
        this.#init = true;
        this.#indexed = false;
        this.#interval = DEFAULT_TIMEFRAMEMS;
        this.#intervalStr = DEFAULT_TIMEFRAME;
        this.#indexStart = 0;
        this.#indexEnd = LIMITFUTURE;
        this.valueMin = 0;
        this.valueMax = 1;
        this.valueDiff = 1;
        this.volumeMin = 0;
        this.volumeMax = 0;
        this.volumeDiff = 0;
        this.valueMinIdx = 0;
        this.valueMaxIdx = 0;
        this.volumeMinIdx = 0;
        this.volumeMaxIdx = 0;
        this.#secondaryMaxMin = {};
        this.#old = {};
        this.#initialCnt = INTITIALCNT;
        this.#limitFuture = LIMITFUTURE;
        this.#limitPast = LIMITPAST;
        this.#minCandles = MINCANDLES;
        this.#maxCandles = MAXCANDLES;
        this.#yAxisBounds = YAXIS_BOUNDS;
        if (!isObject(config)) {
            throw new Error('Range constructor requires a config object');
        }
        if (!(config?.core instanceof TradeXchart)) {
            throw new Error('Range constructor requires a valid TradeXchart instance');
        }
        this.#id = uid(`${SHORTNAME}_Range`);
        this.#init = true;
        this.setConfig(config);
        let tf;
        if (isInteger(config?.interval))
            tf = config.interval;
        else if (isString(config?.interval))
            tf = interval2MS(config?.interval);
        else
            tf = DEFAULT_TIMEFRAMEMS;
        if (this.data.length == 0) {
            let ts = Date.now();
            start = this.rangeLimit * -2;
            end = this.rangeLimit * 2;
            this.#interval = tf;
            this.#intervalStr = ms2Interval(this.#interval);
            this.anchor = ts - (ts % tf);
        }
        else if (this.data.length < 2) {
            this.#interval = tf;
            this.#intervalStr = ms2Interval(this.interval);
        }
        else {
            this.#interval = detectInterval(this.data);
            this.#intervalStr = ms2Interval(this.interval);
        }
        if (!isInteger(start) || this.isPastLimit(start))
            start = this.data.length - this.#initialCnt;
        if (!isInteger(end) || this.isFutureLimit(end))
            end = this.data.length;
        if (end - start > this.#maxCandles)
            end = end - ((end - start) - this.#maxCandles);
        if (end == 0 && this.data.length >= this.rangeLimit)
            end = this.rangeLimit;
        else if (end == 0)
            end = this.data.length;
        this.set(start, end);
        `
    (input) => {
      return maxMinPriceVol(input)
    }
    function ${this.maxMinPriceVol.toString()}
  `;
    }
    get id() { return this.#id; }
    get core() { return this.#core; }
    get allData() { return this.#state.allData; }
    get data() { return this.allData?.data || []; }
    get dataLength() { return (!!this.allData?.data.length) ? this.allData.data.length - 1 : 0; }
    get Length() { return this.indexEnd - this.indexStart; }
    get timeDuration() { return this.timeFinish - this.timeStart; }
    get timeMin() { return this.value(this.indexStart)[0]; }
    get timeMax() { return this.value(this.indexEnd)[0]; }
    get rangeDuration() { return this.timeMax - this.timeMin; }
    get timeStart() { return this.value(0)[0]; }
    get timeFinish() { return this.value(this.dataLength)[0]; }
    get interval() { return this.#interval; }
    get intervalStr() { return this.#intervalStr; }
    get timeFrame() { return this.#intervalStr; }
    get timeFrameMS() { return this.#interval; }
    get indexStart() { return this.#indexStart; }
    get indexEnd() { return this.#indexEnd; }
    get indexed() { return this.#indexed; }
    get indexEndTS() { return this.value(this.indexEnd)[0]; }
    get indexStartTS() { return this.value(this.indexStart)[0]; }
    get indexPastLimit() { return this.limitPast * -1; }
    get indexFutureLimit() { return this.dataLength + this.limitFuture - 1; }
    set initialCnt(c) { if (isInteger(c))
        this.#initialCnt = c; }
    get initialCnt() { return this.#initialCnt; }
    get limitFuture() { return this.#limitFuture; }
    get limitPast() { return this.#limitPast; }
    get minCandles() { return this.#minCandles; }
    get maxCandles() { return this.#maxCandles; }
    get yAxisBounds() { return this.#yAxisBounds; }
    get rangeLimit() { return this.#limitFuture; }
    get secondaryMaxMin() { return this.#secondaryMaxMin; }
    get diff() { return this?.valueDiff; }
    end() {
    }
    isFutureLimit(idx = this.indexEnd) {
        if (!isInteger(idx))
            return;
        return (idx > this.indexFutureLimit);
    }
    isPastLimit(idx = this.indexStart) {
        if (!isInteger(idx))
            return;
        return (idx < this.indexPastLimit);
    }
    isValidTimestamp(ts, msg) {
        if (isValidTimestamp(ts))
            return true;
        this.#core.warn(`Range.${msg}: invalid timestamp`);
        return false;
    }
    isValidDataset(id, msg) {
        let isValid = !isString(id) || !this.hasDataByID(id);
        if (isValid) {
            this.#core.warn(`Range.${msg}: id ${id} is invalid, no dataset exists.`);
        }
        return !isValid;
    }
    set(start = this.indexStart, end = this.indexEnd, max = this.maxCandles) {
        if (!isInteger(start) ||
            !isInteger(end) ||
            !isInteger(max))
            return false;
        start = start | 0;
        end = end | 0;
        max = max | 0;
        max = limit(max, this.minCandles, this.maxCandles);
        if (start > end)
            [start, end] = [end, start];
        end = limit(end, start + this.minCandles, start + max);
        let len = end - start;
        start = limit(start, this.limitPast * -1, this.dataLength + this.limitFuture - this.minCandles - 1);
        end = limit(end, start + this.minCandles, this.dataLength + this.limitFuture - 1);
        start = (end - start < len) ? start - (len - (end - start)) : start;
        const newStart = start;
        const newEnd = end;
        const oldStart = this.indexStart;
        const oldEnd = this.indexEnd;
        let inOut = this.Length;
        this.#indexStart = start;
        this.#indexEnd = end;
        inOut -= this.Length;
        this.setMaxCandles(max);
        this.setAllMaxMin();
        if (this.#init || this.#old.valueMax != this.valueMax || this.#old.valueMin != this.valueMin) {
            this.#core.emit("range_valueMaxMin", { max: this.valueMax, min: this.valueMin });
        }
        this.#core.emit("range_set", [newStart, newEnd, oldStart, oldEnd]);
        return true;
    }
    setConfig(config) {
        let state = config?.state;
        this.#state = state;
        let core = config?.core;
        if (!(core instanceof TradeXchart))
            throw new Error(`Range requires a valid TradeXchart instance`);
        this.#core = core;
        let initialCnt = (isInteger(config?.initialCnt)) ? config.initialCnt : INTITIALCNT;
        this.#initialCnt = this.#core.config?.range?.initialCnt || initialCnt;
        this.#limitFuture = (isInteger(config?.limitFuture)) ? config.limitFuture : LIMITFUTURE;
        this.#limitPast = (isInteger(config?.limitPast)) ? config.limitPast : LIMITPAST;
        this.#yAxisBounds = (isNumber(config?.yAxisBounds)) ? config.yAxisBounds : YAXIS_BOUNDS;
        this.#minCandles = (isInteger(config?.minCandles)) ? config.minCandles : MINCANDLES;
        this.setMaxCandles(config?.maxCandles);
    }
    setMaxCandles(max) {
        let maxCandles = this.#core?.MainPane?.graph?.width ||
            Math.floor(this.#core?.parentElement?.clientWidth) ||
            MAXCANDLES;
        this.#maxCandles = (isInteger(max)) ? max : maxCandles;
    }
    setMaxMin(maxMin) {
        for (let m in maxMin) {
            this.#old[m] = this[m];
            this[m] = maxMin[m];
        }
        this.scale = (this.dataLength != 0) ? this.Length / this.dataLength : 1;
    }
    value(index, id = "chart") {
        if (!isString(id)) {
            this.#core.warn(`Range.value: id must be a string. Instead received typeOf ${typeof id}`);
            return null;
        }
        const data = this.getDataById(id);
        if (!data) {
            this.#core.warn(`Range.value: no data exists for id: ${id}`);
            return null;
        }
        if (!isInteger(index))
            index = data.length - 1;
        let v = data[index];
        if (v !== undefined)
            return v;
        else {
            const len = data.length - 1;
            v = [null, null, null, null, null, null];
            if (data.length < 1) {
                v[0] = Date.now() + (this.interval * index);
                return v;
            }
            else if (index < 0) {
                v[0] = data[0][0] + (this.interval * index);
                return v;
            }
            else if (index > len) {
                v[0] = data[len][0] + (this.interval * (index - len));
                return v;
            }
            else
                return null;
        }
    }
    valueByTS(ts, id = "chart") {
        const idx = this.getTimeIndex(ts);
        const data = this.getDataById(id);
        if (!data?.length) {
            this.#core.warn(`Range.valueByTS: no data in dataset ${id}`);
            return null;
        }
        if (!idx || idx > data.length) {
            this.#core.warn(`Range.valueByTS: no valid indesx for timestapm ${ts} in dataset ${id}`);
            return null;
        }
        return data[idx];
    }
    hasDataByID(id) {
        if (!isString(id))
            return false;
        if (id === "chart")
            return true;
        const datas = [
            this.allData.primaryPane,
            this.allData.secondaryPane,
            this.allData.datasets
        ];
        for (let data of datas) {
            for (let entry of data) {
                if (id === entry?.id)
                    return true;
            }
        }
        return false;
    }
    getDataById(id = "chart") {
        if (!this.isValidDataset(id, "getDataById"))
            return null;
        if (id === "chart")
            return this.data;
        const datas = [
            this.allData.primaryPane,
            this.allData.secondaryPane,
            this.allData.datasets
        ];
        for (let data of datas) {
            for (let entry of data) {
                if (id === entry?.id)
                    return entry.data;
            }
        }
        return null;
    }
    getTimeIndex(ts, id = "chart") {
        if (!this.isValidTimestamp(ts, "getTimeIndex"))
            return null;
        if (!this.isValidDataset(id, "getTimeIndex"))
            return null;
        ts = ts - (ts % this.interval);
        const data = this.getDataById(id);
        const x = (data.length > 0) ? data[0][0] : this.anchor;
        if (ts === x)
            return 0;
        else if (ts < x)
            return ((x - ts) / this.interval) * -1;
        else
            return (ts - x) / this.interval;
    }
    inRange(t) {
        return (t >= this.timeMin && t <= this.timeMax) ? true : false;
    }
    inPriceHistory(t) {
        return (t >= this.timeStart && t <= this.timeFinish) ? true : false;
    }
    inRenderRange(t) {
        let i = this.getTimeIndex(t);
        let o = this.#core.rangeScrollOffset;
        return (i >= this.indexStart - o && i <= this.indexEnd + o) ? true : false;
    }
    rangeIndex(ts) { return this.getTimeIndex(ts) - this.indexStart; }
    setAllMaxMin() {
        let maxMin = this.maxMinPriceVol({ data: this.data, start: this.indexStart, end: this.indexEnd, that: this });
        this.setMaxMin(maxMin);
        this.maxMinDatasets();
    }
    maxMinPriceVol(input) {
        let { data, start, end, that } = { ...input };
        if (!data || data.length === 0) {
            return {
                valueLo: 0,
                valueHi: 1,
                valueMin: 0,
                valueMax: 1,
                valueDiff: 1,
                valueLast: undefined,
                valueLive: undefined,
                valueLiveMin: undefined,
                valueLiveMax: undefined,
                volumeMin: 0,
                volumeMax: 0,
                volumeDiff: 0,
                valueMinIdx: 0,
                valueMaxIdx: 0,
                volumeMinIdx: 0,
                volumeMaxIdx: 0,
            };
        }
        const l = data.length - 1;
        const buffer = Math.round(that.core.bufferPx / that.core.candleW) || 0;
        start = Math.max(0, (isInteger(start) ? start - buffer : 0));
        end = Math.min(l, isInteger(end) ? end : l);
        let i = limit(start, 0, l);
        let c = limit(end, 0, l);
        let valueMin = data[i][3] || Infinity;
        let valueMax = data[i][2] || -Infinity;
        let volumeMin = data[i][5] || Infinity;
        let volumeMax = data[i][5] || -Infinity;
        let valueMinIdx = i;
        let valueMaxIdx = i;
        let volumeMinIdx = i;
        let volumeMaxIdx = i;
        let val;
        while (i++ < c) {
            val = data[i][3];
            if (isNumber(val) && val < valueMin) {
                valueMin = val;
                valueMinIdx = i;
            }
            val = data[i][2];
            if (isNumber(val) && val > valueMax) {
                valueMax = val;
                valueMaxIdx = i;
            }
            val = data[i][5];
            if (isNumber(val) && val < volumeMin) {
                volumeMin = val;
                volumeMinIdx = i;
            }
            if (isNumber(val) && val > volumeMax) {
                volumeMax = val;
                volumeMaxIdx = i;
            }
        }
        if (valueMin === Infinity)
            valueMin = 0;
        if (valueMax === -Infinity)
            valueMax = 1;
        if (volumeMin === Infinity)
            volumeMin = 0;
        if (volumeMax === -Infinity)
            volumeMax = 0;
        const rawDiff = valueMax - valueMin;
        const valueLo = valueMin;
        const valueHi = valueMax;
        valueMin -= rawDiff * that.yAxisBounds;
        valueMin = Math.max(0, valueMin);
        valueMax += rawDiff * that.yAxisBounds;
        const valueDiff = valueMax - valueMin;
        const valueLast = data[l]?.[4] ?? null;
        const valueLive = that.core.stream?.lastTick?.[4] ?? null;
        const valueLiveMin = that.core.stream?.lastPriceMin ?? null;
        const valueLiveMax = that.core.stream?.lastPriceMax ?? null;
        return {
            valueLo,
            valueHi,
            valueMin,
            valueMax,
            valueDiff,
            valueLast,
            valueLive,
            valueLiveMin,
            valueLiveMax,
            volumeMin,
            volumeMax,
            volumeDiff: volumeMax - volumeMin,
            valueMinIdx,
            valueMaxIdx,
            volumeMinIdx,
            volumeMaxIdx
        };
        function limit(val, min, max) {
            return Math.min(max, Math.max(min, val));
        }
    }
    maxMinDatasets() {
        if (!this.allData?.secondaryPane?.length)
            return;
        let old = Object.keys(this.#secondaryMaxMin) || [];
        for (let pane of this.allData.secondaryPane) {
            let index = old.indexOf(pane.id);
            let input = {
                data: pane.data,
                start: this.indexStart,
                end: this.indexEnd,
                that: this
            };
            this.#secondaryMaxMin[pane.id] = this.maxMinData(input);
            if (index !== -1) {
                old.splice(index, 1);
            }
        }
        for (let del of old) {
            delete this.#secondaryMaxMin[del];
        }
    }
    maxMinData(input) {
        let { data, start, end, that } = { ...input };
        let buffer = bRound(that.#core.bufferPx / that.#core.candleW);
        let l = data?.length - 1 || 0;
        let x = this.dataLength - data?.length || 0;
        let f = data?.[0]?.length - 1 || 0;
        const r = {};
        const d = {
            min: 0,
            max: 1,
            minIdx: 0,
            maxIdx: 0,
            diff: 1,
            last: undefined
        };
        if (l < 1 || !data || !data[0]?.length)
            return { data: d };
        for (let g = f; g > 0; g--) {
            r[`data${g}`] = d;
        }
        buffer = (isInteger(buffer)) ? buffer : 0;
        start = (isInteger(start)) ? start - buffer : 0;
        start = (start > 0) ? start - x : 0;
        end = (isInteger(end)) ? end - x : l;
        if (l < 0 || data[0].length == 0)
            return r;
        let i = limit(start, 0, l);
        let c = limit(end, 0, l);
        if (i >= c)
            return r;
        let j, v, min, max, diff, tMin, tMax, tDiff;
        for (let d in r) {
            max = (isNumber(data[i][f])) ? data[i][f] : -Infinity;
            min = max;
            r[d].min = max;
            r[d].max = max;
            j = i;
            while (j++ < c) {
                v = data[j][f];
                if (!isNumber(v))
                    continue;
                if (v <= min) {
                    r[d].min = v;
                    r[d].minIdx = j;
                    min = v;
                }
                if (v >= max) {
                    r[d].max = v;
                    r[d].maxIdx = j;
                    max = v;
                }
            }
            if (tMin === undefined || min < tMin)
                tMin = min;
            if (tMax === undefined || max > tMax)
                tMax = max;
            diff = r[d].max - r[d].min;
            r[d].diff = (!isNaN(diff)) ? diff : 0;
            --f;
        }
        if (tMin === undefined)
            tMin = 0;
        if (tMax === undefined)
            tMax = 1;
        tDiff = tMax - tMin;
        tMin -= tDiff * this.yAxisBounds;
        tMax += tDiff * this.yAxisBounds;
        tDiff = tMax - tMin;
        r.data = {
            min: tMin,
            max: tMax,
            diff: tMax - tMin
        };
        return r;
    }
    snapshot(start, end) {
        let data = this.export();
        data.snapshot = true;
        data.ts = Date.now();
        JSON.parse(JSON.stringify(this.data));
        data.dataLength = this.dataLength;
        data.Length = this.Length;
        return data;
    }
    export(exclude) {
        let data = {};
        exclude = (isArray(exclude)) ? exclude : [];
        for (let c of copy) {
            if (!exclude.includes(c))
                data[c] = this[c];
        }
        return data;
    }
}
function detectInterval(ohlcv) {
    if (!isArray(ohlcv) ||
        ohlcv.length < 2)
        return Infinity;
    if (!ohlcv.every(candle => isArray(candle) && candle.length >= 1 && typeof candle[0] === 'number')) {
        return Infinity;
    }
    let len = Math.min(ohlcv.length - 1, 99);
    let min = Infinity;
    ohlcv.slice(0, len).forEach((x, i) => {
        let d = ohlcv[i + 1][0] - x[0];
        if (!isNaN(d) && d < min)
            min = d;
    });
    return min;
}
const copy = [
    "indexEnd",
    "indexStart",
    "scale",
    "secondaryMaxMin",
    "valueDiff",
    "valueHi",
    "valueLo",
    "valueMax",
    "valueMaxIdx",
    "valueMin",
    "valueMinIdx",
    "volumeDiff",
    "volumeMax",
    "volumeMaxIdx",
    "volumeMin",
    "volumeMinIdx",
    "diff",
    "indexFutureLimit",
    "id",
    "indexed",
    "initialCnt",
    "interval",
    "intervalStr",
    "limitFuture",
    "limitPast",
    "maxCandles",
    "minCandles",
    "indexPastLimit",
    "rangeDuration",
    "rangeLimit",
    "timeDuration",
    "timeFinish",
    "timeFrame",
    "timeFrameMS",
    "timeMax",
    "timeMin",
    "timeStart",
    "yAxisBounds",
];

const TIMEUNITS = ['y', 'M', 'd', 'h', 'm', 's', 'ms'];
const TIMEUNITSLONG = ['years', 'months', 'days', 'hours', 'minutes', 'seconds', 'milliseconds'];
const dayCntInc = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
const dayCntLeapInc = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
const monthDayCnt = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
const MONTHMAP = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
const BTCGENESIS = 1231006505000;
const MILLISECOND = 1;
const SECOND_MS$1 = 1000;
const MINUTE_MS$1 = SECOND_MS$1 * 60;
const HOUR_MS$1 = MINUTE_MS$1 * 60;
const DAY_MS$1 = HOUR_MS$1 * 24;
const WEEK_MS = DAY_MS$1 * 7;
const MONTHR_MS$1 = DAY_MS$1 * 30;
function MONTH_MS(m = 3, l = false) {
    let ms = monthDayCnt[m % 12] * DAY_MS$1;
    if (l && m > 0)
        ms += DAY_MS$1;
    return ms;
}
const YEAR_MS$1 = DAY_MS$1 * 365;
const TIMEUNITSVALUESSHORT = {
    y: YEAR_MS$1,
    M: MONTHR_MS$1,
    w: WEEK_MS,
    d: DAY_MS$1,
    h: HOUR_MS$1,
    m: MINUTE_MS$1,
    s: SECOND_MS$1,
    u: MILLISECOND
};
const TIMEUNITSVALUESLONG = {
    years: YEAR_MS$1,
    months: MONTHR_MS$1,
    weeks: WEEK_MS,
    days: DAY_MS$1,
    hours: HOUR_MS$1,
    minutes: MINUTE_MS$1,
    seconds: SECOND_MS$1,
    milliseconds: MILLISECOND
};
const TIMEUNITSVALUES = { ...TIMEUNITSVALUESSHORT, ...TIMEUNITSVALUESLONG };
const TIMESCALESVALUES = {
    YEARS10: [YEAR_MS$1 * 10, "years", 10],
    YEARS5: [YEAR_MS$1 * 5, "years", 5],
    YEARS3: [YEAR_MS$1 * 3, "years", 3],
    YEARS2: [YEAR_MS$1 * 2, "years", 2],
    YEARS: [YEAR_MS$1, "years", 1],
    MONTH6: [MONTHR_MS$1 * 6, "months", 6],
    MONTH4: [MONTHR_MS$1 * 4, "months", 4],
    MONTH3: [MONTHR_MS$1 * 3, "months", 3],
    MONTH2: [MONTHR_MS$1 * 2, "months", 2],
    MONTH: [MONTHR_MS$1, "months", 1],
    DAY15: [DAY_MS$1 * 15, "years", 15],
    DAY10: [DAY_MS$1 * 10, "days", 10],
    DAY7: [DAY_MS$1 * 7, "days", 7],
    DAY5: [DAY_MS$1 * 5, "days", 5],
    DAY3: [DAY_MS$1 * 3, "days", 3],
    DAY2: [DAY_MS$1 * 2, "days", 2],
    DAY: [DAY_MS$1, "days", 1],
    HOUR12: [HOUR_MS$1 * 12, "hours", 12],
    HOUR6: [HOUR_MS$1 * 6, "hours", 6],
    HOUR4: [HOUR_MS$1 * 4, "hours", 4],
    HOUR3: [HOUR_MS$1 * 3, "hours", 3],
    HOUR2: [HOUR_MS$1 * 2, "hours", 2],
    HOUR: [HOUR_MS$1, "hours", 1],
    MINUTE30: [MINUTE_MS$1 * 30, "minutes", 30],
    MINUTE15: [MINUTE_MS$1 * 15, "minutes", 15],
    MINUTE10: [MINUTE_MS$1 * 10, "minutes", 10],
    MINUTE5: [MINUTE_MS$1 * 5, "minutes", 5],
    MINUTE3: [MINUTE_MS$1 * 3, "minutes", 3],
    MINUTE2: [MINUTE_MS$1 * 2, "minutes", 2],
    MINUTE: [MINUTE_MS$1, "minutes", 1],
    SECOND30: [SECOND_MS$1 * 30, "seconds", 30],
    SECOND15: [SECOND_MS$1 * 15, "seconds", 15],
    SECOND10: [SECOND_MS$1 * 10, "seconds", 10],
    SECOND5: [SECOND_MS$1 * 5, "seconds", 5],
    SECOND2: [SECOND_MS$1 * 2, "seconds", 2],
    SECOND: [SECOND_MS$1, "seconds", 1],
    MILLISECOND500: [MILLISECOND * 500, "milliseconds", 500],
    MILLISECOND250: [MILLISECOND * 250, "milliseconds", 250],
    MILLISECOND100: [MILLISECOND * 100, "milliseconds", 100],
    MILLISECOND50: [MILLISECOND * 50, "milliseconds", 50],
    MILLISECOND: [MILLISECOND, "milliseconds", 1],
};
const defaultTF = {};
for (let t of Object.values(TIMESCALESVALUES)) {
    let ms = t[0] * 1;
    let key = ms2Interval(ms);
    if (ms < 60000)
        continue;
    defaultTF[`${key}`] = ms;
}
Object.freeze(defaultTF);
const defaultTimeFrames = defaultTF;
const TIMEFRAMEMIN = MINUTE_MS$1;
const INTERVALMIN = TIMEFRAMEMIN;
const TIMEFRAMEMAX = TIMESCALESVALUES.YEARS10[0];
const INTERVALMAX = TIMEFRAMEMAX;
const timeScales = () => {
    const values = Object.values(TIMESCALESVALUES);
    const vals = [];
    for (let v = values.length; --v; v > 0)
        vals[v] = values[v][0];
    return vals;
};
const TIMESCALES = timeScales();
const timeRanks = () => {
    const values = Object.values(TIMESCALESVALUES);
    const vals = [];
    for (let v = values.length; --v; v > 0)
        vals[v] = values[v][1];
    return vals;
};
const TIMESCALESRANK = timeRanks();
const TIMESCALESKEYS = Object.keys(TIMESCALESVALUES);
const timeScalesValues = () => {
    const values = {};
    for (const [key, value] of Object.entries(TIMESCALESVALUES)) {
        values[key] = value[0];
    }
    return values;
};
const TIMESCALESVALUESKEYS = timeScalesValues();
function getTimezone() {
    const offset = new Date().getTimezoneOffset();
    if (Object.prototype.hasOwnProperty.call(timezones, offset)) {
        return timezones[offset.toString()];
    }
    return 'Etc/UTC';
}
function buildSubGrads() {
    const grads = {};
    for (let unit in TIMEUNITSVALUESSHORT) {
        let i = 0;
        grads[unit] = [];
        do {
            grads[unit].push(Math.round(TIMEUNITSVALUESSHORT[unit] * i));
            i += 0.125;
        } while (i < 1);
    }
    return grads;
}
function isValidTimestamp(ts) {
    const date = new Date(ts);
    return (date instanceof Date && !isNaN(date.valueOf()) && isFinite(date.valueOf()));
}
function isValidTimeInRange(time, start = BTCGENESIS, end = Date.now()) {
    if (!isValidTimestamp(time))
        return false;
    return (time > start && time < end) ? true : false;
}
function parseTSDiff(d1, d2, unit) {
    d1 = new Date(d1);
    d2 = new Date(d2);
    let t2 = d2.getTime();
    let t1 = d1.getTime();
    return parseInt((t2 - t1) / unit);
}
const timestampDiff = {
    inSeconds: function (d1, d2) {
        return parseTSDiff(d1, d2, SECOND_MS$1);
    },
    inMinutes: function (d1, d2) {
        return parseTSDiff(d1, d2, MINUTE_MS$1);
    },
    inHours: function (d1, d2) {
        return parseTSDiff(d1, d2, HOUR_MS$1);
    },
    inDays: function (d1, d2) {
        return parseTSDiff(d1, d2, DAY_MS$1);
    },
    inWeeks: function (d1, d2) {
        return parseTSDiff(d1, d2, WEEK_MS);
    },
    inMonths: function (d1, d2) {
        d1 = new Date(d1);
        d2 = new Date(d2);
        let d1Y = d1.getUTCFullYear();
        let d2Y = d2.getUTCFullYear();
        let d1M = d1.getUTCMonth();
        let d2M = d2.getUTCMonth();
        return (d2M + 12 * d2Y) - (d1M + 12 * d1Y);
    },
    inYears: function (d1, d2) {
        let d1Y = new Date(d1);
        let d2Y = new Date(d2);
        return d2Y.getUTCFullYear() - d1Y.getUTCFullYear();
    }
};
function timestampDifference(date1, date2) {
    let years = timestampDiff.inYears(date1, date2);
    let months = timestampDiff.inMonths(date1, date2);
    let weeks = timestampDiff.inWeeks(date1, date2);
    let days = timestampDiff.inDays(date1, date2);
    let hours = timestampDiff.inHours(date1, date2);
    let minutes = timestampDiff.inMinutes(date1, date2);
    let seconds = timestampDiff.inSeconds(date1, date2);
    let milliseconds = new Date(date2).getTime() - new Date(date1).getTime();
    return {
        y: years,
        M: months,
        w: weeks,
        d: days,
        h: hours,
        m: minutes,
        s: seconds,
        ms: milliseconds,
        years: years,
        months: months,
        weeks: weeks,
        days: days,
        hours: hours,
        minutes: minutes,
        seconds: seconds,
        milliseconds: milliseconds
    };
}
function isTimeFrameMS(ms) {
    return (isInteger(ms) &&
        !(ms < SECOND_MS$1) &&
        !(ms === Infinity));
}
function isTimeFrame(tf) {
    let ms = SECOND_MS$1;
    if (isString(tf)) {
        ms = interval2MS(tf);
        if (ms)
            tf = tf;
        else {
            ms = SECOND_MS$1;
            tf = "1s";
        }
    }
    else if (isInteger(tf)) {
        ms = tf;
        tf = ms2Interval(tf);
    }
    else
        tf = "1s";
    return { tf, ms };
}
function interval2MS(tf) {
    if (!isString(tf))
        return undefined;
    const regex = /([0-9]{1,2})([s|m|h|d|w|M|y])/gm;
    let m;
    if ((m = regex.exec(tf)) !== null) {
        return TIMEUNITSVALUESSHORT[m[2]] * m[1];
    }
    else
        return undefined;
}
function ms2TimeUnits(milliseconds) {
    let seconds = Math.floor(milliseconds / 1000);
    let minutes = Math.floor(seconds / 60);
    seconds = seconds % 60;
    let hours = Math.floor(minutes / 60);
    minutes = minutes % 60;
    let days = Math.floor(hours / 24);
    hours = hours % 24;
    let _weeks = Math.floor(days / 7);
    days = days % 7;
    let months = Math.floor(_weeks / 4);
    let years = Math.floor(_weeks / 52);
    let weeks = _weeks % 4;
    months = months % 13;
    return {
        y: years,
        M: months,
        w: weeks,
        d: days,
        h: hours,
        m: minutes,
        s: seconds,
        years: years,
        months: months,
        weeks: weeks,
        days: days,
        hours: hours,
        minutes: minutes,
        seconds: seconds,
    };
}
function ms2Interval(milliseconds) {
    const intervals = ms2TimeUnits(milliseconds);
    for (const unit in intervals) {
        if (intervals[unit])
            return `${intervals[unit]}${unit}`;
    }
}
function get_second(t) {
    return t ? new Date(t).getUTCSeconds() : null;
}
function second_start(t) {
    let start = new Date(t);
    return start.setUTCMilliseconds(0, 0);
}
function get_minute(t) {
    return t ? new Date(t).getUTCMinutes() : null;
}
function minute_start(t) {
    let start = new Date(t);
    return start.setUTCSeconds(0, 0);
}
function get_hour(t) {
    return t ? new Date(t).getUTCHours() : null;
}
function hour_start(t) {
    let start = new Date(t);
    return start.setUTCMinutes(0, 0, 0);
}
function get_day(t) {
    return t ? new Date(t).getUTCDate() : undefined;
}
function get_dayName(t, locale = "en-GB", len = "short") {
    return new Date(t).toLocaleDateString(locale, { weekday: len });
}
function day_start(t) {
    return new Date(t).setUTCHours(0, 0, 0, 0);
}
function get_month(t) {
    if (!t)
        return undefined;
    return new Date(t).getUTCMonth();
}
function get_monthName(t, locale = "en-GB", len = "short") {
    return new Date(t).toLocaleDateString(locale, { month: len });
}
function month_start(t) {
    let date = new Date(t);
    return Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), 1);
}
function nextMonth(t) {
    let m = (get_month(t) + 1) % 12;
    t += MONTH_MS(m, isLeapYear(t));
    return t;
}
function get_year(t) {
    if (!t)
        return undefined;
    return new Date(t).getUTCFullYear();
}
function year_start(t) {
    return Date.UTC(new Date(t).getUTCFullYear());
}
function nextYear(t) {
    t = t + YEAR_MS$1 + DAY_MS$1;
    if (!isLeapYear(t))
        ;
    return t;
}
function isLeapYear(t) {
    let date = new Date(t);
    let year = date.getUTCFullYear();
    if ((year & 3) != 0)
        return false;
    return ((year % 100) != 0 || (year % 400) == 0);
}
function dayOfYear(t) {
    let date = new Date(t);
    let mn = date.getUTCMonth();
    let dn = date.getUTCDate();
    let dayOfYear = dayCount[mn] + dn;
    if (mn > 1 && isLeapYear())
        dayOfYear++;
    return dayOfYear;
}
function time_start(t, unit) {
    const findStart = {
        years: (t) => year_start(t),
        months: (t) => month_start(t),
        weeks: (t) => day_start(t),
        days: (t) => day_start(t),
        hours: (t) => hour_start(t),
        minutes: (t) => minute_start(t),
        seconds: (t) => second_start(t),
    };
    return findStart[unit](t);
}
function unitRange(ts, tf) {
    let start, end;
    switch (tf) {
        case "years":
            start = year_start(ts);
            end = nextYear(ts);
            break;
        case "months":
            start = month_start(ts);
            end = nextMonth(ts);
            break;
        case "weeks":
            start = day_start(ts);
            end = start + DAY_MS$1;
            break;
        case "days":
            start = day_start(ts);
            end = start + DAY_MS$1;
            break;
        case "hours":
            start = hour_start(ts);
            end = start + HOUR_MS$1;
            break;
        case "minutes":
            start = minute_start(ts);
            end = start + MINUTE_MS$1;
            break;
        case "seconds":
            start = second_start(ts);
            end = start + SECOND_MS$1;
    }
    return { start, end };
}
function HM(t) {
    let { d, h, m } = DHMS(t);
    if (h == "0" && m == "0")
        return `${d}`;
    else
        return `${h}:${m}`;
}
function HMS(t) {
    let { d, h, m, s } = DHMS(t);
    if (h == "0" && m == "0" && s == "0")
        return `${d}`;
    return `${h}:${m}:${s}`;
}
function MS(t) {
    let { d, h, m, s } = DHMS(t);
    if (h == "0" && m == "0" && s == "0")
        return `${d}`;
    return `${m}:${s}`;
}
function DHMS(t) {
    let d, h, m, s;
    d = String(get_day(t));
    h = String(get_hour(t)).padStart(2, '0');
    m = String(get_minute(t)).padStart(2, '0');
    s = String(get_second(t)).padStart(2, '0');
    return { d, h, m, s };
}
function nearestTs(t, ts) {
    let dist = Infinity;
    let val = null;
    let index = -1;
    for (let i = 0; i < ts.length; i++) {
        let ti = ts[i][0];
        if (Math.abs(ti - t) < dist) {
            dist = Math.abs(ti - t);
            val = ts[i];
            index = i;
        }
    }
    return [index, val];
}
class TimeData {
    #range = {};
    #timeZoneOffset = getTimezoneOffset();
    #timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    static { this.timeUnits = TIMEUNITS; }
    static { this.timeUnitsLong = TIMEUNITSLONG; }
    static { this.timeUnitsValues = TIMESCALESVALUES; }
    static { this.timeScaleValues = TIMESCALESVALUES; }
    static { this.BTCGenesis = BTCGENESIS; }
    constructor(range) {
        if (range instanceof Range)
            this.#range = range;
        this.setTimeZone(Intl.DateTimeFormat().resolvedOptions().timeZone);
    }
    get range() { return this.#range; }
    get timeFrameMS() { return this.#range.interval; }
    get timeFrame() { return this.#range.intervalStr; }
    set timeZone(z) { this.setTimeZone(z); }
    get timeZone() { return this.#timeZone; }
    set timeZoneOffset(z) { this.#timeZoneOffset = (isNumber(z)) ? z : new Date().getTimezoneOffset(); }
    get timeZoneOffset() { return this.#timeZoneOffset; }
    get timeZoneLocal() { return getTimezone(); }
    get indexed() { return this.#range.indexed; }
    setTimeZone(z) {
        if (Intl.supportedValuesOf('timeZone').includes(z)) {
            this.#timeZone = z;
            this.#timeZoneOffset = getTimezoneOffset(z);
        }
    }
    isValidTimestamp(ts) {
        return isValidTimestamp(ts);
    }
    isValidTimeInRange(time, start = BTCGENESIS, end = Date.now()) {
        return isValidTimeInRange(time, start, end);
    }
    interval2MS(tf) {
        return interval2MS(tf);
    }
    ms2Interval(ms) {
        return ms2Interval(ms);
    }
    static timezoneLocal() {
        return getTimezone();
    }
    static timezoneOffset(timeZone, locale) {
        return getTimezoneOffset(timeZone, locale);
    }
    static IANATimeZone(locale) {
        return IANATimeZones(locale);
    }
    static isValidTimestamp(ts) {
        return isValidTimestamp(ts);
    }
    static isValidTimeInRange(time, start = BTCGENESIS, end = Date.now()) {
        return isValidTimeInRange(time, start, end);
    }
    static interval2MS(tf) {
        return interval2MS(tf);
    }
    static ms2Interval(ms) {
        return ms2Interval(ms);
    }
}
function IANATimeZones(locale = 'en-US') {
    const tz = {};
    Intl.supportedValuesOf('timeZone').forEach((timeZone) => {
        let offset = getTimezoneOffset(timeZone, locale);
        tz[timeZone] = offset;
    });
    return tz;
}
function getTimezoneOffset(timeZone = Intl.DateTimeFormat().resolvedOptions().timeZone, locale = 'en-US') {
    const now = new Date();
    const tzString = now.toLocaleString(locale, { timeZone });
    const localString = now.toLocaleString(locale);
    const diff = (Date.parse(localString) - Date.parse(tzString)) / 3600000;
    const offset = diff + now.getTimezoneOffset() / 60;
    return -offset;
}

var Time = /*#__PURE__*/Object.freeze({
    __proto__: null,
    BTCGENESIS: BTCGENESIS,
    DAY_MS: DAY_MS$1,
    HM: HM,
    HMS: HMS,
    HOUR_MS: HOUR_MS$1,
    IANATimeZones: IANATimeZones,
    INTERVALMAX: INTERVALMAX,
    INTERVALMIN: INTERVALMIN,
    MILLISECOND: MILLISECOND,
    MINUTE_MS: MINUTE_MS$1,
    MONTHMAP: MONTHMAP,
    MONTHR_MS: MONTHR_MS$1,
    MONTH_MS: MONTH_MS,
    MS: MS,
    SECOND_MS: SECOND_MS$1,
    TIMEFRAMEMAX: TIMEFRAMEMAX,
    TIMEFRAMEMIN: TIMEFRAMEMIN,
    TIMESCALES: TIMESCALES,
    TIMESCALESKEYS: TIMESCALESKEYS,
    TIMESCALESRANK: TIMESCALESRANK,
    TIMESCALESVALUES: TIMESCALESVALUES,
    TIMESCALESVALUESKEYS: TIMESCALESVALUESKEYS,
    TIMEUNITS: TIMEUNITS,
    TIMEUNITSLONG: TIMEUNITSLONG,
    TIMEUNITSVALUES: TIMEUNITSVALUES,
    TIMEUNITSVALUESLONG: TIMEUNITSVALUESLONG,
    TIMEUNITSVALUESSHORT: TIMEUNITSVALUESSHORT,
    TimeData: TimeData,
    WEEK_MS: WEEK_MS,
    YEAR_MS: YEAR_MS$1,
    buildSubGrads: buildSubGrads,
    dayCntInc: dayCntInc,
    dayCntLeapInc: dayCntLeapInc,
    dayOfYear: dayOfYear,
    day_start: day_start,
    defaultTimeFrames: defaultTimeFrames,
    getTimezone: getTimezone,
    getTimezoneOffset: getTimezoneOffset,
    get_day: get_day,
    get_dayName: get_dayName,
    get_hour: get_hour,
    get_minute: get_minute,
    get_month: get_month,
    get_monthName: get_monthName,
    get_second: get_second,
    get_year: get_year,
    hour_start: hour_start,
    interval2MS: interval2MS,
    isLeapYear: isLeapYear,
    isTimeFrame: isTimeFrame,
    isTimeFrameMS: isTimeFrameMS,
    isValidTimeInRange: isValidTimeInRange,
    isValidTimestamp: isValidTimestamp,
    minute_start: minute_start,
    monthDayCnt: monthDayCnt,
    month_start: month_start,
    ms2Interval: ms2Interval,
    ms2TimeUnits: ms2TimeUnits,
    nearestTs: nearestTs,
    nextMonth: nextMonth,
    nextYear: nextYear,
    second_start: second_start,
    time_start: time_start,
    timestampDiff: timestampDiff,
    timestampDifference: timestampDifference,
    unitRange: unitRange,
    year_start: year_start
});

const composition = ["source-over", "source-atop", "source-in", "source-out", "destination-over", "destination-atop", "destination-in", "destination-out", "lighter", "copy", "xor", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
const _OffscreenCanvas = (typeof OffscreenCanvas !== "undefined") ? true : false;
const contextTypes = ["2d", "webgl", "webgl2d", "webgl2", "webgpu", "bitmaprenderer"];
let Node$1 = class Node {
    #key = 0;
    #id;
    #scene;
    #layers;
    #container;
    constructor(cfg = {}) {
        if (!cfg?.offscreen && !isHTMLElement(cfg?.container))
            throw new Error("Viewport container is not a valid HTML element.");
        this.#container = cfg.container;
        this.#layers = [];
        this.#id = CEL.idCnt++;
        this.#scene = new CEL.Scene(cfg);
        const rect = this.#container.getBoundingClientRect();
        this.setSize(rect.width || cfg.width, rect.height || cfg.height);
    }
    get id() { return this.#id; }
    get scene() { return this.#scene; }
    get layers() { return this.#layers; }
    get container() { return this.#container; }
    get OffscreenCanvas() { return _OffscreenCanvas; }
    generateKey() {
        return this.#key++;
    }
    setSize(width, height) {
        let { width: w, height: h } = sizeSanitize(width, height);
        this.width = w;
        this.height = h;
        this.scene.setSize(w, h);
        this.layers.forEach(function (layer) {
            layer.setSize(w, h);
        });
        return this;
    }
    addLayer(layer) {
        if (!(layer instanceof Layer))
            return false;
        this.layers.push(layer);
        layer.setSize(layer.width || this.width, layer.height || this.height);
        layer.viewport = this;
        return this;
    }
    removeLayer(layer) {
        if (!(layer instanceof Layer) ||
            !layer.index ||
            this.layers[layer.index] !== layer)
            return false;
        this.layers.splice(layer.index, 1);
        return true;
    }
    getIntersection(x, y) {
        var layers = this.layers, n = layers.length - 1, layer, key;
        while (n >= 0) {
            layer = layers[n];
            key = layer.hit.getIntersection(x, y);
            if (key >= 0) {
                return key;
            }
            n--;
        }
        return -1;
    }
    get index() {
        let viewports = CEL.viewports, viewport, n = 0;
        for (viewport of viewports) {
            if (this.id === viewport.id)
                return n;
            n++;
        }
        return null;
    }
    destroy() {
        for (let layer of this.layers) {
            this.removeLayer(layer);
            layer.destroy();
        }
    }
    render(all = false) {
        let { scene, layers } = this, layer;
        scene.clear();
        let ctx = scene.context;
        if (!ctx)
            return;
        ctx.save();
        for (layer of layers) {
            if (all &&
                isArray(layer.layers) &&
                layer.layers.length > 0)
                layer.render(all);
            if (layer.visible && layer.width > 0 && layer.height > 0) {
                if (composition.includes(layer?.composition))
                    ctx.globalCompositeOperation = layer.composition;
                ctx.globalAlpha = layer.alpha;
                ctx.scale(1, 1);
                ctx.drawImage(layer.scene.canvas, layer.x, layer.y, layer.width, layer.height);
            }
        }
        ctx.restore();
    }
};
class Viewport extends Node$1 {
    constructor(cfg = {}) {
        const cfg2 = { ...cfg };
        cfg2.offscreen = false;
        super(cfg2);
        const canvas = this.scene.canvas;
        const c = cfg.container;
        if (c?.hasCanvasSlot)
            canvas.slot = "viewportCanvas";
        c.innerHTML = "";
        c.appendChild(canvas);
        CEL.viewports.push(this);
    }
    destroy() {
        super.destroy();
        this.container.innerHTML = "";
        CEL.viewports.splice(this.index, 1);
    }
}
class Layer {
    #x = 0;
    #y = 0;
    #width = 0;
    #height = 0;
    #alpha = 1;
    #visible = true;
    #composition = null;
    #offScreen = _OffscreenCanvas;
    constructor(cfg = {}) {
        const c = { ...cfg };
        this.id = CEL.idCnt++;
        this.#offScreen = (isBoolean(cfg?.offscreen)) ? cfg.offscreen : this.#offScreen;
        c.layer = this;
        c.offscreen = this.#offScreen;
        this.hit = new CEL.Hit(c);
        this.scene = new CEL.Scene(c);
        if (cfg?.x && cfg?.y) {
            this.setPosition(cfg.x, cfg.y);
        }
        if (cfg?.width && cfg?.height) {
            this.setSize(cfg.width, cfg.height);
        }
        if (cfg?.composition) {
            this.composition = cfg.composition;
        }
        if (cfg?.alpha) {
            this.alpha = cfg.alpha;
        }
        if (cfg?.visible) {
            this.visible = cfg.visible;
        }
    }
    set x(x) { if (isNumber(x))
        this.#x = x; }
    get x() { return this.#x; }
    set y(y) { if (isNumber(y))
        this.#y = y; }
    get y() { return this.#y; }
    set width(width) { if (isNumber(width))
        this.#width = width; }
    get width() { return this.#width; }
    set height(height) { if (isNumber(height))
        this.#height = height; }
    get height() { return this.#height; }
    set alpha(alpha) { this.#alpha = (isNumber(alpha)) ? limit(alpha, 0, 1) : 1; }
    get alpha() { return this.#alpha; }
    set composition(c) { if (composition.includes(c))
        this.#composition = c; }
    get composition() { return this.#composition; }
    set visible(v) { if (isBoolean(v))
        this.#visible = v; }
    get visible() { return this.#visible; }
    get isOffScreen() { return this.#offScreen; }
    get index() {
        let layers = this.viewport.layers, n = 0, layer;
        for (layer of layers) {
            if (this.id === layer.id)
                return n;
            n++;
        }
        return null;
    }
    setPosition(x, y) {
        this.x = x;
        this.y = y;
        return this;
    }
    setSize(width, height) {
        let { width: w, height: h } = sizeSanitize(width, height);
        this.width = w;
        this.height = h;
        this.scene.setSize(w, h);
        this.hit.setSize(w, h);
        return this;
    }
    move(pos) {
        let { index = 0, viewport } = this, layers = viewport.layers, order;
        if (isNumber(pos)) {
            order = limit(Math.floor(pos), (layers.length - 1) * -1, layers.length - 1);
            pos = "order";
        }
        switch (pos) {
            case "up":
                if (index < layers.length - 1) {
                    layers[index] = layers[index + 1];
                    layers[index + 1] = this;
                }
                break;
            case "down":
                if (index > 0) {
                    layers[index] = layers[index - 1];
                    layers[index - 1] = this;
                }
                break;
            case "top":
                layers.splice(index, 1);
                layers.push(this);
                break;
            case "bottom":
                layers.splice(index, 1);
                layers.unshift(this);
                break;
            case "order":
                arrayMove(layers, this.index, order);
                break;
        }
        return this;
    }
    moveUp() {
        return this.move("up");
    }
    moveDown() {
        return this.move("down");
    }
    moveTop() {
        return this.move("top");
    }
    moveBottom() {
        return this.move("bottom");
    }
    remove() {
        return this.viewport.removeLayer(this);
    }
    destroy() {
        setSize(1, 1, this.scene);
        this.scene.clear();
        this.hit.clear();
    }
}
class Foundation {
    #id;
    #width = 0;
    #height = 0;
    #canvas;
    #offscreen = true;
    #context;
    #contextType;
    #layer;
    constructor(cfg = { offscreen: true }) {
        this.#id = CEL.idCnt++;
        this.#layer = cfg?.layer;
        this.#contextType = (contextTypes.includes(cfg?.contextType)) ? cfg.contextType : "2d";
        const canvas = document.createElement("canvas");
        canvas.className = "scene-canvas";
        canvas.style.display = "block";
        cfg.offscreen = (isBoolean(cfg?.offscreen)) ? cfg.offscreen : true;
        if (_OffscreenCanvas && cfg.offscreen) {
            this.#canvas = canvas.transferControlToOffscreen();
            this.#offscreen = true;
        }
        else {
            this.#canvas = canvas;
            this.#offscreen = false;
        }
        if (this.#contextType == "webgl2d")
            this.#context = this.getContext("2d");
        else
            this.#context = this.getContext(this.contextType);
        if (!!cfg?.width && !!cfg?.height) {
            this.setSize(cfg.width, cfg.height);
        }
    }
    get id() { return this.#id; }
    set width(width) { if (isNumber(width))
        this.#width = width; }
    get width() { return this.#width; }
    set height(height) { if (isNumber(height))
        this.#height = height; }
    get height() { return this.#height; }
    get canvas() { return this.#canvas; }
    get offscreen() { return this.#offscreen; }
    get contextType() { return this.#contextType; }
    get context() { return this.#context; }
    get layer() { return this.#layer; }
    getContext(type, cfg) {
        return this.canvas.getContext(type, cfg);
    }
    getDataURL(type, quality, canvas = this.canvas) {
        if (!this.offscreen) {
            const dataURL = canvas.toDataURL(type, quality);
            return dataURL;
        }
        else {
            try {
                canvas.convertToBlob()
                    .then(blob => {
                    blobToDataURL(blob)
                        .then(dataURL => {
                        return dataURL;
                    });
                });
            }
            catch (error) {
                throw error;
            }
        }
    }
    setSize(width, height) {
        return setSize(width, height, this);
    }
    clear() {
        return clear(this);
    }
}
class Scene extends Foundation {
    constructor(cfg = { offscreen: true }) {
        super(cfg);
    }
    toImage(type = "image/png", quality, cb) {
        let that = this, imageObj = new Image(), dataURL = this.getDataURL(type, quality);
        imageObj.onload = function () {
            imageObj.width = that.width;
            imageObj.height = that.height;
            cb(imageObj);
        };
        imageObj.src = dataURL;
    }
    export(cfg, type = "image/png", quality) {
        if (!this.offscreen) {
            const dataURL = this.getDataURL(type, quality);
            this.invokeImageDownload(dataURL, cfg.fileName);
        }
        else {
            this.getDataURL()
                .then(dataURL => {
                this.invokeImageDownload(dataURL, cfg.fileName);
            });
        }
    }
    exportHit(cfg, type = "image/png", quality) {
        const dataURL = this.getDataURL(type, quality, this.layer.hit.canvas);
        this.invokeImageDownload(dataURL, cfg.fileName);
    }
    invokeImageDownload(dataURL, fileName) {
        let anchor = document.createElement("a");
        anchor.setAttribute("href", dataURL);
        anchor.setAttribute("target", "_blank");
        anchor.setAttribute("download", fileName || "canvas.png");
        if (document.createEvent) {
            Object.assign(document.createElement("a"), {
                href: dataURL,
                target: "_blank",
                download: fileName,
            }).click();
        }
        else if (anchor.click) {
            anchor.click();
        }
    }
}
class Hit extends Foundation {
    constructor(cfg = {}) {
        super(cfg);
    }
    getContext(type) {
        return super.getContext(type, {
            preserveDrawingBuffer: true,
            antialias: false,
        });
    }
    getIntersection(x, y) {
        let ctx = this.context, data;
        x = Math.round(x - this.layer.x);
        y = Math.round(y - this.layer.y);
        if (x < 0 || y < 0 || x > this.width || y > this.height) {
            return -1;
        }
        if (this.contextType === "2d") {
            data = ctx.getImageData(x, y, 1, 1).data;
            if (data[3] < 255) {
                return -1;
            }
        }
        else {
            data = new Uint8Array(4);
            ctx.readPixels(x * CEL.pixelRatio, (this.height - y - 1) * CEL.pixelRatio, 1, 1, ctx.RGBA, ctx.UNSIGNED_BYTE, data);
            if (data[0] === 255 && data[1] === 255 && data[2] === 255) {
                return -1;
            }
        }
        return this.rgbToInt(data);
    }
    getIndexToRGB(index) {
        return `#${decimalToHex(index).padStart(6, '0')}`;
    }
    rgbToInt(rgb) {
        let r = rgb[0];
        let g = rgb[1];
        let b = rgb[2];
        return (r << 16) + (g << 8) + b;
    }
    intToRGB(number) {
        let r = (number & 0xff0000) >> 16;
        let g = (number & 0x00ff00) >> 8;
        let b = number & 0x0000ff;
        return [r, g, b];
    }
}
function clear(that) {
    let context = that.context;
    if (that.contextType === "2d") {
        context.save();
        context.setTransform(1, 0, 0, 1, 0, 0);
        context.clearRect(0, 0, that.canvas.width, that.canvas.height);
        context.restore();
    }
    else {
        context.clear(context.COLOR_BUFFER_BIT | context.DEPTH_BUFFER_BIT);
    }
    return that;
}
function windowDevicePixelRatio() {
    return (window && window.devicePixelRatio) || 1;
}
function sizeSanitize(width, height) {
    if (width < 0)
        width = 0;
    if (height < 0)
        height = 0;
    return { width, height };
}
function setSize(width, height, scene) {
    let { width: w, height: h } = sizeSanitize(width, height);
    const dpr = windowDevicePixelRatio();
    scene.width = w;
    scene.height = h;
    scene.canvas.width = Math.round(w * dpr);
    scene.canvas.height = Math.round(h * dpr);
    if (scene.contextType === "2d") {
        scene.context.scale(dpr, dpr);
    }
    if (!scene.offscreen) {
        scene.canvas.style.width = `${w}px`;
        scene.canvas.style.height = `${h}px`;
    }
    if (scene.contextType !== "2d" &&
        scene.contextType !== "bitmaprenderer") {
        scene.context.viewport(0, 0, scene.canvas.width, scene.canvas.height);
    }
    return scene;
}
const CEL = {
    idCnt: 0,
    viewports: [],
    get pixelRatio() { return windowDevicePixelRatio(); },
    Node: Node$1,
    Viewport,
    Layer,
    Scene,
    Hit,
};

class xAxis extends Axis {
    #xAxisTicks = 4;
    #xAxisGrads;
    #indexBased = true;
    constructor(parent) {
        super(parent);
    }
    get range() { return this.parent.range; }
    get width() { return this.core.MainPane.width; }
    get interval() { return this.range.interval; }
    get intervalStr() { return this.range.intervalStr; }
    get timeStart() { return this.range.timeStart; }
    get timeFinish() { return this.range.timeFinish; }
    get rangeDuration() { return this.range.rangeDuration; }
    get rangeLength() { return this.range.Length; }
    get indexStart() { return this.range.indexStart; }
    get indexEnd() { return this.range.indexEnd; }
    get timeMax() { return this.range.timeMax; }
    get timeMin() { return this.range.timeMin; }
    get candleW() { return (this.width / this.range.Length); }
    get candlesOnLayer() { return bRound(this.core.Chart.layerWidth / this.candleW); }
    get xAxisRatio() { return this.width / this.range.rangeDuration; }
    set xAxisTicks(t) { this.#xAxisTicks = isNumber(t) ? t : 0; }
    get xAxisTicks() { return this.#xAxisTicks; }
    get xAxisGrads() { return this.#xAxisGrads; }
    get scrollOffsetPx() { return this.core.scrollPos % this.candleW; }
    get bufferPx() { return this.core.bufferPx; }
    xPos(ts) {
        return bRound((this.range.rangeIndex(ts) * this.candleW) + (this.candleW * 0.5));
    }
    t2Index(ts) {
        return this.range.rangeIndex(ts);
    }
    t2Pixel(ts) {
        return this.xPos(ts);
    }
    pixel2T(x) {
        let c = this.pixel2Index(x);
        return this.range.value(c)[0];
    }
    pixel2Index(x) {
        x -= this.candleW / 2;
        let c = this.range.indexStart;
        let o = bRound(x / this.candleW);
        return c + o;
    }
    pixelOHLCV(x) {
        let c = this.pixel2Index(x);
        return this.range.value(c);
    }
    xPosSnap2CandlePos(x) {
        let r = x % this.candleW;
        let o = (r) ? this.candleW / 2 : 0;
        return bRound((x - r) + o);
    }
    xPos2Time(x) {
        return this.pixel2T(x);
    }
    xPos2Index(x) {
        return this.pixel2Index(x);
    }
    xPosOHLCV(x) {
        return this.pixelOHLCV(x);
    }
    initXAxisGrads() {
        this.#xAxisGrads = this.calcXAxisGrads();
    }
    doCalcXAxisGrads(range) {
        this.#xAxisGrads = this.calcXAxisGrads(range);
    }
    calcXAxisGrads(range = this.range.snapshot()) {
        const grads = {
            entries: {},
            values: [],
            major: [],
            minor: [],
        };
        const units = ms2TimeUnits(range.rangeDuration);
        grads.units = units;
        for (let u in units) {
            if (units[u] > 0) {
                grads.units = [u, u];
                grads.timeSpan = `${units[u]} ${u}`;
                break;
            }
        }
        const tf = range.interval;
        const { xStep, rank } = this.xStep(range);
        const tLimit = this.pixel2T(this.width) + xStep;
        let t1 = range.timeMin - (range.timeMin % xStep) - xStep;
        let start = t1;
        while (t1 < tLimit) {
            let y = time_start(t1, "years");
            let m = time_start(t1, "months");
            let d = time_start(t1, "days");
            if (!(y in grads.entries) && y >= start) {
                grads.entries[y] = [this.dateTimeValue(y, tf, rank), this.t2Pixel(y), y, "major"];
            }
            else if (!(m in grads.entries) && m >= start) {
                grads.entries[m] = [this.dateTimeValue(m, tf, rank), this.t2Pixel(m), m, "major"];
            }
            else if (!(d in grads.entries) && d >= start) {
                grads.entries[d] = [this.dateTimeValue(d, tf, rank), this.t2Pixel(d), d, "major"];
            }
            else {
                grads.entries[t1] = [this.dateTimeValue(t1, tf, rank), this.t2Pixel(t1), t1, "minor"];
            }
            t1 += xStep;
        }
        grads.values = Object.values(grads.entries);
        return grads;
    }
    xStep(range) {
        let minStep = XAXIS_STEP;
        let interval = this.#indexBased ? range.interval : 1;
        let xStep = TIMESCALES[0];
        let candleW = bRound(this.width / range.Length);
        let rank = TIMESCALESRANK[0];
        let i = TIMESCALES.indexOf(interval);
        while (i-- >= 0) {
            const gradPixels = candleW * (TIMESCALES[i] / interval);
            if (gradPixels >= minStep)
                break;
        }
        xStep = TIMESCALES[i];
        rank = TIMESCALESRANK[i];
        return { xStep, rank };
    }
    dateTimeValue(ts, tf, r) {
        let locale;
        if ((ts / DAY_MS$1) % 1 === 0) {
            const date = get_day(ts);
            if (date === 1) {
                let month = get_month(ts);
                if (month === 0)
                    return get_year(ts);
                else
                    return get_monthName(ts);
            }
            else {
                let day = get_dayName(ts, locale);
                return `${day} ${date}`;
            }
        }
        else {
            switch (r) {
                case "milliseconds": return MS(ts);
                case "seconds": return MS(ts);
                case "minutes": return HM(ts);
                case "hours": return HM(ts);
            }
        }
    }
}

class yAxis extends Axis {
    #parent;
    #source;
    #chart;
    #yAxisType = YAXIS_TYPE.percent;
    #mode = "automatic";
    #transform = {
        automatic: {
            get max() { return this.range?.valueMax; },
            get min() { return this.range?.valueMin; },
            get mid() { return this.range?.valueMin + (this.range?.valueDiff * 0.5); },
            get diff() { return this.range?.valueDiff; },
            get zoom() { return 1; },
            get offset() { return 0; },
            get secondaryMaxMin() { return this.range?.secondaryMaxMin; },
            range: null
        },
        manual: {
            max: 1,
            min: 0,
            mid: 0.5,
            diff: 1,
            zoom: 1,
            offset: 0,
            secondaryMaxMin: {}
        }
    };
    #yAxisPadding = 1;
    #yAxisStep = YAXIS_STEP;
    #yAxisTicks = 3;
    #yAxisGrads;
    #step;
    #range;
    constructor(parent, chart, yAxisType = YAXIS_TYPE.default, range) {
        super(parent);
        this.#chart = chart;
        this.#parent = parent;
        this.#source = parent.parent;
        this.yAxisType = YAXIS_TYPE.valid(yAxisType);
        if (yAxisType == YAXIS_TYPE.relative)
            range = this.core.range;
        else
            range = (range) ? range : this.core.range;
        this.setRange(range);
    }
    get chart() { return this.#chart; }
    get range() { return this.#range; }
    get height() { return this.chart.height; }
    get rangeH() { return this.#range.diff * this.yAxisPadding; }
    get yAxisRatio() { return this.getYAxisRatio(); }
    get yAxisPrecision() { return this.yAxisCalcPrecision; }
    set yAxisPadding(p) { if (isNumber(p) || p != 0)
        this.#yAxisPadding = p; }
    get yAxisPadding() { return this.#yAxisPadding; }
    set yAxisType(t) { this.#yAxisType = YAXIS_TYPE.valid(t); }
    get yAxisType() { return this.#yAxisType; }
    set yAxisStep(s) { this.#yAxisStep = isNumber(s) ? s : YAXIS_STEP; }
    get yAxisStep() { return this.#yAxisStep; }
    set yAxisTicks(t) { this.#yAxisTicks = isNumber(t) ? t : 0; }
    get yAxisTicks() { return this.#yAxisTicks; }
    get yAxisGrads() { return this.#yAxisGrads; }
    get yAxisDigits() { return this.parent.digitCnt; }
    get step() { return this.#step; }
    set mode(m) { this.setMode(m); }
    get mode() { return this.#mode; }
    set offset(o) { this.setOffset(o); }
    get offset() { return this.#range.offset; }
    set zoom(z) { this.setZoom(z); }
    get zoom() { return this.#range.zoom; }
    getYAxisRatio() {
        return this.height / this.#range.diff;
    }
    getMaxMinDiff() {
        let max = (this.#range.max > 0) ? this.#range.max : 1, min = (this.#range.min > 0) ? this.#range.min : 0, chart = this.parent.parent, id = chart.view[0]?.id, mm = this.range.secondaryMaxMin || {}, pane = this.#range;
        if (!chart.isPrimary &&
            id in mm) {
            max = mm[id]?.data?.max || 0;
            min = mm[id]?.data?.min || 0;
            pane = mm[id]?.data || [];
        }
        if (max == min) {
            if (max == 0) {
                max = 0.05;
                min = -0.05;
            }
            else {
                max = max + (max * 0.05);
                min = min + (min * 0.05);
            }
        }
        if (this.mode != "manual") {
            max *= this.#yAxisPadding || 1;
            min *= this.#yAxisPadding || 1;
        }
        let diff = max - min;
        return { max, min, diff, pane };
    }
    yAxisRangeBounds() {
        let max = this.range.valueMax;
        let min = this.range.valueMin;
        return { max, min };
    }
    yAxisLog() {
    }
    yAxisCntDigits(value) {
        return countDigits(value);
    }
    yAxisCalcPrecision() {
        let integerCnt = numDigits(this.#range.max);
        return this.yDigits - integerCnt;
    }
    yAxisCursor() {
    }
    yPos(y) {
        let val;
        switch (this.yAxisType) {
            case YAXIS_TYPE.relative:
                val = this.val2Pixel(y);
                break;
            case YAXIS_TYPE.percent:
                val = this.p100toPixel(y);
                break;
            case YAXIS_TYPE.log:
                val = this.$2Pixel(log10(y));
                break;
            default:
                val = this.$2Pixel(y);
                break;
        }
        return bRound(val);
    }
    val2Pixel(y) {
        let p, chart = this.parent.parent;
        if (!chart.isPrimary) {
            let h = this.height, { min, diff } = this.getMaxMinDiff();
            p = h - (h * ((y - min) / diff));
        }
        else {
            p = this.$2Pixel(y);
        }
        return p;
    }
    $2Pixel(y) {
        const height = y - this.#range.min;
        const yPos = this.height - (height * this.yAxisRatio);
        return yPos;
    }
    lastYData2Pixel(y) {
        let height = y - this.core.stream.lastPriceMin;
        let yPos = this.height - (height * this.yAxisRatio);
        return yPos;
    }
    p100toPixel(y) {
        return this.$2Pixel(y);
    }
    yPos2Price(y) {
        return this.pixel2$(y);
    }
    pixel2Val(y) {
        return this.pixel2$(y);
    }
    pixel2$(y) {
        let { min, diff } = this.getMaxMinDiff();
        let ratio = (this.height - y) / this.height;
        let adjust = diff * ratio;
        return min + adjust;
    }
    yAxisTransform() {
    }
    setMode(m) {
        if (!["automatic", "manual"].includes(m))
            return false;
        let t = this.#transform.manual;
        if (this.mode == "automatic" && m == "manual") {
            t.max = this.#range.valueMax;
            t.min = this.#range.valueMin;
            t.diff = t.max - t.min;
            t.zoom = 0;
            t.secondaryMaxMin = doStructuredClone(this.#range.secondaryMaxMin);
            this.#mode = m;
            this.core.emit("yaxis_setmode", { mode: m, axis: this });
        }
        else if (this.mode == "manual" && m == "automatic") {
            t.zoom = 0;
            this.#mode = m;
            this.core.emit("yaxis_setmode", { mode: m, axis: this });
        }
        return true;
    }
    transformPrimarySecondary() {
        let t = this.#transform.manual;
        if (this.#yAxisType != YAXIS_TYPE.percent &&
            !this.parent.parent.isPrimary) {
            let { pane } = this.getMaxMinDiff();
            t = pane;
        }
        return t;
    }
    setOffset(o) {
        if (!isNumber(o) || o == 0 || this.#mode !== "manual")
            return false;
        let t = this.transformPrimarySecondary();
        let max = this.pixel2Val(o * -1);
        let min = this.pixel2Val(this.height - o);
        let diff = max - min;
        t.min = min;
        t.max = max;
        t.mid = (diff) / 2;
        t.diff = diff;
        t.zoom = 0;
    }
    setZoom(z) {
        if (!isNumber(z) || this.#mode !== "manual")
            return false;
        let t = this.#transform.manual;
        let { max, min, diff, pane } = this.getMaxMinDiff();
        const diff10P = diff * 0.01;
        const change = z * diff10P;
        min -= change;
        max += change;
        if (max < min || min <= Infinity * -1 || max >= Infinity)
            return;
        pane.min -= change;
        pane.max += change;
        t.max = max;
        t.min = min;
        t.mid = (diff) / 2;
        t.diff = diff;
        t.zoom = change;
    }
    setRange(range) {
        this.#transform.automatic.range = range;
        this.#range = new Proxy(range, {
            get: (obj, prop) => {
                const m = this.#mode;
                const t = this.#transform[m];
                const p = t[prop];
                switch (prop) {
                    case "max": return p;
                    case "min": return p;
                    case "mid": return t.min + (t.max - t.min);
                    case "diff": return t.max - t.min;
                    case "zoom": return p;
                    case "offset": return p;
                    case "secondaryMaxMin": return p;
                    default: return obj[prop];
                }
            }
        });
    }
    calcGradations() {
        let mm, max, min, off;
        max = (this.#range.max > 0) ? this.#range.max : 1;
        min = (this.#range.min > 0) ? this.#range.min : 0;
        switch (this.yAxisType) {
            case YAXIS_TYPE.percent:
                max = (this.#range.max > -10) ? this.#range.max : 110;
                min = (this.#range.min > -10) ? this.#range.min : -10;
                break;
            case YAXIS_TYPE.relative:
                mm = this.getMaxMinDiff();
                max = mm.max;
                min = mm.min;
                break;
        }
        off = this.#range.offset;
        this.#yAxisGrads = this.gradations(max + off, min + off);
        return this.#yAxisGrads;
    }
    gradations(max, min, decimals = true) {
        let digits, scaleGrads = [], rangeH = max - min, niceNumber = this.niceNumber(rangeH), yStartRoundNumber = Math.ceil(min / niceNumber) * niceNumber, yEndRoundNumber = Math.floor(max / niceNumber) * niceNumber, pos = this.height, step = countDigits(niceNumber), nice;
        this.#step = step;
        for (var y = yStartRoundNumber; y <= yEndRoundNumber; y += niceNumber) {
            digits = countDigits(y);
            nice = limitPrecision(y, step.decimals) * 1;
            pos = this.yPos(nice);
            scaleGrads.push([nice, pos, digits]);
        }
        return scaleGrads;
    }
    niceNumber(rangeH = this.rangeH) {
        const yGridSize = (rangeH) / (this.height / (this.core.theme.yAxis.fontSize * YAxisFontSizeFactor));
        let niceNumber = Math.pow(10, Math.ceil(Math.log10(yGridSize)));
        if (yGridSize < 0.25 * niceNumber)
            niceNumber = 0.25 * niceNumber;
        else if (yGridSize < 0.5 * niceNumber)
            niceNumber = 0.5 * niceNumber;
        return niceNumber;
    }
}

function calcTextWidth(ctx, text) {
    return Math.round(ctx.measureText(text).width);
}
function createFont(fontSize = CanvasStyle.fontSize, fontWeight = CanvasStyle.fontWeight, fontFamily = CanvasStyle.fontFamily) {
    return `${fontWeight} ${fontSize}px ${fontFamily}`;
}
function getTextRectWidth(ctx, text, opts) {
    ctx.font = createFont(opts?.fontSize, opts?.fontWeight, opts?.fontFamily);
    const textWidth = calcTextWidth(ctx, text);
    const paddingLeft = opts?.paddingLeft || 0;
    const paddingRight = opts?.paddingRight || 0;
    const borderWidth = opts?.borderWidth || 0;
    return paddingLeft + paddingRight + textWidth + (borderWidth * 2);
}
function getTextRectHeight(opts) {
    const paddingTop = opts?.paddingTop || 0;
    const paddingBottom = opts?.paddingBottom || 0;
    const borderWidth = opts?.borderWidth || 0;
    const fontSize = opts?.fontSize || 0;
    return paddingTop + paddingBottom + fontSize + (borderWidth * 2);
}
function renderText(ctx, x, y, opts) {
    ctx.fillStyle = opts?.colour;
    ctx.font = createFont(opts?.fontSize, opts?.fontWeight, opts?.fontFamily);
    ctx.textAlign = opts?.textAlign || "start";
    ctx.textBaseline = opts?.textBaseLine || "alphabetic";
    ctx.direction = opts?.direction || "inherit";
    ctx.lineWidth = opts?.width;
    ctx.strokeStyle = opts?.border;
    if (opts?.stroke)
        ctx.strokeText(opts?.text, x, y, opts?.max);
    else
        ctx.fillText(opts?.text, x, y, opts?.max);
}
function renderTextBG(ctx, txt, x, y, opts) {
    ctx.save();
    ctx.font = createFont(opts?.fontSize, opts?.fontWeight, opts?.fontFamily);
    ctx.textBaseline = 'top';
    ctx.fillStyle = opts?.bakCol || CanvasStyle.bakCol;
    let width = opts?.width || getTextRectWidth(ctx, txt, opts);
    let height = opts?.height || getTextRectHeight(opts);
    ctx.fillRect(x, y, width, height);
    ctx.fillStyle = opts?.txtCol || CanvasStyle.txtCol;
    x = x + opts?.paddingLeft;
    y = y + opts?.paddingTop;
    ctx.fillText(`${txt}`, x, y);
    ctx.restore();
}

function renderRectStroke(ctx, x, y, w, h, opts) {
    ctx.lineWidth = opts?.width || CanvasStyle.borderWidth;
    ctx.strokeStyle = opts?.border || CanvasStyle.stroke;
    ctx.beginPath();
    ctx.rect(x, y, w, h);
    ctx.stroke();
}
function renderRectFill(ctx, x, y, w, h, opts) {
    ctx.fillStyle = opts?.fill || CanvasStyle.fill;
    ctx.fillRect(x, y, w, h);
}
function renderRect(ctx, x, y, w, h, opts) {
    if (isString(opts.fill))
        renderRectFill(ctx, x, y, w, h, opts);
    if (isNumber(opts.width) && opts.width > 0)
        renderRectStroke(ctx, x, y, w, h, opts);
}
function renderRectRoundStroke(ctx, x, y, w, h, r, opts) {
    ctx.lineWidth = opts?.width || CanvasStyle.borderWidth;
    ctx.strokeStyle = opts?.border || CanvasStyle.stroke;
    renderRectRoundPath(ctx, x, y, w, h, r);
    ctx.stroke();
}
function renderRectRoundFill(ctx, x, y, w, h, r, opts) {
    ctx.fillStyle = opts?.fill || CanvasStyle.fill;
    renderRectRoundPath(ctx, x, y, w, h, r);
    ctx.fill();
}
function renderRectRoundPath(ctx, x, y, w, h, r) {
    ctx.beginPath();
    ctx.moveTo(x + r, y);
    ctx.arcTo(x + w, y, x + w, y + h, r);
    ctx.arcTo(x + w, y + h, x, y + h, r);
    ctx.arcTo(x, y + h, x, y, r);
    ctx.arcTo(x, y, x + w, y, r);
    ctx.closePath();
}
function renderRectRound(ctx, x, y, w, h, r, opts) {
    if (isString(opts.fill))
        renderRectRoundFill(ctx, x, y, w, h, r, opts?.fill);
    if (isNumber(opts.width) && opts.width > 0)
        renderRectRoundStroke(ctx, x, y, w, h, r, opts?.border, opts?.width);
}

function linearGradient(ctx, grad = [], stops = []) {
    let [x1, y1, x2, y2] = grad;
    const grd = ctx.createLinearGradient(x1, y1, x2, y2);
    let i = 0;
    let step = 1 / (stops.length - 1);
    for (let stop of stops) {
        grd.addColorStop(i, stop);
        i += step;
    }
    ctx.fillStyle = grd;
}
function fillStroke(ctx, fill, stroke, width) {
    if (isString(fill)) {
        ctx.fillStyle = fill;
        ctx.fill();
    }
    if (isNumber(width) && width > 0) {
        ctx.lineWidth = width;
        ctx.strokeStyle = stroke || CanvasStyle.stroke;
        ctx.stroke();
    }
}

function renderPolygonRegular(ctx, x, y, radius, sides, rotateAngle, opts) {
    if (sides < 3)
        return;
    var a = (Math.PI * 2) / sides;
    ctx.beginPath();
    ctx.translate(x, y);
    ctx.rotate(rotateAngle * Math.PI / 180);
    ctx.moveTo(radius, 0);
    for (var i = 1; i < sides; i++) {
        ctx.lineTo(radius * Math.cos(a * i), radius * Math.sin(a * i));
    }
    ctx.closePath();
    fillStroke(ctx, opts?.fill, opts?.stroke, opts?.width);
}
function renderPolygonIrregular(ctx, points, opts) {
    if (points.length > 0) {
        ctx.beginPath();
        var point = points[0];
        ctx.moveTo(point.x, point.y);
        for (var i = 1; i < points.length; ++i) {
            point = points[i];
            ctx.lineTo(point.x, point.y);
        }
        ctx.closePath();
        fillStroke(ctx, opts?.fill, opts?.stroke, opts?.width);
    }
}
function renderTriangle(ctx, x, y, h, opts) {
    renderPolygonRegular(ctx, x, y, h, 3, opts?.rotate || 0, opts);
    fillStroke(ctx, opts?.fill, opts?.stroke, opts?.width);
}
function renderDiamond(ctx, x, y, w, h, opts) {
    ctx.beginPath();
    ctx.moveTo(x - w / 2, y);
    ctx.lineTo(x, y - h / 2);
    ctx.lineTo(x + w / 2, y);
    ctx.lineTo(x, y + h / 2);
    ctx.closePath();
    fillStroke(ctx, opts?.fill, opts?.stroke, opts?.width);
}

function renderPath(ctx, coords, style, strokeFill = () => { }) {
    ctx.save();
    const w = style.width || 1;
    ctx.lineWidth = w;
    if (w % 2) {
        ctx.translate(0.5, 0.5);
    }
    ctx.strokeStyle = style.stroke;
    let dash = style?.dash;
    if (isString(dash)) {
        dash = dash.split(",");
    }
    if (isArray(dash))
        ctx.setLineDash(dash);
    ctx.beginPath();
    let move = true;
    coords.forEach(coord => {
        if (coord && coord.x !== null) {
            if (move) {
                ctx.moveTo(coord.x, coord.y);
                move = false;
            }
            else {
                ctx.lineTo(coord.x, coord.y);
            }
        }
    });
    if (isFunction(strokeFill))
        strokeFill();
    ctx.restore();
}
function renderPathStroke(ctx, coords, style) {
    renderPath(ctx, coords, style, () => {
        ctx.stroke();
    });
}
function renderPathClosed(ctx, coords, style, opts) {
    renderPath(ctx, coords, style, () => {
        ctx.closePath();
    });
    fillStroke(ctx, opts?.fill, opts?.stroke, opts?.size);
}
function renderSpline(ctx, points, tension) {
    ctx.beginPath();
    ctx.moveTo(points[0].x, points[0].y);
    var t = (tension != null) ? tension : 1;
    for (var i = 0; i < points.length - 1; i++) {
        var p0 = (i > 0) ? points[i - 1] : points[0];
        var p1 = points[i];
        var p2 = points[i + 1];
        var p3 = (i != points.length - 2) ? points[i + 2] : p2;
        var cp1x = p1.x + (p2.x - p0.x) / 6 * t;
        var cp1y = p1.y + (p2.y - p0.y) / 6 * t;
        var cp2x = p2.x - (p3.x - p1.x) / 6 * t;
        var cp2y = p2.y - (p3.y - p1.y) / 6 * t;
        ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, p2.x, p2.y);
    }
    ctx.stroke();
}

function renderLineHorizontal(ctx, y, left, right, opts = {}) {
    const coords = [{ x: left, y: y }, { x: right, y: y }];
    renderPath(ctx, coords, opts, () => {
        ctx.stroke();
        ctx.closePath();
    });
}
function renderLineVertical(ctx, x, top, bottom, opts = {}) {
    const coords = [{ x: x, y: top }, { x: x, y: bottom }];
    renderPath(ctx, coords, opts, () => {
        ctx.stroke();
        ctx.closePath();
    });
}
function renderLine(ctx, coords, opts = {}) {
    renderPath(ctx, coords, opts, () => {
        ctx.stroke();
        ctx.closePath();
    });
}

function renderCircle(ctx, x, y, r, opts) {
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.closePath();
    fillStroke(ctx, opts?.fill, opts?.stroke, opts?.width);
}

function renderCheckerBoard(ctx, squareSize, rows, cols, odd, even) {
    for (let j = 0; j < rows; j++)
        for (let i = 0; i < cols; i++) {
            if ((i % 2 == 0 && j % 2 == 0) || (i % 2 != 0 && j % 2 != 0))
                ctx.fillStyle = odd;
            else
                ctx.fillStyle = even;
            ctx.fillRect(i * squareSize, j * squareSize, squareSize, squareSize);
        }
}

function chartBar(ctx) {
    renderRect(ctx, x, y, w, h, opts);
}

const colours2 = [
    "#263238", "#B71C1C", "#BF360C", "#FF6F00", "#827717", "#194D33", "#006064", "#0D47A1", "#311B92", "#880E4F",
    "#455A64", "#D32F2F", "#E64A19", "#FFA000", "#AFB42B", "#388E3C", "#0097A7", "#1976D2", "#512DA8", "#C2185B",
    "#607D8B", "#F44336", "#FF5722", "#FFC107", "#CDDC39", "#4CAF50", "#00BCD4", "#2196F3", "#673AB7", "#E91E63",
    "#90A4AE", "#E57373", "#FF8A65", "#FFD54F", "#DCE775", "#81C784", "#4DD0E1", "#64B5F6", "#9575CD", "#F06292",
    "#CFD8DC", "#FFCDD2", "#FFCCBC", "#FFECB3", "#F0F4C3", "#C8E6C9", "#B2EBF2", "#BBDEFB", "#D1C4E9", "#F8BBD0"
];

const RGBAHex = `#?([0-9a-f]{3}|[0-9a-f]{6}|[0-9a-f]{8})`;
const isHex = /^#?([0-9a-f]{3}|[0-9a-f]{6}|[0-9a-f]{8})$/i;
const isHSL = /^hsl\(\s*(\d+),\s*([0-9.]+)%,\s*([0-9.]+)%\s*\)$/;
const isHSLA = /^hsla?\s*\(\s*(\d+),\s*([0-9.]+)%,\s*([0-9.]+)%,\s*(0?\.\d+|0|1)?\s*\)$/i;
const isRGB = /^rgb[(](?:\s*0*(?:\d\d?(?:\.\d+)?(?:\s*%)?|\.\d+\s*%|100(?:\.0*)?\s*%|(?:1\d\d|2[0-4]\d|25[0-5])(?:\.\d+)?)\s*(?:,(?![)])|(?=[)]))){3}[)]$/i;
const isRGBA = /^rgba[(](?:\s*0*(?:\d\d?(?:\.\d+)?(?:\s*%)?|\.\d+\s*%|100(?:\.0*)?\s*%|(?:1\d\d|2[0-4]\d|25[0-5])(?:\.\d+)?)\s*,){3}\s*0*(?:\.\d+|0|1(?:\.0*)?)\s*[)]$/i;
class Colour {
    #value = {
        r: null,
        g: null,
        b: null,
        a: null,
        h: null,
        s: null,
        l: null,
        v: null,
        r16: null,
        g16: null,
        b16: null,
        a16: null,
        hex: null,
        hexa: null,
        hsl: null,
        hsla: null,
        rgb: null,
        rgba: null,
        isValid: false,
        error: ""
    };
    constructor(colour) {
        this.#validate(colour);
        if (isHex.test(colour))
            this.#valueIsHex(colour);
        if (isHSL.test(colour))
            this.#valueIsHSL(colour);
        if (isHSLA.test(colour))
            this.#valueIsHSLA(colour);
        if (isRGB.test(colour))
            this.#valueIsRGB(colour);
        if (isRGBA.test(colour))
            this.#valueIsRGBA(colour);
    }
    get value() { return this.#value; }
    get isValid() { return this.#value.isValid; }
    get hex() { return this.#value.hex; }
    get hexa() { return this.#value.hexa; }
    #validate(colour) {
        if (!isString(colour)) {
            this.#value.isValid = false;
            return;
        }
        if (isBrowser) {
            let el = document.getElementById('divValidColourTest');
            if (!el) {
                el = document.createElement('div');
                el.id = 'divValidColourTest';
            }
            el.style.backgroundColor = "";
            el.style.backgroundColor = colour;
            this.#value.isValid = (el.style.backgroundColor.length) ? true : false;
            el.remove();
        }
        else {
            this.#value.isValid = (isHex.test(colour) ||
                isHSL.test(colour) ||
                isHSLA.test(colour) ||
                isRGB.test(colour) ||
                isRGBA.test(colour)) ? true : false;
        }
    }
    setHex(hex) {
        let val = this.#value;
        ([
            val.r16,
            val.g16,
            val.b16,
            val.a16
        ] = hex);
        val.hex = `#${val.r16}${val.g16}${val.b16}`;
        val.hexa = `#${val.r16}${val.g16}${val.b16}${val.a16}`;
    }
    setRGBA(rgba) {
        let val = this.#value;
        ([
            val.r,
            val.g,
            val.b,
            val.a
        ] = rgba);
        val.rgb = `rgb(${rgba[0]},${rgba[1]},${rgba[2]})`;
        val.rgba = `rgb(${rgba[0]},${rgba[1]},${rgba[2]},${rgba[3]})`;
    }
    setHSLA(hsla) {
        let val = this.#value;
        ([
            val.h,
            val.s,
            val.l,
            val.a
        ] = hsla);
        val.hsl = `hsl(${hsla[0]},${hsla[1]}%,${hsla[2]}%)`;
        val.hsla = `hsl(${hsla[0]},${hsla[1]}%,${hsla[2]}%,${hsla[3]})`;
    }
    #valueIsHex(hex) {
        let l = hex.length, rgba;
        switch (l) {
            case 4:
                rgba = [`${hex[1]}${hex[1]}`, `${hex[2]}${hex[2]}`, `${hex[3]}${hex[3]}`, "ff"];
                break;
            case 7:
                rgba = [hex.substr(1, 2), hex.substr(3, 2), hex.substr(5, 2), "ff"];
                break;
            case 9:
                rgba = [hex.substr(1, 2), hex.substr(3, 2), hex.substr(5, 2), hex.substr(7, 2)];
                break;
        }
        this.setHex(rgba);
        this.#hexToRGB(rgba);
        this.#hexToHSL(rgba);
    }
    #valueIsHSL(hsl) {
        this.#value.hsl = hsl;
    }
    #valueIsHSLA(hsla) {
        this.#value.hsla = hsla;
    }
    #valueIsRGB(rgb) {
        this.#value.rgb = rgb;
        this.#RGBAToHex(rgb);
    }
    #valueIsRGBA(rgba) {
        this.#value.rgba = rgba;
        this.#RGBAToHex(rgba);
    }
    #RGBAToHex(rgba) {
        let x, isPercent, i = 0, y = [], z = [], m = rgba.replace(/\s/g, '').match(/^rgba?\((\d+),(\d+),(\d+),?([^,\s)]+)?/i), a = isString(m[4]) ? m[4] : `1`, mRGBA = [m[1], m[2], m[3], a];
        for (let v of mRGBA) {
            isPercent = v.indexOf("%") > -1;
            x = parseFloat(v);
            if (i < 3 && isPercent) {
                x = Math.round(255 * x / 100);
            }
            else if (i == 3) {
                if (!isPercent && x >= 0 && x <= 1) {
                    x = Math.round(255 * x);
                }
                else if (isPercent && x >= 0 && x <= 100) {
                    x = Math.round(255 * x / 100);
                }
                else {
                    x = "";
                }
            }
            y[i] = (x | 1 << 8).toString(16).slice(1);
            z[i++] = x;
        }
        this.setHex(y);
        this.setRGBA(z);
        this.#hexToHSL(this.#value.hexa);
    }
    #RGBToHSL(rgb) {
        let { r, g, b, a } = this.#getRGB(rgb);
        r = parseInt(r, 16) / 255;
        g = parseInt(g, 16) / 255;
        b = parseInt(b, 16) / 255;
        a = parseInt(a, 16) / 255;
        const l = Math.max(r, g, b);
        const s = l - Math.min(r, g, b);
        const h = s
            ? l === r
                ? (g - b) / s
                : l === g
                    ? 2 + (b - r) / s
                    : 4 + (r - g) / s
            : 0;
        let hsla = [
            (60 * h < 0 ? 60 * h + 360 : 60 * h).toString(),
            (100 * (s ? (l <= 0.5 ? s / (2 * l - s) : s / (2 - (2 * l - s))) : 0)).toString(),
            ((100 * (2 * l - s)) / 2).toString(),
            (a).toString()
        ];
        this.setHSLA(hsla);
        return this;
    }
    #HSLToRGB(h, s, l) {
        s /= 100;
        l /= 100;
        const k = n => (n + h / 30) % 12;
        const a = s * Math.min(l, 1 - l);
        const f = n => l - a * Math.max(-1, Math.min(k(n) - 3, Math.min(9 - k(n), 1)));
        return [255 * f(0), 255 * f(8), 255 * f(4)];
    }
    ;
    #HSLToHex(h, s, l) {
        l /= 100;
        const a = s * Math.min(l, 1 - l) / 100;
        const f = n => {
            const k = (n + h / 30) % 12;
            const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
            return Math.round(255 * color).toString(16).padStart(2, '0');
        };
        return `#${f(0)}${f(8)}${f(4)}`;
    }
    #hexToRGB(hex) {
        if (isString(hex))
            hex = /([a-f\d]{2})/ig.exec(hex);
        if (isArray(hex)) {
            var rgba = [
                parseInt(hex[0], 16),
                parseInt(hex[1], 16),
                parseInt(hex[2], 16),
                parseInt(hex[3], 16) / 255
            ];
            this.setRGBA(rgba);
        }
        else
            this.#value.error = "hexToRGB() invalid input";
    }
    #hexToHSL(hex) {
        if (isString(hex))
            hex = /([a-f\d]{2})/ig.exec(hex);
        if (isArray(hex)) {
            let r = parseInt(hex[0], 16);
            let g = parseInt(hex[1], 16);
            let b = parseInt(hex[2], 16);
            let a = parseInt(hex[3], 16);
            r /= 255, g /= 255, b /= 255, a /= 255;
            this.setHSLA([r, g, b, a]);
        }
        else
            this.#value.error = "hexToHSL() invalid input";
    }
    #getRGB(rgb) {
        let r, g, b, a;
        let v = this.#value;
        if (isString(rgb)) {
            let sep = rgb.indexOf(",") > -1 ? "," : " ";
            rgb = rgb.substr(4).split(")")[0].split(sep);
        }
        if (isArray(rgb)) {
            if (rgb.length < 3 || rgb.length > 4)
                return false;
            r = rgb[0];
            g = rgb[1];
            b = rgb[2];
            a = (isString(rgb[3])) ? rgb[3] : "";
        }
        else if (isObject(rgb)) {
            r = rgb.r;
            g = rgb.g;
            b = rgb.b;
            a = ("a" in rgb) ? rgb.a : "";
        }
        else if (v.r && v.g && v.b && v.a)
            return { r, g, b, a } = { ...v };
        else {
            this.#value.error = "getRGB() invalid input";
            return false;
        }
        r = `${r * 1}`;
        g = `${g * 1}`;
        b = `${b * 1}`;
        a = `${a * 1}`;
        return { r, g, b, a };
    }
}
class Palette {
    #matrix = [10, 5];
    #colours = colours2;
    #entries = [];
    constructor(matrix = [10, 5], colours = colours2) {
        this.#matrix = (this.validateMatrix(matrix)) ? matrix : this.#matrix;
        this.#colours = (this.validateColours(colours)) ? colours : this.#colours;
    }
    get matrix() { return this.#matrix; }
    get colours() { return this.#colours; }
    get entries() { return this.#entries; }
    validateMatrix(matrix) {
        return (isArray(matrix) &&
            matrix.length == 2 &&
            isInteger(matrix[0]) &&
            isInteger(matrix[1]));
    }
    validateColours(colours) {
        if (!isArray(colours) ||
            colours.length != this.#matrix[0] * this.#matrix[1])
            return false;
        const entries = [];
        for (let c of colours) {
            let k = new Colour(c);
            if (!k.isValid)
                return false;
            entries.push(k);
        }
        this.#entries = entries;
        return true;
    }
}

function renderImage(ctx, image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight) {
    ctx.drawImage(image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight);
}
function imageToCanvas(image, canvas) {
    let w = image.naturalWidth || image.width;
    let h = image.naturalHeight || image.height;
    if (canvas === undefined)
        canvas = createCanvas(w, h);
    canvas.ctx.drawImage(image, 0, 0);
    return canvas;
}
const channels = {
    red: "#FF0000FF",
    green: "#00FF00FF",
    blue: "#0000FFFF",
    alpa: "#000000FF"
};
function fillMask(colour, image) {
    const copy = imageToCanvas(image);
    const ctx = copy.ctx;
    let fill;
    if (Object.keys(channels).includes(colour))
        fill = channels[colour];
    else {
        let c = new Colour(colour);
        fill = (c.isValid) ? c.hexa : channels.alpa;
    }
    ctx.fillStyle = fill;
    ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
    ctx.globalCompositeOperation = "destination-in";
    ctx.drawImage(image, 0, 0);
    return copy;
}
function separateRGB(image) {
    return {
        red: fillMask("red", image),
        green: fillMask("green", image),
        blue: fillMask("blue", image),
        alpha: fillMask("alpha", image)
    };
}
function createCanvas(w, h) {
    const c = document.createElement("canvas");
    c.ctx = c.getContext("2d", { willReadFrequently: true });
    c.width = w || c.ctx.canvas.width;
    c.height = h || c.ctx.canvas.height;
    return c;
}
var canvas = {
    Colour,
    createCanvas,
    imageToCanvas,
    separateRGB,
    fillMask,
    fillStroke,
    linearGradient,
    calcTextWidth,
    createFont,
    getTextRectHeight,
    getTextRectWidth,
    renderImage,
    renderText,
    renderTextBG,
    renderPath,
    renderPathStroke,
    renderPathClosed,
    renderSpline,
    renderLine,
    renderLineHorizontal,
    renderLineVertical,
    renderCircle,
    renderRect,
    renderRectFill,
    renderRectStroke,
    renderRectRound,
    renderRectRoundFill,
    renderRectRoundStroke,
    renderPolygonRegular,
    renderPolygonIrregular,
    renderDiamond,
    renderTriangle,
    renderCheckerBoard,
    chartBar,
};

class Candle {
    constructor(scene, theme) {
        this.areaCoordinates = [];
        this.scene = scene;
        this.ctx = this.scene.context;
        this.width = this.scene.width;
        this.cfg = theme;
        this.dpr = CEL.pixelRatio;
    }
    alignToPixel(value) {
        return Math.round(value * this.dpr) / this.dpr;
    }
    draw(data) {
        const ctx = this.ctx;
        const cfg = this.cfg;
        const hilo = data.raw[4] >= data.raw[1];
        const bodyColour = hilo ? cfg.candle.UpBodyColour : cfg.candle.DnBodyColour;
        const wickColour = hilo ? cfg.candle.UpWickColour : cfg.candle.DnWickColour;
        switch (cfg.candle.Type) {
            case CandleType.CANDLE_SOLID:
                this.fill = true;
                break;
            case CandleType.CANDLE_HOLLOW:
            case CandleType.OHLC:
                this.fill = false;
                break;
            case CandleType.CANDLE_UP_HOLLOW:
                this.fill = !hilo;
                break;
            case CandleType.CANDLE_DOWN_HOLLOW:
                this.fill = hilo;
                break;
        }
        let w = candleW(data.w, this.dpr);
        const gap = Math.floor(data.w * 0.1);
        w = this.alignToPixel(w, gap);
        const x = this.alignToPixel(data.x);
        const bodyX = x - (w / 2);
        let h = Math.abs(data.o - data.c);
        let max_h = data.c === data.o ? 1 : 2;
        let bodyHeight = this.alignToPixel(h);
        ctx.save();
        ctx.strokeStyle = wickColour;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x, this.alignToPixel(data.h));
        if (cfg.candle.Type === CandleType.OHLC) {
            ctx.lineTo(x, this.alignToPixel(data.l));
        }
        else {
            if (hilo) {
                ctx.lineTo(x, this.alignToPixel(data.c));
                ctx.moveTo(x, this.alignToPixel(data.o));
            }
            else {
                ctx.lineTo(x, this.alignToPixel(data.o));
                ctx.moveTo(x, this.alignToPixel(data.c));
            }
            ctx.lineTo(x, this.alignToPixel(data.l));
        }
        ctx.stroke();
        if (w <= 3 * this.dpr) {
            ctx.fillStyle = wickColour;
            let s = hilo ? 1 : -1;
            ctx.fillRect(bodyX, this.alignToPixel(data.c), w, s * Math.max(bodyHeight, max_h));
        }
        else if (this.fill) {
            ctx.fillStyle = bodyColour;
            let s = hilo ? 1 : -1;
            ctx.fillRect(bodyX, this.alignToPixel(data.c), w, s * Math.max(bodyHeight, max_h));
        }
        else if (!this.fill && cfg.candle.Type !== CandleType.OHLC) {
            let s = hilo ? 1 : -1;
            ctx.strokeRect(bodyX, this.alignToPixel(data.c), w, s * Math.max(bodyHeight, max_h));
        }
        else if (cfg.candle.Type === CandleType.OHLC) {
            ctx.beginPath();
            ctx.moveTo(bodyX, this.alignToPixel(data.o));
            ctx.lineTo(x, this.alignToPixel(data.o));
            ctx.moveTo(x, this.alignToPixel(data.c));
            ctx.lineTo(x + w / 2, this.alignToPixel(data.c));
            ctx.stroke();
        }
        else {
            ctx.strokeStyle = wickColour;
            ctx.beginPath();
            ctx.moveTo(x, this.alignToPixel(Math.min(data.o, data.c)));
            ctx.lineTo(x, this.alignToPixel(Math.max(data.o, data.c)) +
                (data.o === data.c ? 1 : 0));
            ctx.stroke();
        }
        ctx.restore();
    }
    area(data) {
        this.areaCoordinates.push(data);
    }
    areaRender() {
        const coords = this.areaCoordinates;
        if (!isArray(coords) || coords.length == 0)
            return;
        let ctx = this.ctx;
        let cfg = this.cfg.candle;
        let fill;
        let w = Math.max(coords[0].w - 1, 1);
        w = candleW(w, this.dpr);
        this.alignToPixel(w * 0.5);
        this.alignToPixel(coords[0].x);
        let start = [this.alignToPixel(coords[0].x), this.alignToPixel(coords[0].h)];
        ctx.save();
        ctx.strokeStyle = cfg.AreaLineColour || cfg.UpBodyColour || cfg.DnBodyColour;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(start[0], start[1]);
        for (let i = 0; i < coords.length; i++) {
            ctx.lineTo(this.alignToPixel(coords[i].x), this.alignToPixel(coords[i].h));
        }
        if (cfg?.Type == "area") {
            fill = ctx.createLinearGradient(0, 0, 0, this.scene.height);
            if (isArray(cfg.AreaFillColour)) {
                for (let [index, value] of cfg.AreaFillColour.entries()) {
                    fill.addColorStop(index, value);
                }
            }
            else if (isString(cfg.AreaFillColour))
                fill = cfg.AreaFillColour;
            else
                fill = cfg.UpBodyColour || cfg.DnBodyColour;
            ctx.stroke();
            ctx.lineTo(this.alignToPixel(coords[coords.length - 1].x), this.scene.height);
            ctx.lineTo(start[0], this.scene.height);
            ctx.fillStyle = fill;
            ctx.closePath();
            ctx.fill();
        }
        else {
            ctx.stroke();
        }
        ctx.restore();
        coords.length = 0;
    }
}
function candleW(w, dpr = CEL.pixelRatio, gapPercentage = 0.1) {
    if (w < 3)
        w = 1;
    else if (w < 10)
        w = 3 * dpr;
    else if (w >= 10)
        w = Math.ceil(w * 0.8);
    const gap = Math.floor(w * gapPercentage);
    const scaledWidth = Math.round((w - gap));
    return scaledWidth;
}

class Histogram {
    constructor(scene, theme) {
        this.scene = scene;
        this.ctx = this.scene.context;
        this.width = this.scene.width;
        this.cfg = theme;
    }
    draw(data) {
        const ctx = this.ctx;
        const cfg = this.cfg;
        this.scene.height;
        const opts = {
            fill: "",
            stroke: "",
            width: 1
        };
        let h;
        for (let d of data) {
            let { w, x, y, zero: z } = d;
            w = candleW(w);
            x = x - (w / 2);
            if (y < z) {
                h = z - y;
                opts.fill = cfg.upfill;
                opts.stroke = cfg.upstroke;
                opts.width = cfg.upwidth;
            }
            else {
                h = y - z;
                y = z;
                opts.fill = cfg.dnfill;
                opts.stroke = cfg.dnstroke;
                opts.width = cfg.dnwidth;
            }
            renderRect(ctx, x, y, w, h, opts);
        }
    }
}

function renderHighLowRange(ctx, high, low, w, h, style) {
    let d = high - low;
    renderRectFill(ctx, 0, low, w, d, style);
    renderLineHorizontal(ctx, high, 0, w, style);
    renderLineHorizontal(ctx, low, 0, w, style);
}

class Overlay {
    static { this.isOverlay = true; }
    #parent;
    #core;
    #config = {};
    #state;
    #range;
    #theme;
    #xAxis;
    #yAxis;
    #target;
    #scene;
    #hit;
    #params;
    #data = [];
    #histogram;
    #mustUpdate = {
        valueMax: null,
        valueMin: null,
        indexStart: null,
        Length: null,
        rowsW: null,
        rowsH: null,
        refresh: true,
        resize: true
    };
    constructor(target, xAxis = false, yAxis = false, theme, parent, params = {}) {
        if (!target || !parent) {
            throw new Error('Target and parent are required parameters');
        }
        if (!parent.core) {
            throw new Error('Parent must have a core property');
        }
        this.#core = parent.core;
        this.#parent = parent;
        this.#config = parent.core.config;
        this.#state = parent.core.state;
        this.#range = parent.core.range;
        this.#target = target;
        this.#scene = target.scene;
        this.#hit = target.hit;
        this.#xAxis = xAxis;
        this.#yAxis = yAxis;
        this.#params = params;
        this.on("global_resize", this.onResize, this);
    }
    destroy() {
        this.#core.hub.expunge(this);
        if ("overlay" in this.#params &&
            "data" in this.#params.overlay) {
            this.#params.overlay.data.length = 0;
            delete this.#params.overlay.data;
        }
    }
    get core() { return this.#core; }
    get parent() { return this.#parent; }
    get target() { return this.#target; }
    get config() { return this.#config; }
    get params() { return this.#params; }
    get range() { return this.#range; }
    get state() { return this.#state; }
    get scene() { return this.#scene; }
    get hit() { return this.#hit; }
    get theme() { return this.#core.theme; }
    get chart() { return this.#parent.parent.parent; }
    get chartData() { return this.#config.state.allData.data; }
    get xAxis() { return this.getXAxis(); }
    get yAxis() { return this.getYAxis(); }
    get overlay() { return this.#params.overlay; }
    get overlayData() { return this.#params.overlay?.data || []; }
    get data() { return this.#params.overlay?.data || []; }
    get stateMachine() { return this.#core.stateMachine; }
    get context() { return this.getContextType(); }
    set position(p) { this.#target.setPosition(p[0], p[1]); }
    get isOverlay() { return Overlay.isOverlay; }
    on(topic, handler, context = this) {
        this.#core.on(topic, handler, context);
    }
    off(topic, handler, context = this) {
        this.#core.off(topic, handler, context);
    }
    expunge(context = this) {
        this.#core.expunge(context);
    }
    emit(topic, data) {
        this.core.emit(topic, data);
    }
    onResize() {
        this.#mustUpdate.resize = true;
    }
    setSize(w, h) {
        this.#target.setSize(w, h);
        this.#mustUpdate.refresh = true;
    }
    setRefresh() {
        this.#mustUpdate.refresh = true;
    }
    getXAxis() {
        if (this.#xAxis instanceof xAxis)
            return this.#xAxis;
        else if (this.core.Chart.time?.xAxis instanceof xAxis)
            return this.core.Chart.time.xAxis;
        else if (this.#parent?.time?.xAxis instanceof xAxis)
            return this.#parent.time.xAxis;
        else
            return false;
    }
    getYAxis() {
        if (this.#yAxis instanceof yAxis)
            return this.#yAxis;
        else if (this.chart?.yAxis instanceof yAxis)
            return this.chart.yAxis;
        else if (this.#parent?.scale?.yAxis instanceof yAxis)
            return this.#parent.scale.yAxis;
        else
            return false;
    }
    getContextType() {
        if (!this.#xAxis && !this.#yAxis)
            return "chart";
        else if (this.getXAxis() instanceof xAxis)
            return "timeline";
        else if (this.getYAxis() instanceof yAxis)
            return "scale";
        else
            return false;
    }
    mustUpdate() {
        const r = this.#core.range;
        const l = this.#mustUpdate;
        this.#core.MainPane.elRows;
        return (l.valueMax !== r.valueMax ||
            l.valueMin !== r.valueMin ||
            l.indexStart !== r.indexStart ||
            l.Length !== r.Length ||
            l.refresh ||
            l.resize) ? this.#mustUpdate : false;
    }
    updated() {
        const r = this.#core.range;
        const l = this.#mustUpdate;
        const d = this.#core.MainPane.elRows;
        l.valueMax = r.valueMax;
        l.valueMin = r.valueMin;
        l.indexStart = r.indexStart;
        l.Length = r.Length;
        l.rowsW = d.width;
        l.rowsH = d.height;
        l.refresh = false;
        l.resize = false;
    }
    plot(plots, type, params) {
        const ctx = this.scene.context;
        const p = plots;
        const plotTypeFn = this.plotTypeFn(canvas, type, ctx, p, params);
        if (!plotTypeFn[type]) {
            this.core.warn(`Overlay: Unknown plot type: ${type}`);
            return;
        }
        try {
            ctx.save();
            plotTypeFn[type]();
        }
        catch (error) {
            this.core.error(`Overlay: Error plotting ${type}:`, error);
        }
        finally {
            ctx.restore();
        }
    }
    plotTypeFn(canvas, type, ctx, p, params) {
        return {
            createCanvas: () => { canvas[type](p[0], p[1]); },
            fillStroke: () => { canvas[type](ctx, p[0], p[1], p[2]); },
            renderLine: () => { canvas[type](ctx, p, params); },
            renderLineHorizontal: () => { canvas[type](ctx, p[0], p[1], p[2], params); },
            renderLineVertical: () => { canvas[type](ctx, p[0], p[1], p[2], params); },
            renderPath: () => { canvas[type](ctx, p, params.style, params); },
            renderPathStroke: () => { canvas[type](ctx, p, params.style); },
            renderPathClosed: () => { canvas[type](ctx, p, params.style, params); },
            renderSpline: () => { canvas[type](ctx, p, params); },
            renderRect: () => { canvas[type](ctx, p[0], p[1], p[2], p[3], params); },
            renderRectFill: () => { canvas[type](ctx, p[0], p[1], p[2], p[3], params); },
            renderRectStroke: () => { canvas[type](ctx, p[0], p[1], p[2], p[3], params); },
            renderRectRound: () => { canvas[type](ctx, p[0], p[1], p[2], p[3], p[4], params); },
            renderRectRoundFill: () => { canvas[type](ctx, p[0], p[1], p[2], p[3], p[4], params); },
            renderRectRoundStroke: () => { canvas[type](ctx, p[0], p[1], p[2], p[3], p[4], params); },
            renderPolygonRegular: () => { canvas[type](ctx, p[0], p[1], p[2], p[3], p[4], params); },
            renderPolygonIrregular: () => { canvas[type](ctx, p, params); },
            renderTriangle: () => { canvas[type](ctx, p[0], p[1], p[2], params); },
            renderDiamond: () => { canvas[type](ctx, p[0], p[1], p[2], p[3], params); },
            renderCircle: () => { canvas[type](ctx, p[0], p[1], p[2], params); },
            renderImage: () => { canvas[type](ctx, params.src, p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]); },
            renderText: () => { canvas[type](ctx, p[0], p[1], params); },
            renderTextBG: () => { canvas[type](ctx, p[0], p[1], p[2], params); },
            histogram: () => { this.histogram(p, params); },
            highLowRange: () => { this.highLowRange(ctx, params); },
        };
    }
    clear() {
        this.scene.clear();
    }
    histogram(p, params) {
        if (!(this.#histogram instanceof Histogram))
            this.#histogram = new Histogram(this.scene, params);
        this.#histogram.draw(p);
    }
    highLowRange(ctx, p) {
        let { high, low } = p;
        let y1 = this.yAxis.yPos(high);
        let y2 = this.yAxis.yPos(low);
        let { width, height } = this.scene;
        renderHighLowRange(ctx, y1, y2, width, height, p);
    }
}

class WinState {
    static { this.opened = new WinState("opened"); }
    static { this.closed = new WinState("closed"); }
    constructor(name) {
        this.name = name;
    }
}
class Window {
    #id;
    #widgets;
    #core;
    #config;
    #state = WinState.closed;
    #parent;
    #elWidgetsG;
    #elWindows;
    #elWindow;
    #elDragBar;
    #elTitle;
    #elCloseIcon;
    #elContent;
    #elColourPicker;
    #pos = {};
    #dims;
    #cursorPos;
    #controller;
    #dragBar;
    #dragging = false;
    #windowEvents = {};
    #title = "";
    #content = "";
    #contentFields = {};
    #params = {};
    static { this.windowList = {}; }
    static { this.windowCnt = 0; }
    static { this.class = CLASS_WINDOWS; }
    static { this.Name = "Windows"; }
    static { this.type = "window"; }
    static { this.currentActive = null; }
    static { this.stylesInstalled = false; }
    static { this.defaultStyles = `
  /** default Window widget styles */

  .tradeXwindow {
    border: 1px solid ${WindowStyle.COLOUR_BORDER};
    border-radius: 5px;
    box-shadow: ${WindowStyle.SHADOW};
    background: ${WindowStyle.COLOUR_BG};
    color: ${WindowStyle.COLOUR_TXT};
  }

  .tradeXwindow .dragBar {
    cursor: grab;
  }

  .tradeXwindow .dragBar:hover {
    background: #222;
  }

  .tradeXwindow .dragBar .title {
    ${WindowStyle.TITLE}
  }

  .tradeXwindow .content {
    ${WindowStyle.CONTENT}
  }
 
  `; }
    static create(widgets, config) {
        config.id = config?.id || uid("window");
        config.id = `${config.id}_${++Window.windowCnt}`;
        config.type = config?.type || Window.type;
        config.class = config?.class || "window";
        Window.windowList[config.id] = new Window(widgets, config);
        return Window.windowList[config.id];
    }
    static destroy(id) {
        if (!(id in Window.windowList))
            return;
        Window.windowList[id].destroy();
        delete Window.windowList[id];
    }
    static defaultNode() {
        const windowStyle = ``;
        const node = `
      <div slot="widget" class="${CLASS_WINDOWS}" style="${windowStyle}"></div>
    `;
        return node;
    }
    constructor(widgets, config) {
        this.#widgets = widgets;
        this.#core = config.core || config.parent.core;
        this.#config = config;
        this.#id = config.id;
        this.#parent = config.parent;
        this.#elWindows = widgets.elements[config.type];
        this.#elWidgetsG = this.#core.elWidgetsG;
        const rootElement = widgets.elements[config.type];
        this.mount(rootElement);
    }
    destroy() {
        this.#core.hub.expunge();
        this.el.remove();
    }
    get id() { return this.#id; }
    get pos() { return this.dimensions; }
    get core() { return this.#core; }
    get parent() { return this.#parent; }
    get config() { return this.#config; }
    set config(c) { this.#config = c; }
    get theme() { return this.#core.theme; }
    get state() { return this.#state; }
    get dimensions() { return elementDimPos(this.#elWindow); }
    set dimensions(d) { this.setDimensions(d); }
    get type() { return Window.type; }
    get el() { return this.#elWindow; }
    get elDragBar() { return this.#elDragBar; }
    get elTitle() { return this.#elTitle; }
    get elCloseIcon() { return this.#elCloseIcon; }
    get elContent() { return this.#elContent; }
    get elColourPicker() { return this.#elColourPicker; }
    get title() { return this.#title; }
    set title(t) { this.setTitle(t); }
    get content() { return this.#content; }
    set content(c) { this.setContent(c); }
    get contentFields() { return this.#contentFields; }
    set params(p) { if (isObject(p))
        this.#params = { ...this.#params, ...p }; }
    get params() { return this.#params; }
    setTitle(t) {
        if (!isString(t))
            return false;
        this.#config.title = t;
        this.#elTitle.innerHTML = t;
        return this.#elTitle;
    }
    setContent(c, m = {}) {
        if (!isString(c) ||
            !isObject(m))
            return false;
        this.#config.content = c;
        this.#elContent.innerHTML = c;
        for (let mod in m) {
            if (!isFunction(m[mod]))
                continue;
            m[mod](this.#elContent);
        }
        this.#contentFields = this.allContentFields();
        return this.#elContent;
    }
    start() {
        this.eventsListen();
        if (this.#config?.openNow !== true)
            this.setClose();
    }
    eventsListen() {
        this.on(`window_close_${this.parent.id}`, this.onCloseWindow, this);
        this.on("global_resize", this.onGlobalResize, this);
    }
    on(topic, handler, context = this) {
        this.#core.on(topic, handler, context);
    }
    off(topic, handler, context = this) {
        this.#core.off(topic, handler, context);
    }
    emit(topic, data) {
        this.#core.emit(topic, data);
    }
    onGlobalResize(e) {
        const dims = this.dimensions;
        const data = {
            position: { x: dims.left, y: dims.top },
            dimensions: { w: dims.w, h: dims.h }
        };
        if (dims.w > e.width)
            data.position.x = e.width;
        if (dims.h > e.height)
            data.position.y = e.height;
        dims.left + data.dimensions.w;
        dims.bottom + data.dimensions.h;
        if (dims.x < 0)
            data.position.x = 0;
        else if (dims.x + data.dimensions.w > e.width)
            data.position.x -= e.width;
        this.setProperties(data);
    }
    onOutsideClickListener(e) {
        if (!this.#elWindow.contains(e.target)
            && isVisible(this.#elWindow)
            && !this.#dragging) {
            let data = {
                target: e.currentTarget.id,
                window: this.#id,
            };
            this.emit("window_close", data);
            this.emit(`window_close_${this.parent.id}`, data);
            document.removeEventListener('click', this.#windowEvents.click);
            delete this.#windowEvents.click;
        }
    }
    onCloseWindow(e) {
        if (e.window === this.#id)
            this.close();
    }
    onWindow(e) {
        e.stopPropagation();
    }
    onDragBar(e) {
        this.#dragging = true;
        let x = this.#elWindow.offsetLeft + e.movement.x;
        let y = this.#elWindow.offsetTop + e.movement.y;
        this.position({ x, y });
    }
    onDragBarEnd(e) {
        setTimeout(() => {
            this.#dragging = false;
        }, 250);
    }
    mount(el) {
        if (el.lastElementChild == null)
            el.innerHTML = this.windowNode();
        else
            el.lastElementChild.insertAdjacentHTML("afterend", this.windowNode());
        this.#elWindow = this.#elWindows.querySelector(`#${this.#config.id}`);
        this.#elDragBar = this.#elWindow.querySelector(".dragBar");
        this.#elTitle = this.#elWindow.querySelector(".title");
        this.#elCloseIcon = this.#elWindow.querySelector(".closeIcon");
        this.#elContent = this.#elWindow.querySelector(".content");
        this.#contentFields = this.allContentFields();
        this.#elWindow.addEventListener("click", this.onWindow.bind(this));
        if (isHTMLElement(this.#elDragBar)) {
            this.#dragBar = new Input(this.#elDragBar, { disableContextMenu: false });
            this.#dragBar.on("pointerdrag", this.onDragBar.bind(this));
            this.#dragBar.on("pointerdragend", this.onDragBarEnd.bind(this));
        }
        const d = this.dimensions;
        const w = this.#config?.w || d.w;
        const h = this.#config?.h || d.h;
        this.setDimensions({ w, h });
        this.position();
    }
    windowNode() {
        const window = this.#config;
        let windowStyle = `position: absolute; z-index: 100; display: block;`;
        let dragBar = (window.dragBar) ? this.dragBar() : '';
        let title = (!window.dragBar && window.title) ? this.titleNode() : '';
        let content = this.contentNode();
        let closeIcon = this.closeIcon();
        let node = `
      <!-- ${this.constructor.type} ${this.parent.id} -->
      <div id="${window.id}" class="${CLASS_WINDOW} ${window.class}" style="${windowStyle}">
          ${dragBar}
          ${title}
          ${closeIcon}
          ${content}
        </div>
      </div>
    `;
        return node;
    }
    contentNode() {
        const window = this.#config;
        let contentStyle = ``;
        let content = (window?.content) ? window.content : '';
        let node = `
      <div class="content" style="${contentStyle}">
        ${content}
      </div>
    `;
        return node;
    }
    dragBar() {
        const window = this.#config;
        const cPointer = "cursor: grab;";
        const over = `onmouseover="this.style.background ='#222'"`;
        const out = `onmouseout="this.style.background ='none'"`;
        let dragBarStyle = `${cPointer} `;
        let node = ``;
        if (window.dragBar)
            node +=
                `
    <div class="dragBar" style="${dragBarStyle}" ${over} ${out}>
        ${this.titleNode()}
      </div>
    `;
        return node;
    }
    titleNode() {
        const cfg = this.config;
        const title = (isString(cfg?.title)) ? cfg.title : "";
        let node = `
        <div class="title">${title}</div>
    `;
        return node;
    }
    closeIcon() {
        const cPointer = "cursor: pointer;";
        const over = `onmouseover="this.style.background ='#222'"`;
        const out = `onmouseout="this.style.background ='none'"`;
        let closeIconStyle = `${cPointer} `;
        this.#config?.styles?.closeIcon;
        let node = ``;
        if (window.closeIcon)
            node +=
                `
      <div class="closeIcon" style="${closeIconStyle}" ${over} ${out}>
        <span>X</span>
      </div>
    `;
        return node;
    }
    allContentFields() {
        const fields = {};
        const c = this.#elContent;
        fields.input = c.querySelectorAll("input");
        fields.select = c.querySelectorAll("select");
        fields.textarea = c.querySelectorAll("textarea");
        fields.button = c.querySelectorAll("button");
        return fields;
    }
    position(p) {
        let rebound = 0.1;
        let wPos = this.dimensions;
        let iPos = this.#core.dimensions;
        Math.round(iPos.left - wPos.left);
        Math.round(iPos.bottom - wPos.top);
        let px = (this.#pos?.iPos?.width !== iPos.width || !!this.#pos.x100) ?
            wPos.width * this.#pos.x100 :
            Math.round((iPos.width - wPos.width) / 2);
        let py = (this.#pos?.iPos?.height !== iPos.height || !!this.#pos.y100) ?
            wPos.height * this.#pos.y100 :
            Math.round((iPos.height + wPos.height) / -2);
        let pz = getStyle(this.#elWindow, "z-index");
        if (isObject(p)) {
            let { x, y, z } = { ...p };
            if (isNumber(x))
                px = x;
            if (isNumber(y))
                py = y;
            if (isNumber(z))
                pz = z;
            this.#pos = { x: x, y: y, z: pz };
        }
        this.#elWindow.style["z-index"] = `${pz}`;
        const width = this.#elWindow.clientWidth;
        if (px + (width * rebound) > this.#elWidgetsG.offsetWidth) {
            px = this.#elWidgetsG.offsetWidth - (width * rebound);
        }
        else if (px < (width - (width * rebound)) * -1) {
            px = (width - (width * rebound)) * -1;
        }
        const height = this.#elWindow.clientHeight;
        if (py < iPos.height * -1) {
            py = iPos.height * -1;
        }
        else if (py > height * rebound * -1) {
            py = height * rebound * -1;
        }
        px = Math.floor(px);
        py = Math.floor(py);
        this.#elWindow.style.left = `${px}px`;
        this.#elWindow.style.top = `${py}px`;
        const x100 = px / wPos.width;
        const y100 = py / wPos.height;
        this.#pos = {
            px, py,
            x100, y100,
            iPos
        };
    }
    setDimensions(d) {
        if (!isObject(d))
            return false;
        if (isNumber(d?.w))
            this.#elWindow.style.width = `${d.w}px`;
        if (isNumber(d?.h))
            this.#elWindow.style.height = `${d.h}px`;
    }
    setProperties(data) {
        if (!isObject(data))
            return false;
        if (isString(data?.title)) {
            this.#elTitle.innerHTML = data.title;
        }
        if (isString(data?.content)) {
            this.#elContent.innerHTML = data.content;
        }
        this.setDimensions({ ...data?.dimensions });
        this.position({ ...data?.position });
        if (isObject(data?.styles)) {
            const styleIt = (k, s) => {
                if (!isObject(s))
                    return false;
                const el = "el" + k.charAt(0).toUpperCase() + k.slice(1);
                if (isObject(this[el])) {
                    for (let p in s) {
                        this[el].style.p = s[p];
                    }
                }
            };
            for (let k of Object.keys(data.styles)) {
                styleIt(k, data.styles[k]);
            }
        }
        return data;
    }
    setOpen() {
        Window.currentActive = this;
        this.#state = WinState.opened;
        this.#elWindow.style.display = "block";
        this.#elWindow.style.zindex = "10";
        this.#elWindow.classList.add('active');
    }
    setClose() {
        Window.currentActive = null;
        this.#state = WinState.closed;
        this.#elWindow.style.display = "none";
        this.#elWindow.classList.remove('active');
        document.removeEventListener('click', this.#windowEvents.click);
    }
    remove() {
        return Window.destroy(this.id);
    }
    open(data = {}) {
        if (Window.currentActive === this &&
            this.state === WinState.opened)
            return true;
        if (isObject(data.params))
            this.params = data.params;
        this.setOpen();
        this.setProperties(data);
        this.emit("window_opened", this.id);
        this.emit(`window_opened_${this.parent.id}`, this.id);
        setTimeout(() => {
            this.#windowEvents.click = this.onOutsideClickListener.bind(this);
            document.addEventListener('click', this.#windowEvents.click);
            if (!!this.#elColourPicker) ;
        }, 1000);
        return true;
    }
    close() {
        if (this.#state !== WinState.closed) {
            this.setClose();
            this.emit("window_closed", this.id);
            this.emit(`window_closed_${this.parent.id}`, this.id);
        }
        return true;
    }
}

const ACCBANDS = {
    name: "ACCBANDS",
    camelCaseName: "accBands",
    group: "Overlap Studies",
    description: "Acceleration Bands",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 20,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "upperBand",
            type: "number",
            plot: "limit_upper"
        }, {
            name: "middleBand",
            type: "number",
            plot: "line"
        }, {
            name: "lowerBand",
            type: "number",
            plot: "limit_lower"
        }]
};
const ACOS = {
    name: "ACOS",
    camelCaseName: "acos",
    group: "Math Transform",
    description: "Vector Trigonometric ACos",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const AD = {
    name: "AD",
    camelCaseName: "ad",
    group: "Volume Indicators",
    description: "Chaikin A/D Line",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }, {
            name: "volume",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const ADD = {
    name: "ADD",
    camelCaseName: "add",
    group: "Math Operators",
    description: "Vector Arithmetic Add",
    inputs: [{
            name: "inReal0",
            type: "number"
        }, {
            name: "inReal1",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const ADOSC = {
    name: "ADOSC",
    camelCaseName: "adOsc",
    group: "Volume Indicators",
    description: "Chaikin A/D Oscillator",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }, {
            name: "volume",
            type: "number"
        }],
    options: [{
            name: "fastPeriod",
            displayName: "Fast Period",
            defaultValue: 3,
            hint: "Number of period for the fast MA",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }, {
            name: "slowPeriod",
            displayName: "Slow Period",
            defaultValue: 10,
            hint: "Number of period for the slow MA",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const ADX$1 = {
    name: "ADX",
    camelCaseName: "adx",
    group: "Momentum Indicators",
    description: "Average Directional Movement Index",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const ADXR = {
    name: "ADXR",
    camelCaseName: "adxr",
    group: "Momentum Indicators",
    description: "Average Directional Movement Index Rating",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const APO = {
    name: "APO",
    camelCaseName: "apo",
    group: "Momentum Indicators",
    description: "Absolute Price Oscillator",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "fastPeriod",
            displayName: "Fast Period",
            defaultValue: 12,
            hint: "Number of period for the fast MA",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }, {
            name: "slowPeriod",
            displayName: "Slow Period",
            defaultValue: 26,
            hint: "Number of period for the slow MA",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }, {
            name: "MAType",
            displayName: "MA Type",
            defaultValue: 0,
            hint: "Type of Moving Average",
            type: "MAType"
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const AROON$1 = {
    name: "AROON",
    camelCaseName: "aroon",
    group: "Momentum Indicators",
    description: "Aroon",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "aroonDown",
            type: "number",
            plot: "line_dash"
        }, {
            name: "aroonUp",
            type: "number",
            plot: "line"
        }]
};
const AROONOSC = {
    name: "AROONOSC",
    camelCaseName: "aroonOsc",
    group: "Momentum Indicators",
    description: "Aroon Oscillator",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const ASIN = {
    name: "ASIN",
    camelCaseName: "asin",
    group: "Math Transform",
    description: "Vector Trigonometric ASin",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const ATAN = {
    name: "ATAN",
    camelCaseName: "atan",
    group: "Math Transform",
    description: "Vector Trigonometric ATan",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const ATR$1 = {
    name: "ATR",
    camelCaseName: "atr",
    group: "Volatility Indicators",
    description: "Average True Range",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const AVGDEV = {
    name: "AVGDEV",
    camelCaseName: "avgDev",
    group: "Price Transform",
    description: "Average Deviation",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const AVGPRICE = {
    name: "AVGPRICE",
    camelCaseName: "avgPrice",
    group: "Price Transform",
    description: "Average Price",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const BBANDS = {
    name: "BBANDS",
    camelCaseName: "bbands",
    group: "Overlap Studies",
    description: "Bollinger Bands",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 5,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }, {
            name: "nbDevUp",
            displayName: "Deviations up",
            defaultValue: 2,
            hint: "Deviation multiplier for upper band",
            type: "number",
            range: {
                min: -3e+37,
                max: 3e+37
            }
        }, {
            name: "nbDevDn",
            displayName: "Deviations down",
            defaultValue: 2,
            hint: "Deviation multiplier for lower band",
            type: "number",
            range: {
                min: -3e+37,
                max: 3e+37
            }
        }, {
            name: "MAType",
            displayName: "MA Type",
            defaultValue: 0,
            hint: "Type of Moving Average",
            type: "MAType"
        }],
    outputs: [{
            name: "upperBand",
            type: "number",
            plot: "limit_upper"
        }, {
            name: "middleBand",
            type: "number",
            plot: "line"
        }, {
            name: "lowerBand",
            type: "number",
            plot: "limit_lower"
        }]
};
const BETA = {
    name: "BETA",
    camelCaseName: "beta",
    group: "Statistic Functions",
    description: "Beta",
    inputs: [{
            name: "inReal0",
            type: "number"
        }, {
            name: "inReal1",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 5,
            hint: "Number of period",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const BOP = {
    name: "BOP",
    camelCaseName: "bop",
    group: "Momentum Indicators",
    description: "Balance Of Power",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CCI$1 = {
    name: "CCI",
    camelCaseName: "cci",
    group: "Momentum Indicators",
    description: "Commodity Channel Index",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDL2CROWS = {
    name: "CDL2CROWS",
    camelCaseName: "cdl2Crows",
    group: "Pattern Recognition",
    description: "Two Crows",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDL3BLACKCROWS = {
    name: "CDL3BLACKCROWS",
    camelCaseName: "cdl3BlackCrows",
    group: "Pattern Recognition",
    description: "Three Black Crows",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDL3INSIDE = {
    name: "CDL3INSIDE",
    camelCaseName: "cdl3Inside",
    group: "Pattern Recognition",
    description: "Three Inside Up/Down",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDL3LINESTRIKE = {
    name: "CDL3LINESTRIKE",
    camelCaseName: "cdl3LineStrike",
    group: "Pattern Recognition",
    description: "Three-Line Strike ",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDL3OUTSIDE = {
    name: "CDL3OUTSIDE",
    camelCaseName: "cdl3Outside",
    group: "Pattern Recognition",
    description: "Three Outside Up/Down",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDL3STARSINSOUTH = {
    name: "CDL3STARSINSOUTH",
    camelCaseName: "cdl3StarsInSouth",
    group: "Pattern Recognition",
    description: "Three Stars In The South",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDL3WHITESOLDIERS = {
    name: "CDL3WHITESOLDIERS",
    camelCaseName: "cdl3WhiteSoldiers",
    group: "Pattern Recognition",
    description: "Three Advancing White Soldiers",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLABANDONEDBABY = {
    name: "CDLABANDONEDBABY",
    camelCaseName: "cdlAbandonedBaby",
    group: "Pattern Recognition",
    description: "Abandoned Baby",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [{
            name: "penetration",
            displayName: "Penetration",
            defaultValue: 0.3,
            hint: "Percentage of penetration of a candle within another candle",
            type: "number",
            range: {
                min: 0,
                max: 3e+37
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLADVANCEBLOCK = {
    name: "CDLADVANCEBLOCK",
    camelCaseName: "cdlAdvanceBlock",
    group: "Pattern Recognition",
    description: "Advance Block",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLBELTHOLD = {
    name: "CDLBELTHOLD",
    camelCaseName: "cdlBeltHold",
    group: "Pattern Recognition",
    description: "Belt-hold",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLBREAKAWAY = {
    name: "CDLBREAKAWAY",
    camelCaseName: "cdlBreakaway",
    group: "Pattern Recognition",
    description: "Breakaway",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLCLOSINGMARUBOZU = {
    name: "CDLCLOSINGMARUBOZU",
    camelCaseName: "cdlClosingMarubozu",
    group: "Pattern Recognition",
    description: "Closing Marubozu",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLCONCEALBABYSWALL = {
    name: "CDLCONCEALBABYSWALL",
    camelCaseName: "cdlConcealBabysWall",
    group: "Pattern Recognition",
    description: "Concealing Baby Swallow",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLCOUNTERATTACK = {
    name: "CDLCOUNTERATTACK",
    camelCaseName: "cdlCounterAttack",
    group: "Pattern Recognition",
    description: "Counterattack",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLDARKCLOUDCOVER = {
    name: "CDLDARKCLOUDCOVER",
    camelCaseName: "cdlDarkCloudCover",
    group: "Pattern Recognition",
    description: "Dark Cloud Cover",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [{
            name: "penetration",
            displayName: "Penetration",
            defaultValue: 0.5,
            hint: "Percentage of penetration of a candle within another candle",
            type: "number",
            range: {
                min: 0,
                max: 3e+37
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLDOJI = {
    name: "CDLDOJI",
    camelCaseName: "cdlDoji",
    group: "Pattern Recognition",
    description: "Doji",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLDOJISTAR = {
    name: "CDLDOJISTAR",
    camelCaseName: "cdlDojiStar",
    group: "Pattern Recognition",
    description: "Doji Star",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLDRAGONFLYDOJI = {
    name: "CDLDRAGONFLYDOJI",
    camelCaseName: "cdlDragonflyDoji",
    group: "Pattern Recognition",
    description: "Dragonfly Doji",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLENGULFING = {
    name: "CDLENGULFING",
    camelCaseName: "cdlEngulfing",
    group: "Pattern Recognition",
    description: "Engulfing Pattern",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLEVENINGDOJISTAR = {
    name: "CDLEVENINGDOJISTAR",
    camelCaseName: "cdlEveningDojiStar",
    group: "Pattern Recognition",
    description: "Evening Doji Star",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [{
            name: "penetration",
            displayName: "Penetration",
            defaultValue: 0.3,
            hint: "Percentage of penetration of a candle within another candle",
            type: "number",
            range: {
                min: 0,
                max: 3e+37
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLEVENINGSTAR = {
    name: "CDLEVENINGSTAR",
    camelCaseName: "cdlEveningStar",
    group: "Pattern Recognition",
    description: "Evening Star",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [{
            name: "penetration",
            displayName: "Penetration",
            defaultValue: 0.3,
            hint: "Percentage of penetration of a candle within another candle",
            type: "number",
            range: {
                min: 0,
                max: 3e+37
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLGAPSIDESIDEWHITE = {
    name: "CDLGAPSIDESIDEWHITE",
    camelCaseName: "cdlGapSideSideWhite",
    group: "Pattern Recognition",
    description: "Up/Down-gap side-by-side white lines",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLGRAVESTONEDOJI = {
    name: "CDLGRAVESTONEDOJI",
    camelCaseName: "cdlGravestoneDoji",
    group: "Pattern Recognition",
    description: "Gravestone Doji",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLHAMMER = {
    name: "CDLHAMMER",
    camelCaseName: "cdlHammer",
    group: "Pattern Recognition",
    description: "Hammer",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLHANGINGMAN = {
    name: "CDLHANGINGMAN",
    camelCaseName: "cdlHangingMan",
    group: "Pattern Recognition",
    description: "Hanging Man",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLHARAMI = {
    name: "CDLHARAMI",
    camelCaseName: "cdlHarami",
    group: "Pattern Recognition",
    description: "Harami Pattern",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLHARAMICROSS = {
    name: "CDLHARAMICROSS",
    camelCaseName: "cdlHaramiCross",
    group: "Pattern Recognition",
    description: "Harami Cross Pattern",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLHIGHWAVE = {
    name: "CDLHIGHWAVE",
    camelCaseName: "cdlHignWave",
    group: "Pattern Recognition",
    description: "High-Wave Candle",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLHIKKAKE = {
    name: "CDLHIKKAKE",
    camelCaseName: "cdlHikkake",
    group: "Pattern Recognition",
    description: "Hikkake Pattern",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLHIKKAKEMOD = {
    name: "CDLHIKKAKEMOD",
    camelCaseName: "cdlHikkakeMod",
    group: "Pattern Recognition",
    description: "Modified Hikkake Pattern",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLHOMINGPIGEON = {
    name: "CDLHOMINGPIGEON",
    camelCaseName: "cdlHomingPigeon",
    group: "Pattern Recognition",
    description: "Homing Pigeon",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLIDENTICAL3CROWS = {
    name: "CDLIDENTICAL3CROWS",
    camelCaseName: "cdlIdentical3Crows",
    group: "Pattern Recognition",
    description: "Identical Three Crows",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLINNECK = {
    name: "CDLINNECK",
    camelCaseName: "cdlInNeck",
    group: "Pattern Recognition",
    description: "In-Neck Pattern",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLINVERTEDHAMMER = {
    name: "CDLINVERTEDHAMMER",
    camelCaseName: "cdlInvertedHammer",
    group: "Pattern Recognition",
    description: "Inverted Hammer",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLKICKING = {
    name: "CDLKICKING",
    camelCaseName: "cdlKicking",
    group: "Pattern Recognition",
    description: "Kicking",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLKICKINGBYLENGTH = {
    name: "CDLKICKINGBYLENGTH",
    camelCaseName: "cdlKickingByLength",
    group: "Pattern Recognition",
    description: "Kicking - bull/bear determined by the longer marubozu",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLLADDERBOTTOM = {
    name: "CDLLADDERBOTTOM",
    camelCaseName: "cdlLadderBottom",
    group: "Pattern Recognition",
    description: "Ladder Bottom",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLLONGLEGGEDDOJI = {
    name: "CDLLONGLEGGEDDOJI",
    camelCaseName: "cdlLongLeggedDoji",
    group: "Pattern Recognition",
    description: "Long Legged Doji",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLLONGLINE = {
    name: "CDLLONGLINE",
    camelCaseName: "cdlLongLine",
    group: "Pattern Recognition",
    description: "Long Line Candle",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLMARUBOZU = {
    name: "CDLMARUBOZU",
    camelCaseName: "cdlMarubozu",
    group: "Pattern Recognition",
    description: "Marubozu",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLMATCHINGLOW = {
    name: "CDLMATCHINGLOW",
    camelCaseName: "cdlMatchingLow",
    group: "Pattern Recognition",
    description: "Matching Low",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLMATHOLD = {
    name: "CDLMATHOLD",
    camelCaseName: "cdlMatHold",
    group: "Pattern Recognition",
    description: "Mat Hold",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [{
            name: "penetration",
            displayName: "Penetration",
            defaultValue: 0.5,
            hint: "Percentage of penetration of a candle within another candle",
            type: "number",
            range: {
                min: 0,
                max: 3e+37
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLMORNINGDOJISTAR = {
    name: "CDLMORNINGDOJISTAR",
    camelCaseName: "cdlMorningDojiStar",
    group: "Pattern Recognition",
    description: "Morning Doji Star",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [{
            name: "penetration",
            displayName: "Penetration",
            defaultValue: 0.3,
            hint: "Percentage of penetration of a candle within another candle",
            type: "number",
            range: {
                min: 0,
                max: 3e+37
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLMORNINGSTAR = {
    name: "CDLMORNINGSTAR",
    camelCaseName: "cdlMorningStar",
    group: "Pattern Recognition",
    description: "Morning Star",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [{
            name: "penetration",
            displayName: "Penetration",
            defaultValue: 0.3,
            hint: "Percentage of penetration of a candle within another candle",
            type: "number",
            range: {
                min: 0,
                max: 3e+37
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLONNECK = {
    name: "CDLONNECK",
    camelCaseName: "cdlOnNeck",
    group: "Pattern Recognition",
    description: "On-Neck Pattern",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLPIERCING = {
    name: "CDLPIERCING",
    camelCaseName: "cdlPiercing",
    group: "Pattern Recognition",
    description: "Piercing Pattern",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLRICKSHAWMAN = {
    name: "CDLRICKSHAWMAN",
    camelCaseName: "cdlRickshawMan",
    group: "Pattern Recognition",
    description: "Rickshaw Man",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLRISEFALL3METHODS = {
    name: "CDLRISEFALL3METHODS",
    camelCaseName: "cdlRiseFall3Methods",
    group: "Pattern Recognition",
    description: "Rising/Falling Three Methods",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLSEPARATINGLINES = {
    name: "CDLSEPARATINGLINES",
    camelCaseName: "cdlSeperatingLines",
    group: "Pattern Recognition",
    description: "Separating Lines",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLSHOOTINGSTAR = {
    name: "CDLSHOOTINGSTAR",
    camelCaseName: "cdlShootingStar",
    group: "Pattern Recognition",
    description: "Shooting Star",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLSHORTLINE = {
    name: "CDLSHORTLINE",
    camelCaseName: "cdlShortLine",
    group: "Pattern Recognition",
    description: "Short Line Candle",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLSPINNINGTOP = {
    name: "CDLSPINNINGTOP",
    camelCaseName: "cdlSpinningTop",
    group: "Pattern Recognition",
    description: "Spinning Top",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLSTALLEDPATTERN = {
    name: "CDLSTALLEDPATTERN",
    camelCaseName: "cdlStalledPattern",
    group: "Pattern Recognition",
    description: "Stalled Pattern",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLSTICKSANDWICH = {
    name: "CDLSTICKSANDWICH",
    camelCaseName: "cdlStickSandwhich",
    group: "Pattern Recognition",
    description: "Stick Sandwich",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLTAKURI = {
    name: "CDLTAKURI",
    camelCaseName: "cdlTakuri",
    group: "Pattern Recognition",
    description: "Takuri (Dragonfly Doji with very long lower shadow)",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLTASUKIGAP = {
    name: "CDLTASUKIGAP",
    camelCaseName: "cdlTasukiGap",
    group: "Pattern Recognition",
    description: "Tasuki Gap",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLTHRUSTING = {
    name: "CDLTHRUSTING",
    camelCaseName: "cdlThrusting",
    group: "Pattern Recognition",
    description: "Thrusting Pattern",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLTRISTAR = {
    name: "CDLTRISTAR",
    camelCaseName: "cdlTristar",
    group: "Pattern Recognition",
    description: "Tristar Pattern",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLUNIQUE3RIVER = {
    name: "CDLUNIQUE3RIVER",
    camelCaseName: "cdlUnique3River",
    group: "Pattern Recognition",
    description: "Unique 3 River",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLUPSIDEGAP2CROWS = {
    name: "CDLUPSIDEGAP2CROWS",
    camelCaseName: "cdlUpsideGap2Crows",
    group: "Pattern Recognition",
    description: "Upside Gap Two Crows",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CDLXSIDEGAP3METHODS = {
    name: "CDLXSIDEGAP3METHODS",
    camelCaseName: "cdlXSideGap3Methods",
    group: "Pattern Recognition",
    description: "Upside/Downside Gap Three Methods",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CEIL = {
    name: "CEIL",
    camelCaseName: "ceil",
    group: "Math Transform",
    description: "Vector Ceil",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CMO$1 = {
    name: "CMO",
    camelCaseName: "cmo",
    group: "Momentum Indicators",
    description: "Chande Momentum Oscillator",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const CORREL = {
    name: "CORREL",
    camelCaseName: "correl",
    group: "Statistic Functions",
    description: "Pearson's Correlation Coefficient (r)",
    inputs: [{
            name: "inReal0",
            type: "number"
        }, {
            name: "inReal1",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 30,
            hint: "Number of period",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const COS = {
    name: "COS",
    camelCaseName: "cos",
    group: "Math Transform",
    description: "Vector Trigonometric Cos",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const COSH = {
    name: "COSH",
    camelCaseName: "cosh",
    group: "Math Transform",
    description: "Vector Trigonometric Cosh",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const DEMA = {
    name: "DEMA",
    camelCaseName: "dema",
    group: "Overlap Studies",
    description: "number Exponential Moving Average",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 30,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const DIV = {
    name: "DIV",
    camelCaseName: "div",
    group: "Math Operators",
    description: "Vector Arithmetic Div",
    inputs: [{
            name: "inReal0",
            type: "number"
        }, {
            name: "inReal1",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const DX$1 = {
    name: "DX",
    camelCaseName: "dx",
    group: "Momentum Indicators",
    description: "Directional Movement Index",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const EMA$1 = {
    name: "EMA",
    camelCaseName: "ema",
    group: "Overlap Studies",
    description: "Exponential Moving Average",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 30,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const EXP = {
    name: "EXP",
    camelCaseName: "exp",
    group: "Math Transform",
    description: "Vector Arithmetic Exp",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const FLOOR = {
    name: "FLOOR",
    camelCaseName: "floor",
    group: "Math Transform",
    description: "Vector Floor",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const HT_DCPERIOD = {
    name: "HT_DCPERIOD",
    camelCaseName: "htDcPeriod",
    group: "Cycle Indicators",
    description: "Hilbert Transform - Dominant Cycle Period",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const HT_DCPHASE = {
    name: "HT_DCPHASE",
    camelCaseName: "htDcPhase",
    group: "Cycle Indicators",
    description: "Hilbert Transform - Dominant Cycle Phase",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const HT_PHASOR = {
    name: "HT_PHASOR",
    camelCaseName: "htPhasor",
    group: "Cycle Indicators",
    description: "Hilbert Transform - Phasor Components",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "inPhase",
            type: "number",
            plot: "line"
        }, {
            name: "quadrature",
            type: "number",
            plot: "line_dash"
        }]
};
const HT_SINE = {
    name: "HT_SINE",
    camelCaseName: "htSine",
    group: "Cycle Indicators",
    description: "Hilbert Transform - SineWave",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "sine",
            type: "number",
            plot: "line"
        }, {
            name: "leadSine",
            type: "number",
            plot: "line_dash"
        }]
};
const HT_TRENDLINE = {
    name: "HT_TRENDLINE",
    camelCaseName: "htTrendline",
    group: "Overlap Studies",
    description: "Hilbert Transform - Instantaneous Trendline",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const HT_TRENDMODE = {
    name: "HT_TRENDMODE",
    camelCaseName: "htTrendMode",
    group: "Cycle Indicators",
    description: "Hilbert Transform - Trend vs Cycle Mode",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const IMI = {
    name: "IMI",
    camelCaseName: "imi",
    group: "Momentum Indicators",
    description: "Intraday Momentum Index",
    inputs: [{
            name: "open",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const KAMA = {
    name: "KAMA",
    camelCaseName: "kama",
    group: "Overlap Studies",
    description: "Kaufman Adaptive Moving Average",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 30,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const LINEARREG = {
    name: "LINEARREG",
    camelCaseName: "linearReg",
    group: "Statistic Functions",
    description: "Linear Regression",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const LINEARREG_ANGLE = {
    name: "LINEARREG_ANGLE",
    camelCaseName: "linearRegAngle",
    group: "Statistic Functions",
    description: "Linear Regression Angle",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const LINEARREG_INTERCEPT = {
    name: "LINEARREG_INTERCEPT",
    camelCaseName: "linearRegIntercept",
    group: "Statistic Functions",
    description: "Linear Regression Intercept",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const LINEARREG_SLOPE = {
    name: "LINEARREG_SLOPE",
    camelCaseName: "linearRegSlope",
    group: "Statistic Functions",
    description: "Linear Regression Slope",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const LN = {
    name: "LN",
    camelCaseName: "ln",
    group: "Math Transform",
    description: "Vector Log Natural",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const LOG10 = {
    name: "LOG10",
    camelCaseName: "log10",
    group: "Math Transform",
    description: "Vector Log10",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const MA$1 = {
    name: "MA",
    camelCaseName: "movingAverage",
    group: "Overlap Studies",
    description: "Moving average",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 30,
            hint: "Number of period",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }, {
            name: "MAType",
            displayName: "MA Type",
            defaultValue: 0,
            hint: "Type of Moving Average",
            type: "MAType"
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const MACD$1 = {
    name: "MACD",
    camelCaseName: "macd",
    group: "Momentum Indicators",
    description: "Moving Average Convergence/Divergence",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "fastPeriod",
            displayName: "Fast Period",
            defaultValue: 12,
            hint: "Number of period for the fast MA",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }, {
            name: "slowPeriod",
            displayName: "Slow Period",
            defaultValue: 26,
            hint: "Number of period for the slow MA",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }, {
            name: "signalPeriod",
            displayName: "Signal Period",
            defaultValue: 9,
            hint: "Smoothing for the signal line (nb of period)",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }],
    outputs: [{
            name: "MACD",
            type: "number",
            plot: "line"
        }, {
            name: "MACDSignal",
            type: "number",
            plot: "line_dash"
        }, {
            name: "MACDHist",
            type: "number",
            plot: "histogram"
        }]
};
const MACDEXT = {
    name: "MACDEXT",
    camelCaseName: "macdExt",
    group: "Momentum Indicators",
    description: "MACD with controllable MA type",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "fastPeriod",
            displayName: "Fast Period",
            defaultValue: 12,
            hint: "Number of period for the fast MA",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }, {
            name: "fastMAType",
            displayName: "Fast MA",
            defaultValue: 0,
            hint: "Type of Moving Average for fast MA",
            type: "MAType"
        }, {
            name: "slowPeriod",
            displayName: "Slow Period",
            defaultValue: 26,
            hint: "Number of period for the slow MA",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }, {
            name: "slowMAType",
            displayName: "Slow MA",
            defaultValue: 0,
            hint: "Type of Moving Average for slow MA",
            type: "MAType"
        }, {
            name: "signalPeriod",
            displayName: "Signal Period",
            defaultValue: 9,
            hint: "Smoothing for the signal line (nb of period)",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }, {
            name: "signalMAType",
            displayName: "Signal MA",
            defaultValue: 0,
            hint: "Type of Moving Average for signal line",
            type: "MAType"
        }],
    outputs: [{
            name: "MACD",
            type: "number",
            plot: "line"
        }, {
            name: "MACDSignal",
            type: "number",
            plot: "line_dash"
        }, {
            name: "MACDHist",
            type: "number",
            plot: "histogram"
        }]
};
const MACDFIX = {
    name: "MACDFIX",
    camelCaseName: "macdFix",
    group: "Momentum Indicators",
    description: "Moving Average Convergence/Divergence Fix 12/26",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "signalPeriod",
            displayName: "Signal Period",
            defaultValue: 9,
            hint: "Smoothing for the signal line (nb of period)",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }],
    outputs: [{
            name: "MACD",
            type: "number",
            plot: "line"
        }, {
            name: "MACDSignal",
            type: "number",
            plot: "line_dash"
        }, {
            name: "MACDHist",
            type: "number",
            plot: "histogram"
        }]
};
const MAMA = {
    name: "MAMA",
    camelCaseName: "mama",
    group: "Overlap Studies",
    description: "MESA Adaptive Moving Average",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "fastLimit",
            displayName: "Fast Limit",
            defaultValue: 0.5,
            hint: "Upper limit use in the adaptive algorithm",
            type: "number",
            range: {
                min: 0.01,
                max: 0.99
            }
        }, {
            name: "slowLimit",
            displayName: "Slow Limit",
            defaultValue: 0.05,
            hint: "Lower limit use in the adaptive algorithm",
            type: "number",
            range: {
                min: 0.01,
                max: 0.99
            }
        }],
    outputs: [{
            name: "MAMA",
            type: "number",
            plot: "line"
        }, {
            name: "FAMA",
            type: "number",
            plot: "line_dash"
        }]
};
const MAVP = {
    name: "MAVP",
    camelCaseName: "movingAverageVariablePeriod",
    group: "Overlap Studies",
    description: "Moving average with variable period",
    inputs: [{
            name: "inReal",
            type: "number"
        }, {
            name: "inPeriods",
            type: "number"
        }],
    options: [{
            name: "minPeriod",
            displayName: "Minimum Period",
            defaultValue: 2,
            hint: "Value less than minimum will be changed to Minimum period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }, {
            name: "maxPeriod",
            displayName: "Maximum Period",
            defaultValue: 30,
            hint: "Value higher than maximum will be changed to Maximum period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }, {
            name: "MAType",
            displayName: "MA Type",
            defaultValue: 0,
            hint: "Type of Moving Average",
            type: "MAType"
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const MAX = {
    name: "MAX",
    camelCaseName: "max",
    group: "Math Operators",
    description: "Highest value over a specified period",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 30,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const MAXINDEX = {
    name: "MAXINDEX",
    camelCaseName: "maxIndex",
    group: "Math Operators",
    description: "Index of highest value over a specified period",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 30,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const MEDPRICE = {
    name: "MEDPRICE",
    camelCaseName: "medPrice",
    group: "Price Transform",
    description: "Median Price",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const MFI$1 = {
    name: "MFI",
    camelCaseName: "mfi",
    group: "Momentum Indicators",
    description: "Money Flow Index",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }, {
            name: "volume",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const MIDPOINT = {
    name: "MIDPOINT",
    camelCaseName: "midPoint",
    group: "Overlap Studies",
    description: "MidPoint over period",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const MIDPRICE = {
    name: "MIDPRICE",
    camelCaseName: "midPrice",
    group: "Overlap Studies",
    description: "Midpoint Price over period",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const MIN = {
    name: "MIN",
    camelCaseName: "min",
    group: "Math Operators",
    description: "Lowest value over a specified period",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 30,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const MININDEX = {
    name: "MININDEX",
    camelCaseName: "minIndex",
    group: "Math Operators",
    description: "Index of lowest value over a specified period",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 30,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const MINMAX = {
    name: "MINMAX",
    camelCaseName: "minMax",
    group: "Math Operators",
    description: "Lowest and highest values over a specified period",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 30,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "min",
            type: "number",
            plot: "line"
        }, {
            name: "max",
            type: "number",
            plot: "line"
        }]
};
const MINMAXINDEX = {
    name: "MINMAXINDEX",
    camelCaseName: "minMaxIndex",
    group: "Math Operators",
    description: "Indexes of lowest and highest values over a specified period",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 30,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "minIdx",
            type: "number",
            plot: "line"
        }, {
            name: "maxIdx",
            type: "number",
            plot: "line"
        }]
};
const MINUS_DI = {
    name: "MINUS_DI",
    camelCaseName: "minusDI",
    group: "Momentum Indicators",
    description: "Minus Directional Indicator",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const MINUS_DM = {
    name: "MINUS_DM",
    camelCaseName: "minusDM",
    group: "Momentum Indicators",
    description: "Minus Directional Movement",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const MOM = {
    name: "MOM",
    camelCaseName: "mom",
    group: "Momentum Indicators",
    description: "Momentum",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 10,
            hint: "Number of period",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const MULT = {
    name: "MULT",
    camelCaseName: "mult",
    group: "Math Operators",
    description: "Vector Arithmetic Mult",
    inputs: [{
            name: "inReal0",
            type: "number"
        }, {
            name: "inReal1",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const NATR = {
    name: "NATR",
    camelCaseName: "natr",
    group: "Volatility Indicators",
    description: "Normalized Average True Range",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const OBV$1 = {
    name: "OBV",
    camelCaseName: "obv",
    group: "Volume Indicators",
    description: "On Balance Volume",
    inputs: [{
            name: "inReal",
            type: "number"
        }, {
            name: "volume",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const PLUS_DI = {
    name: "PLUS_DI",
    camelCaseName: "plusDI",
    group: "Momentum Indicators",
    description: "Plus Directional Indicator",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const PLUS_DM = {
    name: "PLUS_DM",
    camelCaseName: "plusDM",
    group: "Momentum Indicators",
    description: "Plus Directional Movement",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const PPO$1 = {
    name: "PPO",
    camelCaseName: "ppo",
    group: "Momentum Indicators",
    description: "Percentage Price Oscillator",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "fastPeriod",
            displayName: "Fast Period",
            defaultValue: 12,
            hint: "Number of period for the fast MA",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }, {
            name: "slowPeriod",
            displayName: "Slow Period",
            defaultValue: 26,
            hint: "Number of period for the slow MA",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }, {
            name: "MAType",
            displayName: "MA Type",
            defaultValue: 0,
            hint: "Type of Moving Average",
            type: "MAType"
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const ROC$1 = {
    name: "ROC",
    camelCaseName: "roc",
    group: "Momentum Indicators",
    description: "Rate of change : ((price/prevPrice)-1)*100",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 10,
            hint: "Number of period",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const ROCP = {
    name: "ROCP",
    camelCaseName: "rocP",
    group: "Momentum Indicators",
    description: "Rate of change Percentage: (price-prevPrice)/prevPrice",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 10,
            hint: "Number of period",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const ROCR = {
    name: "ROCR",
    camelCaseName: "rocR",
    group: "Momentum Indicators",
    description: "Rate of change ratio: (price/prevPrice)",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 10,
            hint: "Number of period",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const ROCR100 = {
    name: "ROCR100",
    camelCaseName: "rocR100",
    group: "Momentum Indicators",
    description: "Rate of change ratio 100 scale: (price/prevPrice)*100",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 10,
            hint: "Number of period",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const RSI$1 = {
    name: "RSI",
    camelCaseName: "rsi",
    group: "Momentum Indicators",
    description: "Relative Strength Index",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const SAR = {
    name: "SAR",
    camelCaseName: "sar",
    group: "Overlap Studies",
    description: "Parabolic SAR",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }],
    options: [{
            name: "acceleration",
            displayName: "Acceleration Factor",
            defaultValue: 0.02,
            hint: "Acceleration Factor used up to the Maximum value",
            type: "number",
            range: {
                min: 0,
                max: 3e+37
            }
        }, {
            name: "maximum",
            displayName: "AF Maximum",
            defaultValue: 0.2,
            hint: "Acceleration Factor Maximum value",
            type: "number",
            range: {
                min: 0,
                max: 3e+37
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const SAREXT = {
    name: "SAREXT",
    camelCaseName: "sarExt",
    group: "Overlap Studies",
    description: "Parabolic SAR - Extended",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }],
    options: [{
            name: "startValue",
            displayName: "Start Value",
            defaultValue: 0,
            hint: "Start value and direction. 0 for Auto, >0 for Long, <0 for Short",
            type: "number",
            range: {
                min: -3e+37,
                max: 3e+37
            }
        }, {
            name: "offsetOnReverse",
            displayName: "Offset on Reverse",
            defaultValue: 0,
            hint: "Percent offset added/removed to initial stop on short/long reversal",
            type: "number",
            range: {
                min: 0,
                max: 3e+37
            }
        }, {
            name: "accelerationInitLong",
            displayName: "AF Init Long",
            defaultValue: 0.02,
            hint: "Acceleration Factor initial value for the Long direction",
            type: "number",
            range: {
                min: 0,
                max: 3e+37
            }
        }, {
            name: "accelerationLong",
            displayName: "AF Long",
            defaultValue: 0.02,
            hint: "Acceleration Factor for the Long direction",
            type: "number",
            range: {
                min: 0,
                max: 3e+37
            }
        }, {
            name: "accelerationMaxLong",
            displayName: "AF Max Long",
            defaultValue: 0.2,
            hint: "Acceleration Factor maximum value for the Long direction",
            type: "number",
            range: {
                min: 0,
                max: 3e+37
            }
        }, {
            name: "accelerationInitShort",
            displayName: "AF Init Short",
            defaultValue: 0.02,
            hint: "Acceleration Factor initial value for the Short direction",
            type: "number",
            range: {
                min: 0,
                max: 3e+37
            }
        }, {
            name: "accelerationShort",
            displayName: "AF Short",
            defaultValue: 0.02,
            hint: "Acceleration Factor for the Short direction",
            type: "number",
            range: {
                min: 0,
                max: 3e+37
            }
        }, {
            name: "accelerationMaxShort",
            displayName: "AF Max Short",
            defaultValue: 0.2,
            hint: "Acceleration Factor maximum value for the Short direction",
            type: "number",
            range: {
                min: 0,
                max: 3e+37
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const SIN = {
    name: "SIN",
    camelCaseName: "sin",
    group: "Math Transform",
    description: "Vector Trigonometric Sin",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const SINH = {
    name: "SINH",
    camelCaseName: "sinh",
    group: "Math Transform",
    description: "Vector Trigonometric Sinh",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const SMA$1 = {
    name: "SMA",
    camelCaseName: "sma",
    group: "Overlap Studies",
    description: "Simple Moving Average",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 30,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const SQRT = {
    name: "SQRT",
    camelCaseName: "sqrt",
    group: "Math Transform",
    description: "Vector Square Root",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const STDDEV = {
    name: "STDDEV",
    camelCaseName: "stdDev",
    group: "Statistic Functions",
    description: "Standard Deviation",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 5,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }, {
            name: "nbDev",
            displayName: "Deviations",
            defaultValue: 1,
            hint: "Nb of deviations",
            type: "number",
            range: {
                min: -3e+37,
                max: 3e+37
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const STOCH$1 = {
    name: "STOCH",
    camelCaseName: "stoch",
    group: "Momentum Indicators",
    description: "Stochastic",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [{
            name: "fastK_Period",
            displayName: "Fast-K Period",
            defaultValue: 5,
            hint: "Time period for building the Fast-K line",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }, {
            name: "slowK_Period",
            displayName: "Slow-K Period",
            defaultValue: 3,
            hint: "Smoothing for making the Slow-K line. Usually set to 3",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }, {
            name: "slowK_MAType",
            displayName: "Slow-K MA",
            defaultValue: 0,
            hint: "Type of Moving Average for Slow-K",
            type: "MAType"
        }, {
            name: "slowD_Period",
            displayName: "Slow-D Period",
            defaultValue: 3,
            hint: "Smoothing for making the Slow-D line",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }, {
            name: "slowD_MAType",
            displayName: "Slow-D MA",
            defaultValue: 0,
            hint: "Type of Moving Average for Slow-D",
            type: "MAType"
        }],
    outputs: [{
            name: "slowK",
            type: "number",
            plot: "line_dash"
        }, {
            name: "slowD",
            type: "number",
            plot: "line_dash"
        }]
};
const STOCHF = {
    name: "STOCHF",
    camelCaseName: "stochF",
    group: "Momentum Indicators",
    description: "Stochastic Fast",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [{
            name: "fastK_Period",
            displayName: "Fast-K Period",
            defaultValue: 5,
            hint: "Time period for building the Fast-K line",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }, {
            name: "fastD_Period",
            displayName: "Fast-D Period",
            defaultValue: 3,
            hint: "Smoothing for making the Fast-D line. Usually set to 3",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }, {
            name: "fastD_MAType",
            displayName: "Fast-D MA",
            defaultValue: 0,
            hint: "Type of Moving Average for Fast-D",
            type: "MAType"
        }],
    outputs: [{
            name: "fastK",
            type: "number",
            plot: "line"
        }, {
            name: "fastD",
            type: "number",
            plot: "line"
        }]
};
const STOCHRSI$1 = {
    name: "STOCHRSI",
    camelCaseName: "stochRsi",
    group: "Momentum Indicators",
    description: "Stochastic Relative Strength Index",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }, {
            name: "fastK_Period",
            displayName: "Fast-K Period",
            defaultValue: 5,
            hint: "Time period for building the Fast-K line",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }, {
            name: "fastD_Period",
            displayName: "Fast-D Period",
            defaultValue: 3,
            hint: "Smoothing for making the Fast-D line. Usually set to 3",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }, {
            name: "fastD_MAType",
            displayName: "Fast-D MA",
            defaultValue: 0,
            hint: "Type of Moving Average for Fast-D",
            type: "MAType"
        }],
    outputs: [{
            name: "fastK",
            type: "number",
            plot: "line"
        }, {
            name: "fastD",
            type: "number",
            plot: "line"
        }]
};
const SUB = {
    name: "SUB",
    camelCaseName: "sub",
    group: "Math Operators",
    description: "Vector Arithmetic Substraction",
    inputs: [{
            name: "inReal0",
            type: "number"
        }, {
            name: "inReal1",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const SUM = {
    name: "SUM",
    camelCaseName: "sum",
    group: "Math Operators",
    description: "Summation",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 30,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const T3 = {
    name: "T3",
    camelCaseName: "t3",
    group: "Overlap Studies",
    description: "Triple Exponential Moving Average (T3)",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 5,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }, {
            name: "VFactor",
            displayName: "Volume Factor",
            defaultValue: 0.7,
            hint: "Volume Factor",
            type: "number",
            range: {
                min: 0,
                max: 1
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const TAN = {
    name: "TAN",
    camelCaseName: "tan",
    group: "Math Transform",
    description: "Vector Trigonometric Tan",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const TANH = {
    name: "TANH",
    camelCaseName: "tanh",
    group: "Math Transform",
    description: "Vector Trigonometric Tanh",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const TEMA = {
    name: "TEMA",
    camelCaseName: "tema",
    group: "Overlap Studies",
    description: "Triple Exponential Moving Average",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 30,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const TRANGE = {
    name: "TRANGE",
    camelCaseName: "trueRange",
    group: "Volatility Indicators",
    description: "True Range",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const TRIMA = {
    name: "TRIMA",
    camelCaseName: "trima",
    group: "Overlap Studies",
    description: "Triangular Moving Average",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 30,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const TRIX = {
    name: "TRIX",
    camelCaseName: "trix",
    group: "Momentum Indicators",
    description: "1-day Rate-Of-Change (ROC) of a Triple Smooth EMA",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 30,
            hint: "Number of period",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const TSF = {
    name: "TSF",
    camelCaseName: "tsf",
    group: "Statistic Functions",
    description: "Time Series Forecast",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const TYPPRICE = {
    name: "TYPPRICE",
    camelCaseName: "typPrice",
    group: "Price Transform",
    description: "Typical Price",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const ULTOSC = {
    name: "ULTOSC",
    camelCaseName: "ultOsc",
    group: "Momentum Indicators",
    description: "Ultimate Oscillator",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [{
            name: "timePeriod1",
            displayName: "First Period",
            defaultValue: 7,
            hint: "Number of bars for 1st period.",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }, {
            name: "timePeriod2",
            displayName: "Second Period",
            defaultValue: 14,
            hint: "Number of bars fro 2nd period",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }, {
            name: "timePeriod3",
            displayName: "Third Period",
            defaultValue: 28,
            hint: "Number of bars for 3rd period",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const VAR = {
    name: "VAR",
    camelCaseName: "variance",
    group: "Statistic Functions",
    description: "Variance",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 5,
            hint: "Number of period",
            type: "number",
            range: {
                min: 1,
                max: 100000
            }
        }, {
            name: "nbDev",
            displayName: "Deviations",
            defaultValue: 1,
            hint: "Nb of deviations",
            type: "number",
            range: {
                min: -3e+37,
                max: 3e+37
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const WCLPRICE = {
    name: "WCLPRICE",
    camelCaseName: "wclPrice",
    group: "Price Transform",
    description: "Weighted Close Price",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const WILLR = {
    name: "WILLR",
    camelCaseName: "willR",
    group: "Momentum Indicators",
    description: "Williams' %R",
    inputs: [{
            name: "high",
            type: "number"
        }, {
            name: "low",
            type: "number"
        }, {
            name: "close",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 14,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const WMA = {
    name: "WMA",
    camelCaseName: "wma",
    group: "Overlap Studies",
    description: "Weighted Moving Average",
    inputs: [{
            name: "inReal",
            type: "number"
        }],
    options: [{
            name: "timePeriod",
            displayName: "Time Period",
            defaultValue: 30,
            hint: "Number of period",
            type: "number",
            range: {
                min: 2,
                max: 100000
            }
        }],
    outputs: [{
            name: "output",
            type: "number",
            plot: "line"
        }]
};
const talibAPI = {
    ACCBANDS,
    ACOS,
    AD,
    ADD,
    ADOSC,
    ADX: ADX$1,
    ADXR,
    APO,
    AROON: AROON$1,
    AROONOSC,
    ASIN,
    ATAN,
    ATR: ATR$1,
    AVGDEV,
    AVGPRICE,
    BBANDS,
    BETA,
    BOP,
    CCI: CCI$1,
    CDL2CROWS,
    CDL3BLACKCROWS,
    CDL3INSIDE,
    CDL3LINESTRIKE,
    CDL3OUTSIDE,
    CDL3STARSINSOUTH,
    CDL3WHITESOLDIERS,
    CDLABANDONEDBABY,
    CDLADVANCEBLOCK,
    CDLBELTHOLD,
    CDLBREAKAWAY,
    CDLCLOSINGMARUBOZU,
    CDLCONCEALBABYSWALL,
    CDLCOUNTERATTACK,
    CDLDARKCLOUDCOVER,
    CDLDOJI,
    CDLDOJISTAR,
    CDLDRAGONFLYDOJI,
    CDLENGULFING,
    CDLEVENINGDOJISTAR,
    CDLEVENINGSTAR,
    CDLGAPSIDESIDEWHITE,
    CDLGRAVESTONEDOJI,
    CDLHAMMER,
    CDLHANGINGMAN,
    CDLHARAMI,
    CDLHARAMICROSS,
    CDLHIGHWAVE,
    CDLHIKKAKE,
    CDLHIKKAKEMOD,
    CDLHOMINGPIGEON,
    CDLIDENTICAL3CROWS,
    CDLINNECK,
    CDLINVERTEDHAMMER,
    CDLKICKING,
    CDLKICKINGBYLENGTH,
    CDLLADDERBOTTOM,
    CDLLONGLEGGEDDOJI,
    CDLLONGLINE,
    CDLMARUBOZU,
    CDLMATCHINGLOW,
    CDLMATHOLD,
    CDLMORNINGDOJISTAR,
    CDLMORNINGSTAR,
    CDLONNECK,
    CDLPIERCING,
    CDLRICKSHAWMAN,
    CDLRISEFALL3METHODS,
    CDLSEPARATINGLINES,
    CDLSHOOTINGSTAR,
    CDLSHORTLINE,
    CDLSPINNINGTOP,
    CDLSTALLEDPATTERN,
    CDLSTICKSANDWICH,
    CDLTAKURI,
    CDLTASUKIGAP,
    CDLTHRUSTING,
    CDLTRISTAR,
    CDLUNIQUE3RIVER,
    CDLUPSIDEGAP2CROWS,
    CDLXSIDEGAP3METHODS,
    CEIL,
    CMO: CMO$1,
    CORREL,
    COS,
    COSH,
    DEMA,
    DIV,
    DX: DX$1,
    EMA: EMA$1,
    EXP,
    FLOOR,
    HT_DCPERIOD,
    HT_DCPHASE,
    HT_PHASOR,
    HT_SINE,
    HT_TRENDLINE,
    HT_TRENDMODE,
    IMI,
    KAMA,
    LINEARREG,
    LINEARREG_ANGLE,
    LINEARREG_INTERCEPT,
    LINEARREG_SLOPE,
    LN,
    LOG10,
    MA: MA$1,
    MACD: MACD$1,
    MACDEXT,
    MACDFIX,
    MAMA,
    MAVP,
    MAX,
    MAXINDEX,
    MEDPRICE,
    MFI: MFI$1,
    MIDPOINT,
    MIDPRICE,
    MIN,
    MININDEX,
    MINMAX,
    MINMAXINDEX,
    MINUS_DI,
    MINUS_DM,
    MOM,
    MULT,
    NATR,
    OBV: OBV$1,
    PLUS_DI,
    PLUS_DM,
    PPO: PPO$1,
    ROC: ROC$1,
    ROCP,
    ROCR,
    ROCR100,
    RSI: RSI$1,
    SAR,
    SAREXT,
    SIN,
    SINH,
    SMA: SMA$1,
    SQRT,
    STDDEV,
    STOCH: STOCH$1,
    STOCHF,
    STOCHRSI: STOCHRSI$1,
    SUB,
    SUM,
    T3,
    TAN,
    TANH,
    TEMA,
    TRANGE,
    TRIMA,
    TRIX,
    TSF,
    TYPPRICE,
    ULTOSC,
    VAR,
    WCLPRICE,
    WILLR,
    WMA,
};

function error(f, e, o) {
    throw new Error(`${f} ${e}`, o);
}
function typeError(f, t, e) {
    throw new TypeError(`${f} received ${t}, expected type ${e}`);
}

function provideEventListeners(selector, listeners) {
    const func = (el) => {
        const elm = el.querySelector(selector);
        if (!!elm) {
            for (let l of listeners) {
                elm.addEventListener(l.event, (e) => {
                    l.fn(e);
                });
            }
        }
    };
    return func;
}

function populateMetaInputs(def) {
    let input = def.input;
    let metaIn = def.meta.input;
    for (let i in metaIn) {
        metaIn[i].value = input[i];
    }
}
function dataOldDefault(entries) {
    if (isArray(entries)) {
        for (let entry of entries) {
            dataOldDefault(entry);
        }
    }
    else if (isObject(entries)) {
        for (let field in entries) {
            let f = (isObject(entries[field])) ? entries[field] : entries;
            let keys = Object.keys(f);
            if (!keys.includes("data-oldval"))
                f["data-oldval"] = f?.value;
            if (!keys.includes("data-default")) {
                f["data-default"] = (!!f?.default) ?
                    f?.default :
                    f?.value;
            }
        }
    }
}
function configField(i, label, type, value, defaultValue, min, max, fn, title, options) {
    defaultValue = defaultValue || value;
    title = title || label;
    if (isNumber(min) && isNumber(max) && min > max) {
        [max, min] = [min, max];
    }
    else if (isNumber(min) && isNumber(max)) {
        value = limit(value, min, max);
    }
    let f = {
        entry: i,
        label,
        type,
        value,
        default: defaultValue,
        "data-oldval": value,
        "data-default": defaultValue,
        $function: fn,
        title
    };
    if (isNumber(min))
        f.min = min;
    if (isNumber(max))
        f.max = max;
    if (isObject(options) && Object.keys(options).length)
        f.options = options;
    return f;
}
function fieldTargetUpdate(target, value, style) {
    for (let e in style) {
        for (let o in style[e]) {
            if (isObject(style[e][o]) && style[e][o].entry == target) {
                style[e][o]["data-oldval"] = style[e][o].value;
                style[e][o].value = value;
            }
        }
    }
}
function validateInputs(d, s, api) {
    const input = { ...d.input, ...s };
    delete input.style;
    d.input = input;
    for (let def of api.options) {
        if (!(def.name in d.input))
            d.input[def.name] = api.options[def.name];
    }
    validate(d.input, api.options, d);
}
function validate(src, def, d) {
    let dm = d.meta;
    let val;
    for (let f of def) {
        val = (typeof src[f.name] == "object") ?
            src[f.name]?.value :
            src[f.name];
        src[f.name] = (typeof val !== f.type) ?
            f.defaultValue : val;
        if ("range" in def)
            src[f.name] = limit(src[f.name], f.range.min, f.range.max);
        const n = configField(f?.name, f?.displayName, f?.type, src[f.name], f?.defaultValue, f?.range?.min, f?.range?.max, undefined, f?.hint);
        dm.input[f.name] = { ...n, ...dm.input[f.name] };
    }
}
function validateOutputs(d, api, oo) {
    if (Object.keys(d.output).length == 0) {
        for (let o of api.outputs) {
            d.output[o.name] = [];
        }
    }
    let doo = true;
    if (Object.keys(d.meta.output).length > 0) {
        doo = false;
        for (let o of d.meta.output) {
            if (isObject(o))
                oo.push(o.name);
        }
    }
    for (let o in d.output) {
        if (!isArray(d.output[o]))
            d.output[o] = [];
        if (doo)
            oo.push(o);
    }
}

const DEFAULT_PERIOD = 5;
const OUTPUTEXTRAS = [
    "highLowRange"
];
const IGNORE_DEFINITIONS = ["outputLegend", "outputOrder", "render", "style"];
const palette = new Palette();
class Context {
    static { this.standard = new Context("standard"); }
    static { this.subcomponent = new Context("subcomponent"); }
    constructor(name) {
        this.name = name;
    }
}
class IndicatorState {
    static { this.noData = new IndicatorState("noData"); }
    static { this.hasData = new IndicatorState("hasData"); }
    static { this.error = new IndicatorState("error"); }
    static { this.destroyed = new IndicatorState("destroyed"); }
    constructor(name) {
        this.name = name;
    }
}
class InputPeriodEnable {
    #enable = true;
    #period = DEFAULT_PERIOD;
    constructor(enable = true, period = 5) {
        this.enable = enable;
        this.period = (isInteger(period)) ? period : 5;
    }
    set enable(e) { this.#enable = (isBoolean(e)) ? e : true; }
    get enable() { return this.#enable; }
    set period(p) { this.#period = (isInteger(p)) ? p : 5; }
    get period() { return this.#period; }
}
class Indicator extends Overlay {
    static #cnt = 0;
    static get cnt() { return ++Indicator.#cnt; }
    static get isIndicator() { return true; }
    static { this.definition = {
        input: {},
        output: {},
        meta: {
            input: {},
            output: [],
            outputOrder: [],
            outputLegend: {},
            style: {}
        }
    }; }
    #ID;
    #cnt_;
    #key;
    #name;
    #shortName;
    #type;
    #context;
    #legendID;
    #legendName;
    #legendVisibility;
    #primaryPane;
    #chartPane;
    #overlay;
    #scaleOverlay;
    #indicator;
    #TALib;
    #range;
    #value;
    #newValueCB;
    #updateValueCB;
    #precision;
    #timePeriod;
    #status;
    #ConfigDialogue;
    #style;
    #palette;
    #plots;
    #gapFill;
    #error;
    constructor(target, xAxis = false, yAxis = false, config, parent, params) {
        super(target, xAxis, yAxis, undefined, parent, params);
        this.#type = "indicator";
        this.#value = [0, 0];
        this.#precision = 2;
        this.#status = IndicatorState.noData;
        this.#style = {};
        this.#gapFill = true;
        this.#error = { type: "", msg: "", style: "" };
        this.definition = doStructuredClone(Indicator.definition);
        this.colours = [
            palette.colours[8],
            palette.colours[18],
            palette.colours[28],
            palette.colours[38],
            palette.colours[48],
        ];
        if (!isObject(this.definition))
            error(`Indicator: ${this.shortName}`, `does not provide a valid definition`);
        const overlay = params.overlay;
        this.#cnt_ = Indicator.cnt;
        this.#overlay = overlay;
        this.id = overlay?.id || uid(this?.shortName || overlay?.name);
        this.#key = overlay?.key || indicatorHashKey(overlay);
        this.#TALib = this.core.TALib;
        this.#range = this.core.range;
        this.legendName = overlay?.legendName || overlay?.name || this?.shortName;
        this.#legendVisibility = (isBoolean(overlay?.legendVisibility)) ? overlay.legendVisibility : true;
        this.#gapFill = (isBoolean(overlay?.gapFill)) ? overlay.gapFill : true;
        this.#palette = palette;
        this.style = (isObject(overlay?.settings?.style)) ?
            { ...this.constructor.defaultStyle, ...overlay.settings.style } :
            { ...this.constructor.defaultStyle, ...config.style };
        const cfg = { title: `${this.legendName} Config`, content: "", params: overlay, parent: this };
        this.#ConfigDialogue = this.core.WidgetsG.insert("ConfigDialogue", cfg);
        switch (overlay.settings?.context) {
            case "subcomponent": this.#context = Context.subcomponent;
            case "standard":
            default: this.#context = Context.standard;
        }
    }
    get id() { return this.#ID || `${this.core.ID}-${this.chartPaneID}-${this.shortName}-${this.#cnt_}`; }
    set id(id) { this.#ID = idSanitize(new String(id)); }
    get key() { return this.#key; }
    get version() { return `${this.constructor?.version}`; }
    get context() { return this.#context; }
    get chartPane() { return this.getChartPane(); }
    get chartPaneID() { return this.params.overlay.paneID; }
    get primaryPane() { return this.#primaryPane || this.constructor.primaryPane; }
    set primaryPane(c) { this.#primaryPane = c; }
    get scaleOverlay() { return this.#scaleOverlay; }
    set scaleOverlay(o) { this.#scaleOverlay = o; }
    get plots() { return this.#plots; }
    set plots(p) { this.#plots = p; }
    get Timeline() { return this.core.Timeline; }
    get scale() { return this.parent.scale; }
    get type() { return this.#type; }
    get overlay() { return this.#overlay; }
    get legend() { return this.chart.legend.list[this.#legendID]; }
    get legendID() { return this.#legendID; }
    get legendName() { return this.#legendName || this.overlay?.name || this?.shortName || this.#ID; }
    set legendName(n) { this.setLegendName(n); }
    set legendVisibility(v) { this.setLegendVisibility(v); }
    get indicator() { return this.#indicator; }
    get TALib() { return this.#TALib; }
    get range() { return this.core.range; }
    set setNewValue(cb) { this.#newValueCB = cb; }
    set setUpdateValue(cb) { this.#updateValueCB = cb; }
    set precision(p) { this.#precision = p; }
    get precision() { return this.#precision; }
    set style(s) { if (isObject(s))
        this.#style = s; }
    get style() { return this.#style; }
    set position(p) { this.target.setPosition(p[0], p[1]); }
    get isIndicator() { return Indicator.isIndicator; }
    get isPrimary() { return this.chart.isPrimary; }
    set status(s) { if (s instanceof IndicatorState)
        this.#status = s; }
    get status() { return this.#status; }
    set error(e) { this.setError(e); }
    get error() { return this.#error; }
    get gapFill() { return this.#gapFill; }
    set gapFill(g) { this.#gapFill = !!g; }
    get configDialogue() { return this.#ConfigDialogue; }
    set value(data) {
        const tfms = this.core.timeData.timeFrameMS;
        let roundedTime = Math.floor(new Date(data[OHLCV.t]) / tfms) * tfms;
        data[OHLCV.t] = roundedTime;
        if (this.#value[OHLCV.t] !== data[OHLCV.t]) {
            this.#value[OHLCV.t] = data[OHLCV.t];
            this.#newValueCB(data);
        }
        else {
            this.#updateValueCB(data);
        }
    }
    get value() {
        return this.#value;
    }
    getChartPane() {
        if (!this.#chartPane) {
            this.#chartPane = this.core.ChartPanes.get(this.chartPaneID);
        }
        return this.#chartPane;
    }
    setError(e) {
        if (this.#status === IndicatorState.destroyed)
            return false;
        if (!isObject(e) &&
            !isString(e?.type) &&
            !isString(e?.msg)) {
            this.core.warn(`WARNING: Indicator: ${this.shortName} ID: ${this.id} setError() recieved invalid error object`);
        }
        const err = { ...e };
        err.indicator = this;
        this.#error = e;
        this.#status = IndicatorState.error;
        this.emit("indicator_error", err);
        this.core.warn(`WARNING: Indicator: ${this.shortName} ID: ${this.id} ${err.msg}`);
    }
    setLegendName(name) {
        this.#legendName = (isString(name)) ? name : this.overlay?.name || this.shortName || this.#ID;
        this.chart.legend.modify(this.#legendID, { legendName: this.#legendName });
    }
    setLegendVisibility(v) {
        this.#legendVisibility = !!v;
        this.chart.legend.modify(this.#legendID, { legendVisibility: !!v });
    }
    setDefinitionValue(d, v) {
        let defs = Object.keys(this.definition.input);
        if (defs.includes(d)) {
            this.definition.input[d] = v * 1;
            this.getTimePeriod(true);
            return "input";
        }
        defs = Object.keys(this.style);
        if (defs.includes(d)) {
            this.style[d] = v;
            return "style";
        }
    }
    init(api) {
        const overlay = this.params.overlay;
        this.defineIndicator(overlay, api);
        this.calcIndicatorHistory();
        this.setNewValue = (value) => { this.newValue(value); };
        this.setUpdateValue = (value) => { this.updateValue(value); };
        if (this.#context === Context.standard) {
            this.addLegend();
            this.#ConfigDialogue.start();
            this.eventsListen();
            this.setRefresh();
        }
    }
    destroy(state = true) {
        if (this.#status === IndicatorState.destroyed)
            return;
        if (!this.chartPane.indicatorDeleteList[this.id]) {
            this.core.warn(`Cannot "destroy()": ${this.id} !!! Use "indicator.remove()" or "chart.removeIndicator()" instead.`);
            return;
        }
        this.core.hub.expunge(this);
        this.chart.legend.remove(this.#legendID);
        this.clear();
        this.core.MainPane.draw(undefined, true);
        this.chartPane.graph.removeOverlay(this.id);
        this.#newValueCB = null;
        this.#updateValueCB = null;
        this.#ConfigDialogue = null;
        super.destroy();
        if (!!state)
            this.core.state.removeIndicator(this.id);
        this.#status = IndicatorState.destroyed;
    }
    remove() {
        this.core.log(`Deleting indicator: ${this.id} from: ${this.chartPaneID}`);
        if (this.chart.type === "primaryPane" ||
            Object.keys(this.chart.indicators).length > 1) {
            this.emit(`${this.chartPaneID}_removeIndicator`, { id: this.id, paneID: this.chartPaneID });
        }
        else
            this.chart.remove();
    }
    snapshot() {
        return {
            id: this.id,
            key: this.key,
            name: this.params.overlay.name,
            type: this.shortName,
            data: this.data,
            settings: this.definition
        };
    }
    dataProxy(fn, target = []) {
        const range = this.range;
        const state = this.core.state;
        const output = this.definition.meta.output;
        const data = [];
        const dummy = new Array(output.length + 1);
        dummy.fill(0);
        let length = range.dataLength;
        for (let i = 0; i <= length; i++) {
            dummy[0] = range.data[i][0];
            data[i] = Array.from(dummy);
        }
        if (isFunction(fn))
            fn(data, state, range);
        this.data.length = 0;
        for (let d of data) {
            this.data.push(d);
        }
    }
    visible(v) {
        if (isBoolean(v)) {
            this.emit(`${this.chartPaneID}_visibleIndicator`, { id: this.id, paneID: this.chartPaneID, visible: v });
            this.chartPane.indicators[this.id].layer.visible = v;
            this.draw();
        }
        return this.chartPane.indicators[this.id].layer.visible;
    }
    settings(s) {
        if (isObject(s)) {
            if (isObject(s?.config))
                this.params.overlay.settings =
                    mergeDeep(this.params.overlay.settings, s.config);
            if (isObject(s?.style))
                this.style =
                    mergeDeep(this.style, s.style);
            this.draw();
        }
        return {
            config: this.params.overlay.settings,
            style: this.style,
            defaultStyle: this?.defaultStyle,
            plots: this.plots,
            precision: this.precision,
            definition: this.definition,
        };
    }
    eventsListen() {
        this.on(STREAM_UPDATE, this.onStreamUpdate, this);
        this.on(`window_opened_${this.id}`, this.onConfigDialogueOpen, this);
        this.on(`window_closed_${this.id}`, this.onConfigDialogueCancel, this);
        this.on(`window_submit_${this.id}`, this.onConfigDialogueSubmit, this);
        this.on(`window_cancel_${this.id}`, this.onConfigDialogueCancel, this);
        this.on(`window_default_${this.id}`, this.onConfigDialogueDefault, this);
    }
    on(topic, handler, context = this) {
        this.core.on(topic, handler, context);
    }
    off(topic, handler, context = this) {
        this.core.off(topic, handler, context);
    }
    emit(topic, data) {
        this.core.emit(topic, data);
    }
    onStreamNewValue(value) {
    }
    onStreamUpdate(candle) {
        this.value = candle;
    }
    onLegendAction(e) {
        const action = this.chart.legend.onPointerClick(e.currentTarget);
        switch (action.icon) {
            case "up": return;
            case "down": return;
            case "visible":
                this.onVisibility(action);
                return;
            case "notVisible":
                this.onVisibility(action);
                return;
            case "remove":
                this.remove();
                return;
            case "config":
                this.invokeSettings();
                return;
            default: return;
        }
    }
    onVisibility(action) {
        this.setRefresh();
        this.visible(!this.visible());
        action.parent.classList.toggle("visible");
        action.parent.classList.toggle("notvisible");
    }
    onConfigDialogueOpen(d) {
        if (this.#ConfigDialogue.state === WinState.opened)
            return;
        this.#ConfigDialogue.setOpen();
        const fields = this.#ConfigDialogue.contentFields;
        for (let field in fields) {
            for (let f of fields[field]) {
                if (f.classList.contains("subject")) {
                    if (f.getAttribute("data-oldval") !== f.value) {
                        f.setAttribute("data-oldval", f.value);
                    }
                }
            }
        }
    }
    onConfigDialogueSubmit(d) {
        this.#ConfigDialogue.setClose();
        let r, calc = false;
        const fields = this.#ConfigDialogue.contentFields;
        for (let field in fields) {
            for (let f of fields[field]) {
                if (f.classList.contains("subject")) {
                    f.setAttribute("data-oldval", f.value);
                    r = this.setDefinitionValue(f.id, f.value);
                    calc = calc || (r == "input");
                }
            }
        }
        if (calc) {
            this.clear();
            this.overlay.data.length = 0;
            this.calcIndicatorHistory();
        }
        this.setRefresh();
        this.draw();
        this.core.refresh();
    }
    onConfigDialogueCancel(d) {
        this.#ConfigDialogue.setClose();
        const fields = this.#ConfigDialogue.contentFields;
        for (let field in fields) {
            for (let f of fields[field]) {
                if (f.classList.contains("subject")) {
                    f.value = f.getAttribute("data-oldval");
                }
            }
        }
        this.setRefresh();
        this.draw();
    }
    onConfigDialogueDefault(d) {
        const fields = this.#ConfigDialogue.contentFields;
        for (let field in fields) {
            for (let f of fields[field]) {
                if (f.classList.contains("subject")) {
                    let dataDefault = f.getAttribute("data-default");
                    f.value = dataDefault;
                    this.style[f.id] = dataDefault;
                }
            }
        }
        this.calcIndicatorHistory();
        this.setRefresh();
        this.draw();
    }
    invokeSettings(c = {}) {
        let r;
        if (isFunction(c?.fn)) {
            r = c.fn(this);
            if (c?.own)
                return r;
        }
        else if (isFunction(this.core.config.callbacks?.indicatorSettings?.fn)) {
            r = this.core.config.callbacks.indicatorSettings.fn(this);
            if (this.core.config.callbacks?.indicatorSettings?.own)
                return r;
        }
        this.core.log(`invokeSettings: ${this.id}`);
        const cd = this.#ConfigDialogue;
        if (cd.update) {
            if (!isFunction(this.configInputs)) {
                this.core.error(`ERROR: Indicator ${this.name} does not provide configInputs() required for the settings dialogue`);
                return false;
            }
            const configTabs = this.configInputs();
            const { html, modifiers } = cd.configBuild(configTabs);
            const title = `${this.shortName} Config`;
            cd.setTitle(title);
            cd.setContent(html, modifiers);
            cd.update = false;
        }
        if (cd.state.name === "closed")
            cd.open();
        else
            cd.setOpen();
        return true;
    }
    configInputs() {
        const name = this.name || this.shortName || this.id;
        const noConfig = `Indicator ${name} is not configurable.`;
        const noTabs = { "No Config": { tab1: noConfig } };
        let tabs = {};
        let meta = this?.definition?.meta;
        if (!isObject(meta) &&
            !isObject(this?.style) &&
            !isObject(this?.definition?.input))
            return noTabs;
        for (let tab in meta) {
            if (IGNORE_DEFINITIONS.includes(tab))
                continue;
            tabs[tab] = meta[tab];
        }
        if (Object.keys(tabs).length == 0)
            tabs = noTabs;
        else {
            for (let tab in tabs) {
                dataOldDefault(tabs[tab]);
            }
        }
        return tabs;
    }
    fieldEventChange() {
        let style = this.definition.meta.style;
        return {
            event: "change",
            fn: (e) => {
                fieldTargetUpdate(e.target.id, e.target.value, style);
                this.setRefresh();
                this.draw();
            }
        };
    }
    defineIndicator(settings, api) {
        let input = this.retrieveInput(settings);
        api = (isObject(api)) ? api : { outputs: [], options: [] };
        const definition = doStructuredClone(Indicator.definition);
        if (!isObject(this.definition))
            this.definition = definition;
        this.definition = mergeDeep(definition, this.definition);
        let d = this.definition;
        let dm = d.meta;
        let oo = [];
        let out = talibAPI?.[this.libName]?.outputs || [];
        d.input = (!isObject(d.input)) ? input : { ...d.input, ...input };
        d.output = (!isObject(d.output)) ? {} : d.output;
        dm = (!isObject(dm)) ? definition.meta : dm;
        dm.input = (!isObject(dm.input)) ? {} : dm.input;
        dm.output = (!isArray(dm.output) || !dm.output.length) ? out : [...out, ...dm.output];
        dm.outputOrder = (!isArray(dm.outputOrder)) ? [] : dm.outputOrder;
        dm.outputLegend = (!isObject(dm.outputLegend)) ? {} : dm.outputLegend;
        if (!isObjectNotEmpty(dm.style))
            dm.style = this.style || {};
        validateInputs(d, input, api);
        populateMetaInputs(d);
        validateOutputs(d, api, oo);
        this.buildOutputOrder(dm, oo, OUTPUTEXTRAS);
        this.buildOutputLegends(d);
        this.buildConfigOutputTab(dm);
    }
    retrieveInput(settings) {
        if (isObject(settings?.input))
            return settings.input;
        else if (isObject(settings?.settings?.input))
            return settings.settings.input;
        else
            return {};
    }
    buildOutputOrder(dm, oo, extras) {
        let u = [...new Set([...dm.outputOrder, ...oo])];
        let del = diff(u, oo);
        for (let x of del) {
            if (extras.includes(x))
                continue;
            let idx = u.indexOf(x);
            u.splice(idx, 1);
        }
        dm.outputOrder = u;
    }
    buildOutputLegends(d) {
        let dm = d.meta;
        Object.keys(d.output);
        for (let [k, v] of Object.entries(dm.outputLegend)) {
            if (!isObject(v)) {
                dm.outputLegend[k] = {};
            }
            if (!isString(dm.outputLegend[k].labelStr)) {
                dm.outputLegend[k].label = false;
                dm.outputLegend[k].labelStr = "";
            }
            if (!isBoolean(dm.outputLegend[k].label))
                dm.outputLegend[k].label = false;
            if (!isBoolean(dm.outputLegend[k].value))
                dm.outputLegend[k].value = false;
        }
    }
    buildConfigOutputTab(dm) {
        for (let i in dm.style) {
            if (typeof dm.style[i] !== "object")
                delete dm.style[i];
        }
        for (let x = 0; x < dm.output.length; x++) {
            let o = dm.output[x];
            let t = plotFunction(o?.plot);
            switch (t) {
                case "renderLine":
                    o.style = this.defaultMetaStyleLine(o, x, dm.style);
                    break;
                case "histogram":
                    o.style = this.defaultMetaStyleHistogram(o, x, dm.style);
                    break;
                case "highLow": return "highLow";
            }
        }
    }
    defaultMetaStyleLine(o, x, style) {
        let value;
        let fns = {
            change: this.fieldEventChange(),
            provideInputColour: this.#ConfigDialogue.provideInputColor
        };
        o.name = (!o?.name) ? "output" : o.name;
        if (!isObject(style?.[o.name]))
            style[o.name] = {};
        let c = new Colour(style[o.name]?.colour?.value);
        if (!c.isValid) {
            let k = this.colours.length;
            value = (x <= k) ? this.colours[x] : this.colours[k % x];
        }
        else {
            value = c.value.hexa;
        }
        style[o.name].colour = this.defaultOutputField(`${o.name}Colour`, `${o.name} Colour`, value, "color", fns);
        if (!isNumber(style[o.name]?.width?.value))
            value = 1;
        else
            value = style[o.name]?.width.value;
        style[o.name].width = this.defaultOutputField(`${o.name}Width`, `${o.name} Width`, value, "number", 0);
        if ("dash" in style[o.name] && (!!style[o.name].dash)) {
            value = style[o.name]?.dash?.value;
            style[o.name].dash = this.defaultOutputField(`${o.name}dash`, `${o.name} Dash`, value, "dash", undefined, undefined);
        }
        return style[o.name];
    }
    defaultMetaStyleHistogram(o, x, style) {
        let value;
        let fns = {
            change: this.fieldEventChange(),
            provideInputColour: this.#ConfigDialogue.provideInputColor
        };
        o.name = (!o?.name) ? "output" : o.name;
        if (!isObject(style?.[o.name]))
            style[o.name] = {};
        let c = new Colour(style[o.name]?.dnFill?.value);
        if (!c.isValid) {
            value = "#f00";
        }
        else {
            value = c.value.hexa;
        }
        style[o.name].dnFill = this.defaultOutputField(`${o.name}ColourDn`, `${o.name} Colour Dn`, value, "color", fns);
        style[o.name].dnStroke = style[o.name].dnFill;
        c = new Colour(style[o.name]?.upFill?.value);
        if (!c.isValid) {
            value = "#0f0";
        }
        else {
            value = c.value.hexa;
        }
        style[o.name].upFill = this.defaultOutputField(`${o.name}ColourUp`, `${o.name} Colour Up`, value, "color", fns);
        style[o.name].upStroke = style[o.name].upFill;
        return style[o.name];
    }
    defaultOutputField(id, label, value, type, min, max, defaultValue) {
        let fn, listeners, options;
        let change = this.fieldEventChange();
        switch (type) {
            case "number":
                listeners = [change];
                fn = (el) => {
                    provideEventListeners(`#${id}`, listeners)(el);
                };
                break;
            case "color":
                listeners = [change, over, out];
                fn = (el) => {
                    this.#ConfigDialogue.provideInputColor(el, `#${id}`);
                    provideEventListeners(`#${id}`, listeners)(el);
                };
                type = "text";
                break;
            case "dash":
                listeners = [change];
                fn = (el) => {
                    provideEventListeners(`#${id}`, listeners)(el);
                };
                type = "select";
                let patterns = {};
                for (let d in dashedPatterns) {
                    patterns[d] = dashedPatterns[d].toString();
                }
                options = patterns;
                break;
        }
        return configField(id, label, type, value, value, min, max, fn, label, options);
    }
    defaultColour() {
        return "#fff";
    }
    addLegend() {
        let legend = {
            id: this.id,
            title: this.legendName,
            visible: this.#legendVisibility,
            type: "indicator",
            parent: this,
            source: this.legendInputs.bind(this)
        };
        this.#legendID = this.chart.legend.add(legend);
    }
    legendInputs(pos = this.chart.cursorPos) {
        if (this.overlay.data.length == 0)
            return false;
        const labels = [];
        const colours = [];
        const inputs = {};
        const index = this.Timeline.xPos2Index(pos[0]);
        const len = this.overlay.data.length;
        this.definition.meta.outputOrder;
        this.definition.meta.outputLegend;
        let c = index - (this.range.data.length - len);
        let l = limit(len - 1, 0, Infinity);
        c = limit(c, 0, l);
        let i = 0;
        for (let o of this.definition.meta.output) {
            let entry = this.overlay.data[c];
            if (o.type == "overlay" ||
                !isArray(entry) ||
                entry.length == 0)
                continue;
            labels[i] = false;
            inputs[o.name] = this.scale.nicePrice(this.overlay.data[c][i + 1]);
            if (o.plot == "histogram") {
                if (this.overlay.data[c][i + 1] < 0)
                    colours[i] = this.definition.meta.style?.[o.name].dnStroke;
                else
                    colours[i] = this.definition.meta.style?.[o.name].upStroke;
            }
            else
                colours[i] = this.definition.meta.style?.[o.name]?.colour?.value || "#ccc";
            i++;
        }
        return { inputs, colours, labels };
    }
    indicatorInput(start, end) {
        let gaps = this.core.state.gaps.list;
        let raw, val;
        let input = {
            inReal: [],
            open: [],
            high: [],
            low: [],
            close: [],
            volume: []
        };
        do {
            raw = this.range.value(start);
            if (this.#gapFill && `${raw[0]}` in gaps) {
                val = gaps[`${raw[0]}`];
            }
            else
                val = raw;
            input.inReal.push(val[OHLCV.c]);
            input.open.push(val[OHLCV.o]);
            input.high.push(val[OHLCV.h]);
            input.low.push(val[OHLCV.l]);
            input.close.push(val[OHLCV.c]);
            input.volume.push(val[OHLCV.v]);
        } while (start++ < end);
        return input;
    }
    regeneratePlots(params) {
        return params.map((_, index) => {
            const num = index + 1;
            return {
                key: `${this.shortName}${num}`,
                title: `${this.shortName}${num}: `,
                type: 'line'
            };
        });
    }
    getTimePeriod(update = false) {
        if (update || !isNumber(this.#timePeriod)) {
            let period = 0;
            let def = this.definition.input;
            let multiply = (!!this.constructor?.timePeriodMultiplier) ? 2 : 1;
            if ("timePeriod" in def)
                period = def.timePeriod * multiply;
            else {
                for (let i in def) {
                    if (isInteger(def[i]) && def[i] > period)
                        period = def[i];
                }
                period *= multiply;
            }
            this.#timePeriod = period;
        }
        return this.#timePeriod;
    }
    TALibParams() {
        let end = this.range.dataLength;
        let step = this.getTimePeriod();
        let start = end - step;
        let input = this.indicatorInput(start, end);
        let hasNull = input.inReal.find(element => element === null);
        if (hasNull)
            return false;
        else
            return { timePeriod: step, ...input };
    }
    formatValue(entry) {
        let v = [];
        let i = 0;
        for (let o in this.definition.output) {
            v[i++] = entry[o][0];
        }
        return v;
    }
    noCalc(indicator, range = this.range) {
        return this.chart.status == 'destroyed' ||
            !this.core.TALibReady ||
            !isString(indicator) ||
            !(indicator in this.TALib) ||
            !isObject(range) ||
            range.dataLength < this.getTimePeriod();
    }
    noCalcCustom(indicator, range = this.range) {
        return this.chart.status == 'destroyed' ||
            !this.core.TALibReady ||
            !isFunction(indicator) ||
            !isObject(range) ||
            range.dataLength < this.getTimePeriod();
    }
    calcIndicator(indicator, params = {}, range, update) {
        return new Promise((resolve, reject) => {
            let indicatorFn = this.TALib[String(indicator)];
            if (!this.noCalcCustom(indicator))
                indicatorFn = indicator;
            else if (!this.noCalc(indicator, range))
                indicatorFn = this.TALib[indicator];
            else {
                this.core.warn(`Invalid indicator function: ${indicator}`);
                resolve(false);
            }
            let d = this.getTimePeriod();
            let start, end;
            let p = d;
            let t = p + (params?.padding || 0);
            let od = this.overlay.data;
            if (range instanceof Range) {
                start = 0;
                end = range.dataLength - t + 1;
            }
            else if (isObject(range)) {
                start = range?.indexStart || this.Timeline.t2Index(range?.tsStart || 0) || 0;
                end = range?.indexEnd || this.Timeline.t2Index(range?.tsEnd) || range.dataLength - t + 1;
            }
            else
                resolve(false);
            if (!isArray(od))
                resolve(false);
            else if (od.length == 0) ;
            else if (od.length + t !== range.dataLength) {
                if (od[0][0] > range.value(t)[0]) {
                    start = 0;
                    end = range.getTimeIndex(od[0][0]) - t;
                    end = limit(end, t, range.dataLength - 1);
                }
                else if (od[od.length - 1][0] < range.value(range.dataLength - 1)[0]) {
                    start = od.length - 1 + t;
                    start = limit(start, 0, range.dataLength);
                    end = range.dataLength - 1;
                }
                else
                    resolve(false);
            }
            else if (isArrayOfType(update, "integer")) {
                start = this.Timeline.t2Index(update[0]);
                end = this.Timeline.t2Index(update[update.length - 1]) - t;
                if (end - start < t)
                    start = (start - t < 0) ? 0 : start - t;
            }
            else
                resolve(false);
            if (end < t) {
                this.setError({ type: "noData", msg: "Insufficient input data" });
                resolve(false);
            }
            if (end - start < t) {
                start -= (t + p) - (end - start);
            }
            let data = [];
            let entry, input, value;
            while (start < end) {
                input = this.indicatorInput(start, start + t);
                params = { ...params, ...input };
                entry = indicatorFn(params);
                value = this.formatValue(entry);
                data.push([range.value(start + p - 1)[0], ...value]);
                start++;
            }
            resolve(data);
        });
    }
    calcIndicatorHistory(update) {
        const calc = async () => {
            try {
                const data = await this.calcIndicator(this.libName, this.definition.input, this.range, update);
                if (isArray(data)) {
                    this.#processIndicatorData(data);
                }
                else
                    throw new Error(`Indicator ${this.libName} did not return an array`);
            }
            catch (error) {
                this.setError({
                    type: "calculation",
                    msg: `Failed to calculate indicator history: ${error.message}`
                });
            }
        };
        if (this.core.TALibReady)
            calc();
        else
            this.core.talibAwait.push(calc.bind(this));
    }
    #processIndicatorData(data) {
        let od = this.overlay.data;
        if (isArray(data)) {
            new Set(data);
            new Set(od);
            let a, p, r = {};
            if (!isArray(od) ||
                od.length == 0) {
                this.overlay.data = data;
                return;
            }
            else if (!data.length)
                return;
            else if (data[0][0] < od[0][0]) {
                a = data;
                p = od;
            }
            else if (data[data.length - 1][0] > od[od.length - 1][0]) {
                a = od;
                p = data;
            }
            else {
                a = od;
                p = data;
            }
            for (let v of a) {
                r[v[0]] = v;
            }
            for (let v of p) {
                r[v[0]] = v;
            }
            this.overlay.data = Object.values(r);
            this.#status = IndicatorState.hasData;
            this.setRefresh();
            this.scale.draw(this.range, true);
        }
    }
    calcIndicatorStream(indicator, params, range = this.range) {
        if (!(range instanceof Range))
            return false;
        let indicatorFn;
        if (!this.noCalcCustom(indicator))
            indicatorFn = indicator;
        else if (!this.noCalc(indicator, range))
            indicatorFn = this.TALib[indicator];
        else
            return false;
        let entry = indicatorFn(params);
        let time = range.value()[0];
        let value = this.formatValue(entry);
        return [time, ...value];
    }
    newValue(value) {
        this.#setValue((v) => this.overlay.data.push(v));
    }
    updateValue(value) {
        this.#setValue((v) => {
            let l = this.overlay.data.length - 1;
            this.overlay.data[l] = v;
        });
    }
    #setValue(fn) {
        let p = this.TALibParams();
        if (!p)
            return false;
        let v = this.calcIndicatorStream(this.libName, p);
        if (!v)
            return false;
        fn(v);
        this.#status = IndicatorState.hasData;
        this.target.setPosition(this.core.scrollPos, 0);
        this.doDraw = true;
        this.draw(this.range);
    }
    plotInidicatorOutput(rangeLength, rangeIndex, plotIndex, renderFn, plotStyle) {
        const data = this.range.getDataById(this.id) || this.overlay.data;
        const width = this.xAxis.candleW;
        const zero = this.yAxis.yPos(0);
        const plot = { w: width, zero };
        const opts = {};
        let plots = [];
        while (rangeLength) {
            if (rangeIndex < 0 ||
                rangeIndex >= data.length ||
                !isArray(data[rangeIndex])) {
                plots.push({ x: null, y: null });
            }
            else {
                plot.x = this.xAxis.xPos(data[rangeIndex][0]);
                plot.y = this.yAxis.yPos(data[rangeIndex][plotIndex]);
                plots.push({ ...plot });
            }
            rangeIndex++;
            rangeLength--;
        }
        for (let key in plotStyle) {
            if (!!plotStyle[key]?.value)
                opts[key] = plotStyle[key].value;
        }
        this.plot(plots, renderFn, opts);
    }
    canIndicatorDraw() {
        return !(this.overlay.data.length < 2 ||
            !this.mustUpdate() ||
            !this.yAxis ||
            !this.state.isActive);
    }
    draw(range = this.range) {
        if (!this.canIndicatorDraw())
            return;
        this.clear();
        this.overlay.data;
        const meta = this.definition.meta;
        const plots = {};
        let timePeriod = this.getTimePeriod() * this.range.timeFrameMS;
        let rangeTimeMin = this.range.timeMin - timePeriod;
        let offset = this.Timeline.rangeScrollOffset;
        let rangeLen = range.Length + (offset * 2) + 2;
        let timeIndex = this.range.getTimeIndex(rangeTimeMin);
        let outputCnt = 1;
        if (!meta.output.length)
            return super.updated();
        for (let p of meta.output) {
            let r = plotFunction(p.plot);
            if (r)
                plots[p?.name] = { x: outputCnt++, r };
        }
        let oo = (meta?.outputOrder.length > 0) ?
            meta.outputOrder :
            Object.keys(plots);
        let q = oo.reverse();
        for (let p of q) {
            let style = this.formatStyle(this.definition.meta.style[p], p);
            this.plotInidicatorOutput(rangeLen, timeIndex, plots[p].x, plots[p].r, style);
        }
        this.target.viewport.render();
        super.updated();
    }
    formatStyle(style, plot) {
        let e, s = {};
        for (let entry in style) {
            e = entry.replace(plot, "").toLowerCase();
            switch (e) {
                case "colour":
                    e = "stroke";
                    break;
            }
            s[e] = style[entry];
        }
        return s;
    }
    updated() {
        this.setRefresh();
        super.updated();
    }
}
const PLOT_FUNCTIONS = {
    line: "renderLine",
    line_dash: "renderLine",
    limit_lower: "renderLine",
    limit_upper: "renderLine",
    histogram: "histogram",
    highLowRange: "highLowRange"
};
function plotFunction(type) {
    return PLOT_FUNCTIONS[type] || false;
}
const over = {
    event: "pointerover",
    fn: (e) => {
        e.target.style.border = "1px solid #f00;";
    }
};
const out = {
    event: "pointerout",
    fn: (e) => {
        e.target.style.border = "none;";
    }
};
function indicatorHashKey(params) {
    const objStr = JSON.stringify(params);
    const hash = cyrb53(objStr);
    return `${SHORTNAME}_Indicator_${hash}`;
}

let nameShort$s = "ADX";
let nameLong$s = 'Average Directional Movement Index';
class ADX extends Indicator {
    get name() { return nameLong$s; }
    get shortName() { return nameShort$s; }
    get libName() { return nameShort$s; }
    static { this.nameShort = nameShort$s; }
    static { this.nameLong = nameLong$s; }
    static { this.version = "1.0"; }
    static { this.inCnt = 0; }
    static { this.primaryPane = false; }
    static { this.scale = YAXIS_TYPE.percent; }
    static { this.defaultStyle = {
        output: {
            colour: { value: "#E91E63" },
            width: { value: 1 },
            dash: { value: [] },
        },
        highLowRange: {
            colour: { value: "#880E4F" },
            width: { value: 1 },
            dash: { value: [2, 2] },
            fill: { value: "#880E4F08" },
            high: { value: 75 },
            low: { value: 25 }
        }
    }; }
    static { this.timePeriodMultiplier = true; }
    constructor(target, xAxis = false, yAxis = false, config, parent, params) {
        super(target, xAxis, yAxis, config, parent, params);
        this.precision = 2;
        this.scaleOverlay = true;
        this.init(ADX$1);
    }
}

let nameShort$r = "ATR";
let nameLong$r = 'Average True Range';
class ATR extends Indicator {
    get name() { return nameLong$r; }
    get shortName() { return nameShort$r; }
    get libName() { return nameShort$r; }
    static { this.nameShort = nameShort$r; }
    static { this.nameLong = nameLong$r; }
    static { this.version = "1.0"; }
    static { this.inCnt = 0; }
    static { this.primaryPane = false; }
    static { this.scale = YAXIS_TYPE.relative; }
    static { this.defaultStyle = {
        output: {
            colour: { value: "#E91E63" },
            width: { value: 1 },
            dash: { value: [] },
        },
        highLowRange: {
            colour: { value: "#880E4F" },
            width: { value: 1 },
            dash: { value: [2, 2] },
            fill: { value: "#880E4F08" },
            high: { value: 75 },
            low: { value: 25 }
        }
    }; }
    constructor(target, xAxis = false, yAxis = false, config, parent, params) {
        super(target, xAxis, yAxis, config, parent, params);
        this.precision = 2;
        this.scaleOverlay = true;
        this.init(ATR$1);
    }
}

let nameShort$q = "AROON";
let nameLong$q = 'AROON';
class AROON extends Indicator {
    get name() { return nameLong$q; }
    get shortName() { return nameShort$q; }
    get libName() { return nameShort$q; }
    static { this.nameShort = nameShort$q; }
    static { this.nameLong = nameLong$q; }
    static { this.version = "1.0"; }
    static { this.inCnt = 0; }
    static { this.primaryPane = false; }
    static { this.scale = YAXIS_TYPE.percent; }
    static { this.defaultStyle = {
        aroonDown: {
            colour: { value: "#c89" },
            width: { value: 1 },
            dash: { value: "" },
        },
        aroonUp: {
            colour: { value: "#08c" },
            width: { value: 1 },
            dash: { value: "" },
        },
    }; }
    constructor(target, xAxis = false, yAxis = false, config, parent, params) {
        super(target, xAxis, yAxis, config, parent, params);
        this.definition = {
            input: {
                high: [],
                low: [],
                timePeriod: 14
            },
            output: {
                aroonDown: [],
                aroonUp: []
            }
        };
        this.precision = 2;
        this.scaleOverlay = true;
        this.init(AROON$1);
    }
}

let nameShort$p = "BB";
let nameLong$p = 'Bollinger Bands';
class BB extends Indicator {
    get name() { return nameLong$p; }
    static { this.nameShort = nameShort$p; }
    static { this.nameLong = nameLong$p; }
    static { this.version = "1.0"; }
    static { this.inCnt = 0; }
    static { this.primaryPane = true; }
    static { this.defaultStyle = {
        lowerBand: {
            colour: { value: "#08c" },
            width: { value: 1 },
            dash: { value: "" },
        },
        middleBand: {
            colour: { value: "#0080c088" },
            width: { value: 1 },
            dash: { value: [20, 5] },
        },
        upperBand: {
            colour: { value: "#08c" },
            width: { value: 1 },
            dash: { value: "" },
        },
        fill: {
            colour: { value: "#0080c044" },
        }
    }; }
    constructor(target, xAxis = false, yAxis = false, config, parent, params) {
        super(target, xAxis, yAxis, config, parent, params);
        this.shortName = nameShort$p;
        this.libName = 'BBANDS';
        this.definition = {
            input: {
                inReal: [],
                nbDevDn: 2,
                nbDevUp: 2,
                timePeriod: 20
            },
            output: {
                lowerBand: [],
                middleBand: [],
                upperBand: []
            },
            meta: {}
        };
        this.precision = 2;
        this.scaleOverlay = false;
        this.init(BBANDS);
    }
}

let nameShort$o = "CCI";
let nameLong$o = 'Commodity Channel Index';
class CCI extends Indicator {
    get name() { return nameLong$o; }
    get shortName() { return nameShort$o; }
    get libName() { return nameShort$o; }
    static { this.nameShort = nameShort$o; }
    static { this.nameLong = nameLong$o; }
    static { this.version = "1.0"; }
    static { this.inCnt = 0; }
    static { this.primaryPane = false; }
    static { this.scale = YAXIS_TYPE.relative; }
    static { this.defaultStyle = {
        output: {
            colour: { value: "#E91E63" },
            width: { value: 1 },
            dash: { value: [] },
        },
        highLowRange: {
            colour: { value: "#880E4F" },
            width: { value: 1 },
            dash: { value: [2, 2] },
            fill: { value: "#880E4F08" },
            high: { value: 100 },
            low: { value: -100 }
        }
    }; }
    constructor(target, xAxis = false, yAxis = false, config, parent, params) {
        super(target, xAxis, yAxis, config, parent, params);
        this.precision = 2;
        this.scaleOverlay = true;
        this.init(CCI$1);
    }
}

let nameShort$n = "CMO";
let nameLong$n = 'Chande Momentum Oscillator';
class CMO extends Indicator {
    get name() { return nameLong$n; }
    get shortName() { return nameShort$n; }
    get libName() { return nameShort$n; }
    static { this.nameShort = nameShort$n; }
    static { this.nameLong = nameLong$n; }
    static { this.version = "1.0"; }
    static { this.inCnt = 0; }
    static { this.primaryPane = false; }
    static { this.scale = YAXIS_TYPE.relative; }
    static { this.defaultStyle = {
        output: {
            colour: { value: "#E91E63" },
            width: { value: 1 },
            dash: { value: [] },
        },
        highLowRange: {
            colour: { value: "#880E4F" },
            width: { value: 1 },
            dash: { value: [2, 2] },
            fill: { value: "#880E4F08" },
            high: { value: 75 },
            low: { value: 25 }
        }
    }; }
    constructor(target, xAxis = false, yAxis = false, config, parent, params) {
        super(target, xAxis, yAxis, config, parent, params);
        this.precision = 2;
        this.scaleOverlay = true;
        this.init(CMO$1);
    }
}

let nameShort$m = "DMI";
let nameLong$m = 'Average Directional Movement Index';
class DMI extends Indicator {
    static { this.nameShort = nameShort$m; }
    static { this.nameLong = nameLong$m; }
    static { this.version = "1.0"; }
    static { this.inCnt = 0; }
    static { this.primaryPane = false; }
    static { this.scale = YAXIS_TYPE.relative; }
    static { this.colours = []; }
    static { this.defaultStyle = {
        "DI+": {
            colour: { value: "#0f0" },
            width: { value: 1 },
            dash: { value: [] },
        },
        "DI-": {
            colour: { value: "#f00" },
            width: { value: 1 },
            dash: { value: [] },
        },
        "ADX": {
            colour: { value: "#00f" },
            width: { value: 1 },
            dash: { value: [] },
        },
    }; }
    static { this.timePeriodMultiplier = true; }
    #precision;
    get name() { return nameLong$m; }
    constructor(target, xAxis = false, yAxis = false, config, parent, params) {
        super(target, xAxis, yAxis, config, parent, params);
        this.#precision = 2;
        this.shortName = nameShort$m;
        this.scaleOverlay = false;
        this.definition = {
            input: {
                inReal: [],
                timePeriod: 20
            },
            output: {
                output: [],
            },
            meta: {
                output: [
                    { name: "DI+", type: "custom", plot: "line" },
                    { name: "DI-", type: "custom", plot: "line" },
                    { name: "ADX", type: "custom", plot: "line" },
                ],
                outputOrder: ["DMI+", "DMI-", "ADX"],
                outputLegend: {
                    "DI+": { labelStr: "DI+", label: true, value: true },
                    "DI-": { labelStr: "DI-", label: true, value: true },
                    "ADX": { labelStr: "ADX", label: true, value: true },
                }
            },
        };
        this.init();
    }
    get data() { return this.overlay.data; }
    get overlayData() { return this.overlay.data; }
    calcIndicator(indicator, params = {}, range = this.range) {
        return new Promise((resolve, reject) => {
            let promises = [
                super.calcIndicator("PLUS_DI", params, range),
                super.calcIndicator("MINUS_DI", params, range),
                super.calcIndicator("ADX", params, range)
            ];
            Promise.all(promises).then((result) => {
                let [result1, result2, result3] = [...result];
                if (!result1 && !result2 && !result3)
                    resolve(false);
                for (let i = 0; i < result1.length; i++) {
                    result1[i][2] = result2[i][1];
                    result1[i][3] = result3[i][1];
                }
                resolve(result1);
            });
        });
    }
    calcIndicatorStream(indicator, params = {}, range = this.range) {
        console.log("ADX", params);
        let promises = [
            (!this.noCalc("PLUS_DI", range)) ? this.TALib["PLUS_DI"](params).output : false,
            (!this.noCalc("MINUS_DI", range)) ? this.TALib["MINUS_DI"](params).output : false,
            (!this.noCalc("ADX", range)) ? this.TALib["ADX"](params).output : false
        ];
        Promise.all(promises).then((result) => {
            let [result1, result2, result3] = [...result];
            if (!result1 && !result2 && !result3)
                return false;
            let time = range.value()[0];
            return [time, result1[0], result2[0], result3[0]];
        });
    }
    draw(range = this.range) {
        super.draw(range);
    }
}

let nameShort$l = "DX";
let nameLong$l = 'Directional Movement Index';
class DX extends Indicator {
    get name() { return nameLong$l; }
    get shortName() { return nameShort$l; }
    get libName() { return nameShort$l; }
    static { this.nameShort = nameShort$l; }
    static { this.nameLong = nameLong$l; }
    static { this.version = "1.0"; }
    static { this.inCnt = 0; }
    static { this.primaryPane = false; }
    static { this.scale = YAXIS_TYPE.percent; }
    static { this.defaultStyle = {
        output: {
            colour: { value: "#E91E63" },
            width: { value: 1 },
            dash: { value: [] },
        },
        highLowRange: {
            colour: { value: "#880E4F" },
            width: { value: 1 },
            dash: { value: [2, 2] },
            fill: { value: "#880E4F08" },
            high: { value: 75 },
            low: { value: 25 }
        }
    }; }
    constructor(target, xAxis = false, yAxis = false, config, parent, params) {
        super(target, xAxis, yAxis, config, parent, params);
        this.precision = 2;
        this.scaleOverlay = true;
        this.init(DX$1);
    }
}

let nameShort$k = "EMA";
let nameLong$k = 'Exponential Moving Average';
class EMA extends Indicator {
    get name() { return nameLong$k; }
    get shortName() { return nameShort$k; }
    get libName() { return nameShort$k; }
    static { this.nameShort = nameShort$k; }
    static { this.nameLong = nameLong$k; }
    static { this.version = "1.0"; }
    static { this.inCnt = 0; }
    static { this.primaryPane = true; }
    static { this.colours = [
        "#9C27B0",
        "#9C27B0",
        "#66BB6A",
        "#66BB6A"
    ]; }
    static { this.defaultStyle = {
        output: {
            colour: { value: "#C80" },
            width: { value: 1 },
            dash: { value: [] },
        },
    }; }
    constructor(target, xAxis = false, yAxis = false, config, parent, params) {
        super(target, xAxis, yAxis, config, parent, params);
        this.definition = {
            input: {
                inReal: [],
                timePeriod: 20
            },
            output: {
                output: [],
            },
            meta: {
                input: {
                    timePeriod: {
                        entry: 'timePeriod',
                        label: 'Period',
                        type: 'number',
                        value: 5,
                        default: 30,
                        min: '3',
                        title: `Number of time units to use in calculation`,
                        $function: provideEventListeners("#Period", [{
                                event: "change",
                                fn: (e) => {
                                    console.log(`#Period = ${e.target.value}`);
                                }
                            }])
                    }
                }
            }
        };
        this.precision = 2;
        this.checkParamCount = false;
        this.scaleOverlay = false;
        EMA.inCnt++;
        this.init(EMA$1);
    }
}

let nameShort$j = "MA";
let nameLong$j = 'Moving Average';
class MA extends Indicator {
    get name() { return nameLong$j; }
    get shortName() { return nameShort$j; }
    get libName() { return nameShort$j; }
    #precision;
    static { this.nameShort = nameShort$j; }
    static { this.nameLong = nameLong$j; }
    static { this.version = "1.0"; }
    static { this.inCnt = 0; }
    static { this.primaryPane = true; }
    static { this.colours = [
        "#9C27B0",
        "#9C27B0",
        "#66BB6A",
        "#66BB6A"
    ]; }
    static { this.defaultStyle = {
        output: {
            colour: { value: "#9C27B0" },
            width: { value: 1 },
            dash: { value: [] },
        },
    }; }
    constructor(target, xAxis = false, yAxis = false, config, parent, params) {
        super(target, xAxis, yAxis, config, parent, params);
        this.definition = {
            input: {
                inReal: [],
                timePeriod: 20
            },
            output: {
                output: [],
            },
        };
        this.#precision = 2;
        this.primaryPane = true;
        this.scaleOverlay = false;
        MA.inCnt++;
        this.init(MA$1);
    }
}

let nameShort$i = "MMA";
let nameLong$i = 'Moving Average Multi';
class MA_Multi extends Indicator {
    static { this.nameShort = nameShort$i; }
    static { this.nameLong = nameLong$i; }
    static { this.version = "1.0"; }
    static { this.inCnt = 0; }
    static { this.primaryPane = true; }
    static { this.colours = [
        colours2[8],
        colours2[18],
        colours2[28],
        colours2[38],
        colours2[48],
    ]; }
    static { this.defaultStyle = {
        stroke1: MA_Multi.colours[0],
        width1: '1',
        stroke2: MA_Multi.colours[1],
        width2: '1',
        stroke3: MA_Multi.colours[2],
        width3: '1',
        stroke4: MA_Multi.colours[3],
        width4: '1',
        stroke5: MA_Multi.colours[4],
        width5: '1',
    }; }
    get name() { return nameLong$i; }
    get shortName() { return nameShort$i; }
    get libName() { return nameShort$i; }
    #precision;
    #MACnt;
    #MACntMax;
    constructor(target, xAxis = false, yAxis = false, config, parent, params) {
        super(target, xAxis, yAxis, config, parent, params);
        this.definition = {
            input: {
                inReal: [],
                timePeriod1: new InputPeriodEnable(true, 5),
                timePeriod2: new InputPeriodEnable(true, 10),
                timePeriod3: new InputPeriodEnable(true, 20),
                timePeriod4: new InputPeriodEnable(true, 30),
                timePeriod5: new InputPeriodEnable(true, 50)
            },
            output: {
                output1: [],
                output2: [],
                output3: [],
                output4: [],
                output5: [],
            },
        };
        this.#precision = 2;
        this.primaryPane = true;
        this.scaleOverlay = false;
        this.plots = [
            { key: 'MA_1', title: 'MA: ', type: 'line' },
        ];
        this.#MACnt = 3;
        this.#MACntMax = 5;
        this.MA = {
            MA1: { enabled: false, ma: null },
            MA2: { enabled: false, ma: null },
            MA3: { enabled: false, ma: null },
            MA4: { enabled: false, ma: null },
            MA5: { enabled: false, ma: null }
        };
        MA.inCnt++;
        const MAChildren = params.overlay.settings?.MAChildren || this.MA;
        this.#MACnt = Object.keys(MAChildren).length;
        this.MA.ma1 = new MA(target, xAxis = false, yAxis = false, config, parent, params);
        this.MA.ma2 = new MA(target, xAxis = false, yAxis = false, config, parent, params);
    }
    legendInputs(pos = this.chart.cursorPos) {
        if (this.overlay.data.length == 0)
            return false;
        const inputs = {};
        const { c, colours } = super.legendInputs(pos);
        inputs.MA_1 = this.scale.nicePrice(this.overlay.data[c][1]);
        return { inputs, colours };
    }
    draw(range = this.range) {
        if (this.overlay.data.length < 2)
            return;
        if (!super.mustUpdate())
            return;
        this.scene.clear();
        const data = this.overlay.data;
        const width = this.xAxis.candleW;
        const plots = [];
        this.xAxis.smoothScrollOffset || 0;
        const plot = {
            w: width,
        };
        let o = this.Timeline.rangeScrollOffset;
        let d = range.data.length - this.overlay.data.length;
        let c = range.indexStart - d - 2;
        let i = range.Length + (o * 2) + 2;
        while (i) {
            if (c < 0 || c >= this.overlay.data.length) {
                plots.push({ x: null, y: null });
            }
            else {
                plot.x = this.xAxis.xPos(data[c][0]);
                plot.y = this.yAxis.yPos(data[c][1]);
                plots.push({ ...plot });
            }
            c++;
            i--;
        }
        this.plot(plots, "renderLine", this.style);
        this.target.viewport.render();
        super.updated();
    }
}

let nameShort$h = "MACD";
let nameLong$h = 'Moving Average Convergence/Divergence';
class MACD extends Indicator {
    get name() { return 'Moving Average Convergence/Divergence'; }
    get shortName() { return nameShort$h; }
    get libName() { return nameShort$h; }
    #precision;
    static { this.nameShort = nameShort$h; }
    static { this.nameLong = nameLong$h; }
    static { this.version = "1.0"; }
    static { this.inCnt = 0; }
    static { this.primaryPane = false; }
    static { this.scale = YAXIS_TYPE.relative; }
    static { this.colours = [
        "#9C27B0",
        "#9C27B0",
        "#66BB6A",
        "#66BB6A"
    ]; }
    static { this.defaultStyle = {
        MACD: {
            colour: { value: "#08c" },
            width: { value: 1 },
            dash: { value: "" },
        },
        MACDSignal: {
            colour: { value: "#0c8" },
            width: { value: 1 },
            dash: { value: "" },
        },
        MACDHist: {
            upStroke: { value: "#0f0" },
            upFill: { value: "#0c0" },
            upWidth: { value: '1' },
            dnStroke: { value: "#f00" },
            dnFill: { value: "#c00" },
            dnWidth: { value: '1' },
        },
    }; }
    static { this.timePeriodMultiplier = true; }
    constructor(target, xAxis = false, yAxis = false, config, parent, params) {
        super(target, xAxis, yAxis, config, parent, params);
        this.definition = {
            input: {
                inReal: [],
                fastPeriod: 12,
                slowPeriod: 26,
                signalPeriod: 9
            },
            output: {
                MACD: [],
                MACDSignal: [],
                MACDHist: [],
            },
            meta: {
                outputOrder: [
                    "MACD", "MACDSignal", "MACDHist",
                ],
                outputLegend: {
                    MACD: { labelStr: "MACD", label: false, value: true },
                    MACDSignal: { labelStr: "Signal", label: false, value: true },
                    MACDHist: { labelStr: "Hist", label: false, value: true }
                },
            }
        };
        this.#precision = 2;
        this.scaleOverlay = false;
        MACD.inCnt++;
        this.init(MACD$1);
    }
    draw() {
        return super.draw();
    }
}

let nameShort$g = "MFI";
let nameLong$g = 'Money Flow Index';
class MFI extends Indicator {
    get name() { return nameLong$g; }
    get shortName() { return nameShort$g; }
    get libName() { return nameShort$g; }
    static { this.nameShort = nameShort$g; }
    static { this.nameLong = nameLong$g; }
    static { this.version = "1.0"; }
    static { this.inCnt = 0; }
    static { this.primaryPane = false; }
    static { this.scale = YAXIS_TYPE.percent; }
    static { this.defaultStyle = {
        output: {
            colour: { value: "#E91E63" },
            width: { value: 1 },
            dash: { value: [] },
        },
        highLowRange: {
            colour: { value: "#880E4F" },
            width: { value: 1 },
            dash: { value: [2, 2] },
            fill: { value: "#880E4F08" },
            high: { value: 100 },
            low: { value: -100 }
        }
    }; }
    constructor(target, xAxis = false, yAxis = false, config, parent, params) {
        super(target, xAxis, yAxis, config, parent, params);
        this.precision = 2;
        this.scaleOverlay = true;
        this.init(MFI$1);
    }
}

let nameShort$f = "OBV";
let nameLong$f = 'On Balance Volume';
class OBV extends Indicator {
    get name() { return nameLong$f; }
    get shortName() { return nameShort$f; }
    get libName() { return nameShort$f; }
    static { this.nameShort = nameShort$f; }
    static { this.nameLong = nameLong$f; }
    static { this.version = "1.0"; }
    static { this.inCnt = 0; }
    static { this.primaryPane = false; }
    static { this.scale = YAXIS_TYPE.default; }
    static { this.defaultStyle = {
        output: {
            colour: { value: "#E91E63" },
            width: { value: 1 },
            dash: { value: [] },
        },
        highLowRange: {
            colour: { value: "#880E4F" },
            width: { value: 1 },
            dash: { value: [2, 2] },
            fill: { value: "#880E4F08" },
            high: { value: 100 },
            low: { value: -100 }
        }
    }; }
    static { this.timePeriodMultiplier = true; }
    constructor(target, xAxis = false, yAxis = false, config, parent, params) {
        super(target, xAxis, yAxis, config, parent, params);
        this.precision = 2;
        this.scaleOverlay = true;
        this.init(OBV$1);
    }
}

let nameShort$e = "PPO";
let nameLong$e = 'Percentage Price Oscillator';
class PPO extends Indicator {
    get name() { return 'Percentage Price Oscillator'; }
    get shortName() { return nameShort$e; }
    get libName() { return nameShort$e; }
    static { this.nameShort = nameShort$e; }
    static { this.nameLong = nameLong$e; }
    static { this.version = "1.0"; }
    static { this.inCnt = 0; }
    static { this.primaryPane = false; }
    static { this.scale = YAXIS_TYPE.relative; }
    static { this.yAxisPadding = YAXIS_PADDING; }
    static { this.defaultStyle = {
        output: {
            colour: { value: "#E91E63" },
            width: { value: 1 },
            dash: { value: [] },
        },
        highLowRange: {
            colour: { value: "#880E4F" },
            width: { value: 1 },
            dash: { value: [2, 2] },
            fill: { value: "#880E4F08" },
            high: { value: 100 },
            low: { value: -100 }
        }
    }; }
    constructor(target, xAxis = false, yAxis = false, config, parent, params) {
        super(target, xAxis, yAxis, config, parent, params);
        this.precision = 2;
        this.scaleOverlay = true;
        this.init(PPO$1);
    }
}

let nameShort$d = "PSAR";
let nameLong$d = 'Parabolic Stop and Reverse';
class PSAR extends Indicator {
    get name() { return nameLong$d; }
    get shortName() { return nameShort$d; }
    get libName() { return nameShort$d; }
    static { this.nameShort = nameShort$d; }
    static { this.nameLong = nameLong$d; }
    static { this.version = "1.0"; }
    static { this.inCnt = 0; }
    static { this.primaryPane = true; }
    static { this.defaultStyle = {
        output: {
            colour: { value: "#E91E63" },
            width: { value: 1 },
            dash: { value: [] },
        },
    }; }
    constructor(target, xAxis = false, yAxis = false, config, parent, params) {
        super(target, xAxis, yAxis, config, parent, params);
        this.precision = 2;
        this.scaleOverlay = false;
        this.init(SAR);
    }
}

let nameShort$c = "ROC";
let nameLong$c = 'Rate of Change';
class ROC extends Indicator {
    get name() { return nameLong$c; }
    get shortName() { return nameShort$c; }
    get libName() { return nameShort$c; }
    static { this.nameShort = nameShort$c; }
    static { this.nameLong = nameLong$c; }
    static { this.version = "1.0"; }
    static { this.inCnt = 0; }
    static { this.primaryPane = false; }
    static { this.scale = YAXIS_TYPE.relative; }
    static { this.yAxisPadding = YAXIS_PADDING; }
    static { this.defaultStyle = {
        output: {
            colour: { value: "#E91E63" },
            width: { value: 1 },
            dash: { value: [] },
        },
        highLowRange: {
            colour: { value: "#880E4F" },
            width: { value: 1 },
            dash: { value: [2, 2] },
            fill: { value: "#880E4F08" },
            high: { value: 100 },
            low: { value: -100 }
        }
    }; }
    constructor(target, xAxis = false, yAxis = false, config, parent, params) {
        super(target, xAxis, yAxis, config, parent, params);
        this.precision = 2;
        this.scaleOverlay = true;
        this.init(ROC$1);
    }
}

let nameShort$b = "RSI";
let nameLong$b = 'Average Directional Movement Index';
class RSI extends Indicator {
    get name() { return nameLong$b; }
    get shortName() { return nameShort$b; }
    get libName() { return nameShort$b; }
    static { this.nameShort = nameShort$b; }
    static { this.nameLong = nameLong$b; }
    static { this.version = "1.0"; }
    static { this.inCnt = 0; }
    static { this.primaryPane = false; }
    static { this.scale = YAXIS_TYPE.percent; }
    static { this.defaultStyle = {
        output: {
            colour: { value: "#E91E63" },
            width: { value: 1 },
            dash: { value: [] },
        },
        highLowRange: {
            colour: { value: "#880E4F" },
            width: { value: 1 },
            dash: { value: [2, 2] },
            fill: { value: "#880E4F08" },
            high: { value: 75 },
            low: { value: 25 }
        }
    }; }
    constructor(target, xAxis = false, yAxis = false, config, parent, params) {
        super(target, xAxis, yAxis, config, parent, params);
        this.definition = {
            input: {
                inReal: [],
                timePeriod: 20
            },
            output: {
                output: [],
            },
            meta: {
                outputOrder: [
                    "output",
                    "highLowRange"
                ],
                output: [
                    { name: "highLowRange", type: "overlay", plot: "highLowRange", style: RSI.defaultStyle.highLow }
                ],
                style: RSI.defaultStyle
            }
        };
        this.checkParamCount = false;
        this.init(RSI$1);
    }
}

let nameShort$a = "SMA";
let nameLong$a = 'Simple Moving Average';
class SMA extends Indicator {
    get name() { return nameLong$a; }
    get shortName() { return nameShort$a; }
    get libName() { return nameShort$a; }
    #precision;
    static { this.nameShort = nameShort$a; }
    static { this.nameLong = nameLong$a; }
    static { this.version = "1.0"; }
    static { this.inCnt = 0; }
    static { this.primaryPane = true; }
    static { this.colours = [
        "#9C27B0",
        "#9C27B0",
        "#66BB6A",
        "#66BB6A"
    ]; }
    static { this.defaultStyle = {
        output: {
            colour: { value: "#0097A7" },
            width: { value: 1 },
            dash: { value: [] },
        },
    }; }
    constructor(target, xAxis = false, yAxis = false, config, parent, params) {
        super(target, xAxis, yAxis, config, parent, params);
        this.definition = {
            input: {
                inReal: [],
                timePeriod: 20
            },
            output: {
                output: [],
            },
        };
        this.#precision = 2;
        this.primaryPane = true;
        this.scaleOverlay = false;
        SMA.inCnt++;
        this.init(SMA$1);
    }
}

let nameShort$9 = "STOCH";
let nameLong$9 = 'Stochastic Oscillator';
class STOCH extends Indicator {
    get name() { return nameLong$9; }
    get shortName() { return nameShort$9; }
    get libName() { return nameShort$9; }
    static { this.nameShort = nameShort$9; }
    static { this.nameLong = nameLong$9; }
    static { this.version = "1.0"; }
    static { this.inCnt = 0; }
    static { this.primaryPane = false; }
    static { this.scale = YAXIS_TYPE.relative; }
    static { this.defaultStyle = {
        slowK: {
            colour: { value: "#c89" },
            width: { value: 1 },
            dash: { value: "" },
        },
        slowD: {
            colour: { value: "#08c" },
            width: { value: 1 },
            dash: { value: "" },
        },
    }; }
    static { this.timePeriodMultiplier = true; }
    constructor(target, xAxis = false, yAxis = false, config, parent, params) {
        super(target, xAxis, yAxis, config, parent, params);
        this.definition = {
            input: {
                high: [],
                low: [],
                close: [],
                fastK_Period: 5,
                slowK_Period: 3,
                slowD_Period: 3
            },
            output: {
                slowK: [],
                slowD: []
            },
        };
        this.checkParamCount = false;
        this.init(STOCH$1);
    }
}

let nameShort$8 = "STOCHRSI";
let nameLong$8 = 'Stochastic RSI';
class STOCHRSI extends Indicator {
    get name() { return nameLong$8; }
    get shortName() { return nameShort$8; }
    get libName() { return nameShort$8; }
    static { this.nameShort = nameShort$8; }
    static { this.nameLong = nameLong$8; }
    static { this.version = "1.0"; }
    static { this.inCnt = 0; }
    static { this.primaryPane = false; }
    static { this.scale = YAXIS_TYPE.relative; }
    static { this.defaultStyle = {
        fastK: {
            colour: { value: "#c89" },
            width: { value: 1 },
            dash: { value: "" },
        },
        fastD: {
            colour: { value: "#08c" },
            width: { value: 1 },
            dash: { value: "" },
        },
    }; }
    constructor(target, xAxis = false, yAxis = false, config, parent, params) {
        super(target, xAxis, yAxis, config, parent, params);
        this.definition = {
            input: {
                inReal: [],
                timePeriod: 14,
                stochPeriod: 14,
                KPeriod: 3,
                DPeriod: 3
            },
            output: {
                fastK: [],
                fastD: []
            },
        };
        this.checkParamCount = false;
        this.init(STOCHRSI$1);
    }
}

class VolumeBar {
    constructor(scene, theme) {
        this.scene = scene;
        this.ctx = this.scene.context;
        this.width = this.scene.width;
        this.theme = theme;
        this.dpr = CEL.pixelRatio;
    }
    alignToPixel(value) {
        return Math.round(value * this.dpr) / this.dpr;
    }
    draw(data) {
        const ctx = this.ctx;
        const hilo = data.raw[4] >= data.raw[1];
        const barColour = hilo ? this.theme.up.colour.value : this.theme.dn.colour.value;
        let w = Math.max(data.w - 1, 1);
        let hw = w * 0.5;
        w = this.alignToPixel(w);
        const centerX = this.alignToPixel(data.x);
        const barX = centerX - (w / 2) + hw;
        const h = this.alignToPixel(data.h);
        const z = this.alignToPixel(data.z);
        ctx.save();
        ctx.fillStyle = barColour;
        ctx.fillRect(barX, z - h, w, h);
        ctx.restore();
    }
}

let nameShort$7 = "VOL";
let nameLong$7 = 'Volume';
class Volume extends Indicator {
    get name() { return nameLong$7; }
    #defaultStyle;
    #volumeBar;
    #primaryPane;
    static { this.nameShort = nameShort$7; }
    static { this.nameLong = nameLong$7; }
    static { this.version = "1.0"; }
    static { this.inCnt = 0; }
    static { this.primaryPane = "both"; }
    static { this.scale = YAXIS_TYPE.percent; }
    static { this.defaultStyle = {
        up: { colour: { value: "#388E3C" } },
        dn: { colour: { value: "#D32F2F" } },
        height: { percent: { value: 15 } }
    }; }
    constructor(target, xAxis = false, yAxis = false, config, parent, params) {
        super(target, xAxis, yAxis, config, parent, params);
        this.shortName = nameShort$7;
        this.checkParamCount = false;
        this.scaleOverlay = true;
        this.definition = {
            meta: {
                style: {
                    up: { colour: { value: "#388E3C" } },
                    dn: { colour: { value: "#D32F2F" } },
                    height: { percent: { value: 15 } }
                }
            }
        };
        this.#defaultStyle = defaultTheme.volume;
        this.#primaryPane = "both";
        Volume.inCnt++;
        const overlay = params.overlay;
        this.id = params.overlay?.id || uid(this.shortName);
        this.#defaultStyle = { ...this.defaultStyle, ...this.theme.volume };
        this.style = (overlay?.settings?.style) ? { ...this.#defaultStyle, ...overlay.settings.style } : { ...this.#defaultStyle, ...config.style };
        if (this.chart.type === "primaryPane") {
            this.style.Height = limit(this.style.Height, 0, 100) || 100;
            this.#primaryPane = true;
        }
        else {
            this.style.Height = 100;
            this.#primaryPane = false;
        }
        this.mStyle.up.colour.value = this.style.UpColour;
        this.mStyle.dn.colour.value = this.style.DnColour;
        this.mStyle.height.percent.value = this.style.Height;
        this.#volumeBar = new VolumeBar(target.scene, this.mStyle);
        this.addLegend();
        this.configDialogue.start();
    }
    get primaryPane() { return this.#primaryPane; }
    get defaultStyle() { return this.#defaultStyle; }
    get mStyle() { return this.definition.meta.style; }
    legendInputs(pos = this.chart.cursorPos) {
        if (this.range.dataLength == 0)
            return false;
        const idx = super.Timeline.xPos2Index(pos[0]);
        const index = limit(idx, 0, this.range.data.length - 1);
        const ohlcv = this.range.data[index];
        this.chart.theme.candle;
        const colours = (ohlcv[4] >= ohlcv[1]) ?
            [this.mStyle.up.colour.value.slice(0, 7)] :
            [this.mStyle.dn.colour.value.slice(0, 7)];
        const inputs = { "V": this.scale.nicePrice(ohlcv[5]) };
        return { inputs, colours };
    }
    calcIndicatorHistory() {
    }
    draw(range = this.range) {
        if (range.dataLength < 2)
            return false;
        if (!this.mustUpdate())
            return false;
        this.scene.clear();
        const data = range.data;
        const zeroPos = this.scene.height;
        const offset = this.xAxis.smoothScrollOffset || 0;
        let w = Math.max(this.xAxis.candleW - 1, 1);
        w = candleW(w);
        const volume = {
            x: 0 + offset - this.xAxis.candleW,
            w: w,
            z: zeroPos
        };
        const volH = Math.floor(zeroPos * this.mStyle.height.percent.value / 100);
        let o = this.core.rangeScrollOffset;
        let v = range.indexStart - o;
        let i = range.Length + (o * 2);
        let j = i;
        let u = v;
        let x;
        let maxVol = 0;
        while (j--) {
            x = range.value(u);
            if (x[4] !== null) {
                maxVol = (x[5] > maxVol) ? x[5] : maxVol;
            }
            u++;
        }
        while (i--) {
            x = range.value(v);
            volume.x = bRound(this.xAxis.xPos(x[0]) - (w / 2));
            if (x[4] !== null) {
                volume.h = volH - (volH * ((maxVol - x[5]) / maxVol));
                volume.raw = data[v];
                this.#volumeBar.draw(volume);
            }
            v++;
        }
        super.updated();
    }
}

const IndicatorClasses = {
    ADX,
    ATR,
    AROON,
    BB,
    CCI,
    CMO,
    DMI,
    DX,
    EMA,
    MA,
    MACD,
    MFI,
    OBV,
    PPO,
    PSAR,
    ROC,
    RSI,
    SMA,
    STOCHRSI,
    VOL: Volume,
};
const indicators = {};
((ind) => {
    for (let i in ind) {
        indicators[i] = {
            id: i,
            name: ind[i].prototype.name,
            event: "addIndicator",
            ind: ind[i]
        };
    }
})(IndicatorClasses);

var version = "0.158.5";

class LZW {
    static compress(s) {
        if (s === undefined || s === null || typeof s !== 'string') {
            throw new TypeError('LZW compress() input must be a string');
        }
        if (s === '')
            return '';
        let dict = new Map();
        let data = s.split("");
        let out = [];
        let currentCharacter;
        let currentPharse = data[0];
        let code = 256;
        for (let i = 1; i < data.length; i++) {
            currentCharacter = data[i];
            if (dict.has(currentPharse + currentCharacter)) {
                currentPharse += currentCharacter;
            }
            else {
                out.push(currentPharse.length > 1 ? dict.get(currentPharse) : currentPharse.codePointAt(0));
                dict.set(currentPharse + currentCharacter, code);
                code++;
                if (code === 0xd800) {
                    code = 0xe000;
                }
                currentPharse = currentCharacter;
            }
        }
        out.push(currentPharse.length > 1 ? dict.get(currentPharse) : currentPharse.codePointAt(0));
        return String.fromCodePoint(...out);
    }
    static decompress(s) {
        if (s === undefined || s === null || typeof s !== 'string') {
            throw new TypeError('LZW compress() input must be a string');
        }
        if (s === '')
            return '';
        let dict = new Map();
        let data = Array.from(s);
        if (!data.length)
            throw new Error(`Error processing LZW input`);
        let currentCharacter = data[0];
        let oldPhrase = currentCharacter;
        let out = [currentCharacter];
        let code = 256;
        let currentPharse;
        for (let i = 1; i < data.length; i++) {
            let currCode = data[i].codePointAt(0);
            if (currCode < 256) {
                currentPharse = data[i];
            }
            else {
                currentPharse = dict.has(currCode) ? dict.get(currCode) : (oldPhrase + currentCharacter);
            }
            out.push(currentPharse);
            let cp = currentPharse.codePointAt(0);
            currentCharacter = String.fromCodePoint(cp);
            dict.set(code, oldPhrase + currentCharacter);
            code++;
            if (code === 0xd800) {
                code = 0xe000;
            }
            oldPhrase = currentPharse;
        }
        return out.join("");
    }
}

function validateShallow(data, isCrypto = false) {
    if (!isArray(data))
        return false;
    let rnd = getRandomIntBetween(0, data.length);
    if (!isCandleValid(data[0], isCrypto))
        return false;
    if (!isCandleValid(data[rnd], isCrypto))
        return false;
    if (!isCandleValid(data[data.length - 1], isCrypto))
        return false;
    let t1 = data[0][0];
    let t2 = data[1][0];
    let t3 = data[2][0];
    if (t1 > t2 && t2 > t3)
        return false;
    return true;
}
function validateDeep(data, isCrypto = false) {
    if (!isArray(data))
        return false;
    let i = 0;
    let prev = 0;
    while (i < data.length) {
        if (!isCandleValid(data[i], isCrypto))
            return false;
        if (data[i][0] < prev)
            return false;
        prev = data[i][0];
        i++;
    }
    return true;
}
function isCandleValid(c, isCrypto = false) {
    if (!isArray(c))
        return false;
    if (c.length !== 6)
        return false;
    if (isCrypto)
        if (!isValidTimeInRange(c[0]))
            return false;
    if (!isNumber(c[1]) ||
        !isNumber(c[2]) ||
        !isNumber(c[3]) ||
        !isNumber(c[4]) ||
        !isNumber(c[5]))
        return false;
    return true;
}
function sanitizeCandles(c) {
    for (let i of c) {
        for (let j = 0; j < 6; j++) {
            i.length = 6;
            i[j] *= 1;
        }
    }
    return c;
}
class Gaps {
    #core;
    #state;
    #range;
    #list = {};
    constructor(state) {
        if (!(state instanceof State))
            throw new Error(`Class Gaps requires a valid State`);
        this.#core = state.core;
        this.#state = state;
        this.#range = state.range;
    }
    get list() { return this.#list; }
    get hasGaps() { return Object.keys(this.#list).length; }
    get dataSource() { return this.#state.dataSource; }
    get source() { return this.#state.dataSource.source; }
    findFillGaps(data) {
        let timeFrameMS = this.#state.timeFrame;
        if (!isArray(data) ||
            data.length == 1)
            return false;
        let a, b, c, e, ts, i = 0, l = (data[data.length - 1][0] - data[i][0]) / timeFrameMS;
        while (i < l) {
            a = data[i][0];
            b = data[i + 1][0];
            c = b - a;
            if (c == timeFrameMS) ;
            else if (c > timeFrameMS) {
                ts = a + timeFrameMS;
                e = [ts, null, null, null, null, null];
                this.list[`${ts}`] = e;
                data.splice(i + 1, 0, e);
            }
            else ;
            i++;
        }
        return data;
    }
    removeFilledGaps(start, end) {
        if (!this.hasGaps)
            return;
        let tf = this.#state.timeFrame;
        let range = this.#range;
        let filled = [];
        let value;
        const invalid = (start) => {
            value = this.#list[`${start}`];
            if (value !== range.valueByTS(start)) {
                delete this.#list[start];
                filled.push(start);
            }
        };
        if (!isInteger(start) || !isInteger(end)) {
            let gapTFs = Object.keys(this.#list);
            for (let start of gapTFs) {
                invalid(start);
            }
        }
        else {
            while (start <= end) {
                invalid(start);
                start += tf;
            }
        }
        return filled;
    }
    nullFillGapsOnMerge(newer, older) {
        let merged = older;
        let len = older.length;
        let ts = older[len - 1][0];
        let gap = Math.floor((newer[0][0] - ts) / this.#state.timeFrame);
        let arr;
        for (gap; gap > 1; gap--) {
            ts += this.#state.timeFrame;
            arr = Array(newer[0].length).fill(null);
            arr[0] = ts;
            merged.push(arr);
            this.#list[`${ts}`] = arr;
        }
        return merged;
    }
    fillRangeGaps() {
        let range = this.#range;
        let gaps = Object.keys(this.#list);
        let start = range.indexStart;
        let end = range.indexEnd;
        let startTS = range.indexStartTS;
        let endTS = range.indexEndTS;
        let e = { chart: this.#core, start, end, startTS, endTS };
        if (start >= gaps[0] && start <= gaps[gaps.length - 1]) {
            if (isFunction(this.source?.rangeLimitPast))
                this.source?.rangeLimitPast(e);
        }
        if (end >= gaps[0] && end <= gaps[gaps.length - 1]) {
            if (isFunction(this.source?.rangeLimitFuture))
                this.source?.rangeLimitFuture(e);
        }
    }
    findGapsInTimeSpan(startTS = this.#range.indexStartTS, endTS = this.#range.indexEndTS) {
        if (!isValidTimestamp(startTS) || !isValidTimestamp(endTS) || !this.hasGaps)
            return [];
        let range = this.#range;
        let start = range.getTimeIndex(startTS);
        let end = range.getTimeIndex(endTS);
        let TFs = [];
        let value;
        for (let i = start; i < end + 1; i++) {
            value = range.value(i);
            if (value[1] === null)
                TFs.push(value[0]);
            else
                continue;
        }
        return TFs;
    }
}

const ALERT = "alert";
class Alerts {
    #list = new xMap();
    #handlers = {};
    constructor(alerts) {
        if (isArray(alerts)) {
            for (let a of alerts) {
                this.add(a?.price, a?.condition, a?.handler);
            }
        }
    }
    get list() { return this.#list; }
    get handlers() { return this.#handlers; }
    destroy() {
        this.#list.clear();
        this.#handlers = {};
    }
    batchAdd(alerts) {
        if (isArray(alerts)) {
            let ids = [];
            for (let a of alerts) {
                ids.push(this.add(a?.price, a?.condition, a?.handler));
            }
            return ids;
        }
        else
            return false;
    }
    add(price, condition, handler) {
        if (isNaN(price) ||
            !isFunction(handler))
            return false;
        const id = uid(ALERT);
        const alert = { price, condition };
        if (this.list.has(alert)) {
            let value = this.list.get(alert);
            value[id] = handler;
        }
        else {
            const entry = {};
            entry[id] = handler;
            this.list.set(alert, entry);
        }
        this.#handlers[id] = { alert, handler };
        return id;
    }
    remove(id) {
        if (!(id in this.#handlers))
            return false;
        const handler = this.#handlers[id];
        const alert = handler.alert;
        const value = this.#list.get(alert);
        value.delete(id);
        handler.delete(id);
        if (Object.keys(value).length == 0)
            this.#list.delete(alert);
        return true;
    }
    delete(price, condition) {
        if (this.list.has({ price, condition })) {
            const alert = this.list.get({ price, condition });
            for (let id in alert) {
                this.#handlers.delete(id);
                alert.delete(id);
            }
        }
        return this.list.delete({ price, condition });
    }
    pause(id) {
        if (!(id in this.#handlers))
            return false;
        this.#handlers[id];
    }
    handlerByID(id) {
        if (!(id in this.#handlers))
            return false;
        else
            return this.#handlers[id].handler;
    }
    check(prev, curr) {
        if (!isArray(prev) || !isArray(curr))
            return;
        for (let [key, handlers] of this.list) {
            if (key.condition(key.price, prev, curr)) {
                for (let id in handlers) {
                    try {
                        handlers[id](key.price, prev, curr);
                    }
                    catch (e) {
                        console.error(e);
                    }
                }
            }
        }
    }
}

const statusAllowStart = [STREAM_NONE, STREAM_STOPPED];
const keys = ["t", "o", "h", "l", "c", "v"];
const T = 0, O = 1, H = 2, L = 3, C = 4, V = 5;
const empty = [null, null, null, null, null];
const defaultStreamConfig = {
    tfCountDown: true,
    alerts: []
};
class Stream {
    #core;
    #config;
    #state;
    #status;
    #maxUpdate;
    #updateTimer = 0;
    #precision;
    #data;
    #candle = empty;
    #countDownStart = 0;
    #countDownMS = 0;
    #countDown = "";
    #dataReceived = false;
    #lastTick = empty;
    #lastScrollPos;
    #lastXPos;
    #lastYPos;
    #alerts;
    constructor(core, state) {
        if (!(core instanceof TradeXchart))
            throwError$2({ id: "invalid" }, `not a valid chart instance`);
        else
            this.#core = core;
        if (!(state instanceof State))
            throwError$2(core, `state not a valid State instance`);
        else
            this.#state = state;
        this.status = { status: STREAM_NONE };
        this.#config = validateConfig(core.config?.stream);
        this.#maxUpdate = (isNumber(core.config?.maxCandleUpdate)) ? core.config.maxCandleUpdate : STREAM_MAXUPDATE;
        this.#precision = (isNumber(core.config?.streamPrecision)) ? core.config.streamPrecision : STREAM_PRECISION;
    }
    get state() { return this.#state; }
    get config() { return this.#config; }
    get countDownMS() { return this.#countDownMS; }
    get countDown() { return this.#countDown; }
    get range() { return this.#state.range; }
    get status() { return this.#status; }
    set status(s) {
        if (!isObject(s) && !isString(s?.status))
            return;
        this.#status = s.status;
        this.emit(s.status, s?.data);
    }
    get symbol() { return this.#state.symbol; }
    get timeFrame() { return this.#state.timeFrame; }
    get timeFrameStr() { return this.#state.timeFrameStr; }
    set dataReceived(data) {
        if (this.#dataReceived)
            return;
        this.#dataReceived = true;
        this.status = { status: STREAM_FIRSTVALUE, data };
    }
    get alerts() { return this.#alerts; }
    get lastPriceMin() { return this.#candle[3]; }
    get lastPriceMax() { return this.#candle[2]; }
    get lastScrollPos() { return this.#lastScrollPos; }
    set lastScrollPos(p) { this.setLastScrollPos(p); }
    get lastXPos() { return this.#lastXPos; }
    set lastXPos(p) { if (isNumber(p))
        this.#lastXPos = p; }
    get lastYPos() { return this.#lastYPos; }
    set lastYPos(p) { if (isObject(p))
        this.#lastYPos = p; }
    get lastTick() { return this.#lastTick; }
    set lastTick(t) {
        if (!isArray(t))
            return;
        this.#lastTick;
        this.#lastTick = t;
        this.alerts.check(t, this.#candle);
    }
    get isActive() {
        let active = [
            STREAM_LISTENING,
            STREAM_STARTED,
            STREAM_FIRSTVALUE,
            STREAM_NEWVALUE,
            STREAM_UPDATE
        ];
        if (active.includes(this.#status))
            return true;
        else
            return false;
    }
    get inRange() {
        if (!!this.#candle)
            return false;
        else
            return this.range.inRange(this.candle[0]);
    }
    set candle(data) {
        const now = Date.now();
        const lastTick = [...this.#candle];
        if (!valuesInArray(keys, Object.keys(data)))
            return;
        if (!isValidTimestamp(data.t))
            return;
        data.ts = Date.now();
        data.t = this.roundTime(new Date(data.t));
        data.o = data.o * 1;
        data.h = data.h * 1;
        data.l = data.l * 1;
        data.c = data.c * 1;
        data.v = data.v * 1;
        this.#data = data;
        this.dataReceived = data;
        if (this.#candle[T] !== data.t) {
            this.newCandle(data);
        }
        else {
            this.updateCandle(data);
        }
        this.newBounds();
        this.status = { status: STREAM_LISTENING, data: this.#candle };
        this.lastTick = lastTick;
        if (now - this.#updateTimer > this.#maxUpdate)
            this.onUpdate();
        this.#updateTimer = now;
    }
    get candle() {
        return (this.#candle !== empty) ? this.#candle : null;
    }
    setLastScrollPos(p) {
        if (isNumber(p))
            this.#lastScrollPos = p;
    }
    resetLastPos() {
        this.#lastXPos = undefined;
        this.#lastYPos = undefined;
        this.#lastScrollPos = undefined;
    }
    start() {
        if (!statusAllowStart.includes(this.status)) {
            this.#core.error("ERROR: Invoke stopStream() before starting a new one.");
            return;
        }
        if (!(this.#alerts instanceof Alerts))
            this.#alerts = new Alerts(this.#config.alerts);
        this.status = { status: STREAM_STARTED };
    }
    stop() {
        if (this.#alerts instanceof Alerts)
            this.#alerts.destroy();
        this.status = { status: STREAM_STOPPED };
        this.resetLastPos();
    }
    emit(topic, data) {
        this.#core.emit(topic, data);
    }
    error() {
        this.status = { status: STREAM_ERROR };
    }
    onTick(tick) {
        if ((this.#status == STREAM_STARTED || this.#status == STREAM_LISTENING) &&
            isObject(tick)) {
            if (!isInteger(tick.t * 1))
                return;
            let keys = Object.keys(tick);
            let _tick = {}, value;
            for (let key of keys) {
                value = tick[key] * 1;
                if (isNumber(value))
                    _tick[key] = value;
            }
            this.candle = _tick;
        }
    }
    onUpdate() {
        if (!this.#state?.isActive)
            return;
        if (this.#candle !== empty) {
            this.status = { status: STREAM_UPDATE, data: this.candle };
            this.status = { status: STREAM_LISTENING, data: this.#candle };
        }
    }
    newBounds() {
        if (this.lastPriceMax > this.range.valueHi ||
            this.lastPriceMin < this.range.valueLo) {
            this.range.set();
        }
    }
    newCandle(data) {
        this.prevCandle();
        this.#candle =
            [data.t,
                data.o,
                data.h,
                data.l,
                data.c,
                data.v,
                null, true];
        this.#state.mergeData({ ohlcv: [this.#candle] }, true, false);
        this.status = { status: STREAM_NEWVALUE, data: { data: data, candle: this.#candle } };
        this.#countDownMS = this.#state.timeFrame;
        this.#countDownStart = this.roundTime(data.ts);
    }
    prevCandle() {
        const d = this.#state.data.chart.data;
        if (d.length > 0 && d[d.length - 1][7])
            d[d.length - 1].length = 6;
    }
    updateCandle(data) {
        let candle = this.#candle;
        candle[O] = data.o;
        candle[H] = data.h;
        candle[L] = data.l;
        candle[C] = data.c;
        candle[V] = data.v;
        this.#candle = candle;
        const d = this.#state.data.chart.data;
        const l = (d.length > 0) ? d.length - 1 : 0;
        d[l] = this.#candle;
        if (this.#state?.isActive)
            this.countDownUpdate();
    }
    countDownUpdate() {
        let y, M, w, d, h, m, s;
        let tf = this.#state.timeFrame;
        let now = this.#data.ts;
        let cntDn = tf - (now - this.#countDownStart);
        if (cntDn < 0) {
            cntDn = 0;
        }
        this.#countDownMS = cntDn;
        if (cntDn > YEAR_MS$1) {
            y = String(Math.floor(cntDn / YEAR_MS$1));
            M = String(Math.floor((cntDn % YEAR_MS$1) / MONTHR_MS$1)).padStart(2, '0');
            this.#countDown = `${y}Y ${M}M`;
        }
        else if (cntDn > MONTHR_MS$1) {
            M = String(Math.floor(cntDn / MONTHR_MS$1)).padStart(2, '0');
            d = String(Math.floor((cntDn % MONTHR_MS$1) / DAY_MS$1)).padStart(2, '0');
            this.#countDown = `${M}M ${d}D`;
        }
        else if (cntDn > WEEK_MS) {
            w = String(Math.floor(cntDn / WEEK_MS)).padStart(2, '0');
            d = String(Math.floor((cntDn % MONTHR_MS$1) / DAY_MS$1)).padStart(2, '0');
            this.#countDown = `${w}W ${d}D`;
        }
        else if (cntDn > DAY_MS$1) {
            d = String(Math.floor(cntDn / DAY_MS$1)).padStart(2, '0');
            h = String(Math.floor((cntDn % DAY_MS$1) / HOUR_MS$1)).padStart(2, '0');
            m = String(Math.floor((cntDn % HOUR_MS$1) / MINUTE_MS$1)).padStart(2, '0');
            this.#countDown = `${d}D ${h}:${m}`;
        }
        else if (cntDn > HOUR_MS$1) {
            h = String(Math.floor(cntDn / HOUR_MS$1)).padStart(2, '0');
            m = String(Math.floor((cntDn % HOUR_MS$1) / MINUTE_MS$1)).padStart(2, '0');
            s = String(Math.floor((cntDn % MINUTE_MS$1) / SECOND_MS$1)).padStart(2, '0');
            this.#countDown = `${h}:${m}:${s}`;
        }
        else if (cntDn > MINUTE_MS$1) {
            m = String(Math.floor(cntDn / MINUTE_MS$1)).padStart(2, '0');
            s = String(Math.floor((cntDn % MINUTE_MS$1) / SECOND_MS$1)).padStart(2, '0');
            this.#countDown = `00:${m}:${s}`;
        }
        else {
            s = String(Math.floor(cntDn / SECOND_MS$1)).padStart(2, '0');
            String(cntDn % SECOND_MS$1).padStart(4, '0');
            this.#countDown = `00:00:${s}`;
        }
        return this.#countDown;
    }
    roundTime(ts) {
        return ts - (ts % this.#state.dataSource.timeFrame);
    }
}
function validateConfig(c) {
    if (!isObject(c))
        return defaultStreamConfig;
    else {
        let d = doStructuredClone(defaultStreamConfig);
        c = mergeDeep(d, c);
        c.tfCountDown = (isBoolean(c.tfCountDown)) ? c.tfCountDown : defaultStreamConfig.tfCountDown;
        c.alerts = (isArray(c.alerts)) ? c.alerts : defaultStreamConfig.alerts;
    }
    return c;
}
function throwError$2(id, e) {
    throw new Error(`TradeX-chart: ${id} : Ticker Stream : ${e}`);
}

class Dataset {
    #state;
    #id;
    #type;
    #data = [];
    constructor(state, ds) {
        this.#state = state;
        this.#id = (isString(ds.id)) ? ds.id : uid;
        this.#type = (isString(ds.type)) ? ds.type : "default";
        this.#data = (isArray(ds.data)) ? ds.data : [];
    }
}

class StateMachine {
    #id;
    #state;
    #statePrev;
    #context = {};
    #config;
    #core;
    #status = "stopped";
    #statusOld = "";
    #events;
    #event;
    #eventData;
    #actions;
    #guards;
    #statuses = ["await", "idle", "running", "stopped", "paused"];
    #statusNoExecute = ["stopped", "paused"];
    constructor(config, context) {
        this.#core = context.core;
        if (!StateMachine.validateConfig(config, this.#core)) {
            const msg = `StateMachine config is invalid`;
            this.#core?.error(msg);
            throw new Error(msg);
        }
        const cfg = doStructuredClone(config);
        this.id = cfg.id;
        this.#config = cfg;
        this.#state = cfg.initial;
        this.#context.origin = context;
        this.#actions = cfg?.actions || {};
        this.#guards = cfg?.guards || {};
        this.#subscribe();
    }
    set id(id) { this.#id = idSanitize(id); }
    get id() { return this.#id; }
    get state() { return this.#state; }
    get previousState() { return this.#statePrev; }
    get context() { return this.#context; }
    get core() { return this.#core; }
    get status() { return this.#status; }
    get event() { return this.#event; }
    get events() { return this.#events; }
    get eventData() { return this.#eventData; }
    get actions() { return this.#actions; }
    get guards() { return this.#guards; }
    getStateOverview() {
        return {
            current: this.#state,
            previous: this.#statePrev,
            context: this.#context,
            status: this.#status
        };
    }
    notify(event, data) {
        if (this.#noExecute()) {
            this.#core?.warn(`StateMachine not running. Status: ${this.#status}`);
            return false;
        }
        if (!isObject(this.#config))
            return false;
        this.#event = event;
        this.#eventData = data;
        const currentStateConfig = this.#config.states[this.#state];
        if (!currentStateConfig) {
            this.#core?.warn(`No config for state: ${this.#state}`);
            return false;
        }
        const destinationTransition = currentStateConfig.on[event] || currentStateConfig.on.always;
        if (destinationTransition) {
            try {
                const condition = destinationTransition?.condition || false;
                if (condition && !this.#transitionGuard.call(this, condition, data)) {
                    this.#core?.warn(`Condition prevents transition for state: ${this.#state}`);
                    return false;
                }
            }
            catch (error) {
                this.#core?.error(`Condition (guard) check generated an error: ${error.message}`);
                return false;
            }
            const action = destinationTransition?.action || false;
            if (!isFunction(action)) {
                if (isArray(action)) {
                    if (!this.#transitionActionValidate(action)) {
                        this.#core?.error(`Event ${event} actions are not functions`);
                        return false;
                    }
                }
                else if (!(action in this.#config.actions)) {
                    this.#core?.error(`Event ${event} action does not refer to an actions function`);
                    return false;
                }
                else {
                    this.#core?.error(`Event ${event} action is not an inline function`);
                    return false;
                }
            }
            const destinationState = destinationTransition?.target;
            if (!destinationState || !this.#config.states[destinationState]) {
                this.#core?.error(`Invalid destination state: ${destinationState}`);
                return false;
            }
            if (currentStateConfig?.onExit) {
                try {
                    currentStateConfig.onExit.call(this, data);
                }
                catch (error) {
                    this.#core?.error(`Error in onExit for state ${this.#state}: ${error.message}`);
                    return false;
                }
            }
            if (destinationTransition.action) {
                this.#transitionAction(destinationTransition.action, event, data);
            }
            this.#progressState(destinationState);
            const destinationStateConfig = this.#config.states[destinationState];
            if (destinationStateConfig?.onEnter) {
                try {
                    destinationStateConfig.onEnter.call(this, data);
                }
                catch (error) {
                    this.#core?.error(`Error in onEnter for state ${destinationState}: ${error.message}`);
                    return false;
                }
            }
        }
        return this.getStateOverview();
    }
    #noExecute() {
        return this.#statusNoExecute.includes(this.#status);
    }
    #progressState(target) {
        this.#statePrev = this.#state;
        this.#state = target;
    }
    #transitionAction(action, event = null, data = {}) {
        try {
            if (isArray(action)) {
                action.forEach(act => {
                    act = this.#processFunctions(this.#actions, action);
                    act.call(this, data);
                });
            }
            else {
                const act = this.#processFunctions(this.#actions, action);
                return act.call(this, data);
            }
        }
        catch (error) {
            this.#core?.error(`Error in ${event} action: ${error.message}`);
            return false;
        }
    }
    #transitionActionValidate(action) {
        if (isArray(action)) {
            return action.every(act => { this.#processFunctions(this.#actions, act); });
        }
        else {
            return this.#processFunctions(this.#actions, action);
        }
    }
    #transitionGuard(cond, event = null, data = {}) {
        try {
            if (isArray(cond)) {
                return cond.every(f => { this.#processFunctions(this.#guards, f); });
            }
            else {
                const func = this.#processFunctions(this.#guards, cond);
                return func.call(this, data);
            }
        }
        catch (error) {
            this.#core?.error(`Error in ${event} condition (guard): ${error.message}`);
            return false;
        }
    }
    #processFunctions(type, func) {
        if (!func)
            return false;
        let fn;
        if (isString(func)) {
            fn = type[func];
        }
        else if (isFunction(func)) {
            fn = func;
        }
        if (!fn)
            return false;
        return fn;
    }
    canTransition(event) {
        const currentStateConfig = this.#config.states[this.#state];
        return currentStateConfig && currentStateConfig.on && currentStateConfig.on[event] !== undefined;
    }
    can(event) {
        return this.canTransition(event);
    }
    is(state) {
        return this.state === state;
    }
    start() {
        if (this.#status !== "stopped") {
            this.#core?.warn(`StateMachine can only start from a stopped status`);
            return false;
        }
        this.#status = "running";
        return true;
    }
    stop() {
        this.#status = "stopped";
    }
    pause() {
        this.#statusOld = this.#status;
        this.#status = "paused";
    }
    resume() {
        if (this.#status === "stopped") {
            this.#core?.warn(`StateMachine cannot resume when stopped`);
            return false;
        }
        this.#status = this.#statusOld;
        return true;
    }
    destroy() {
        this.stop();
        this.#unsubscribe();
        this.#config = null;
        this.#context = null;
        this.#actions = null;
        this.#guards = null;
    }
    #subscribe() {
        this.#events = new Set();
        for (let state in this.#config.states) {
            const stateConfig = this.#config.states[state];
            if (!stateConfig.on)
                continue;
            for (let event in stateConfig.on) {
                if (event === '' || event === 'always')
                    continue;
                let cb = this.notify.bind(this, event);
                this.#events.add({ topic: event, cb });
                this.#core?.on(event, cb, this.context);
            }
        }
    }
    #unsubscribe() {
        const events = this.#events?.values();
        if (!events)
            return;
        for (let e of events) {
            this.#core?.off(e.topic, e.cb, this.context);
        }
        this.#events.clear();
    }
    static validateConfig(c, core) {
        if (!isObject(c)) {
            core?.error(`StateMachine config must be an object`);
            return false;
        }
        const required = ["id", "initial", "context", "states"];
        let keys = Object.keys(c);
        const missing = required.filter(r => !keys.includes(r));
        if (missing.length > 0) {
            core?.error(`StateMachine config is missing required properties: ${missing.join(', ')}`);
            return false;
        }
        if (!(c.initial in c.states)) {
            core?.error(`StateMachine config: the initial state '${c.initial}' is not found in states`);
            return false;
        }
        if (c.actions && !isObject(c.actions)) {
            core?.error(`StateMachine config: actions must be an object`);
            return false;
        }
        if (c.actions) {
            for (let actionName in c.actions) {
                if (!isFunction(c.actions[actionName])) {
                    core?.error(`StateMachine config: action '${actionName}' must be a function`);
                    return false;
                }
            }
        }
        if (c.guards && !isObject(c.guards)) {
            core?.error(`StateMachine config: guards must be an object`);
            return false;
        }
        if (c.guards) {
            for (let guardName in c.guards) {
                if (!isFunction(c.guards[guardName])) {
                    core?.error(`StateMachine config: guard '${guardName}' must be a function`);
                    return false;
                }
            }
        }
        for (let stateName in c.states) {
            const state = c.states[stateName];
            if (!isObject(state)) {
                core?.error(`StateMachine config: state '${stateName}' must be an object`);
                return false;
            }
            if ("onEnter" in state && !isFunction(state.onEnter)) {
                core?.error(`StateMachine config: onEnter for state '${stateName}' must be a function`);
                return false;
            }
            if ("onExit" in state && !isFunction(state.onExit)) {
                core?.error(`StateMachine config: onExit for state '${stateName}' must be a function`);
                return false;
            }
            if ("on" in state) {
                if (!isObject(state.on)) {
                    core?.error(`StateMachine config: transitions 'on' for state '${stateName}' must be an object`);
                    return false;
                }
                for (let eventName in state.on) {
                    const event = state.on[eventName];
                    if (!isObject(event) && !isArray(event)) {
                        core?.error(`StateMachine config: event '${eventName}' in state '${stateName}' must be object or array`);
                        return false;
                    }
                    if (isArray(event)) {
                        for (let i = 0; i < event.length; i++) {
                            const evt = event[i];
                            if (!StateMachine.#validateSingleTransition(evt, eventName, stateName, c, core))
                                return false;
                        }
                    }
                    else {
                        if (!StateMachine.#validateSingleTransition(event, eventName, stateName, c, core))
                            return false;
                    }
                }
            }
        }
        return true;
    }
    static #validateSingleTransition(event, eventName, stateName, cfg, core) {
        if (isObject(event) && !isArray(event)) {
            if (!isString(event.target)) {
                core?.error(`StateMachine config: event '${eventName}' in state '${stateName}' must have string target`);
                return false;
            }
            if (!(event.target in cfg.states)) {
                core?.error(`StateMachine config: target state '${event.target}' not found in states`);
                return false;
            }
            if ("action" in event) {
                return StateMachine.#validateFunction(event.action, "actions", eventName, stateName, cfg, core);
            }
            if ("condition" in event) {
                return StateMachine.#validateFunction(event.condition, "guards", eventName, stateName, cfg, core);
            }
        }
        return true;
    }
    static #validateFunction(func, type, eventName, stateName, cfg, core) {
        if (!func)
            return true;
        if (!["actions", "guards"].includes(type))
            return false;
        if (isArray(func)) {
            for (let i = 0; i < func.length; i++) {
                if (!StateMachine.#validateFunction(func[i], type, eventName, stateName, cfg, core)) {
                    return false;
                }
            }
            return true;
        }
        if (isString(func)) {
            if (!cfg[type] || !isFunction(cfg[type][func])) {
                core?.error(`StateMachine config: event '${eventName}'.${type} '${func}' in state '${stateName}' does not refer to a valid ${type} function`);
                return false;
            }
            return true;
        }
        if (isFunction(func)) {
            return true;
        }
        core?.error(`StateMachine config: event '${eventName}'.${type} in state '${stateName}' must be a function, string reference, or array`);
        return false;
    }
}

class Overlays {
    #core;
    #config;
    #parent;
    #chart;
    #list;
    #elOverlays;
    constructor(parent, list = []) {
        this.#parent = parent;
        this.#chart = parent.chart;
        this.#core = parent.core;
        this.#list = new xMap([...list]);
        this.addOverlays(list);
    }
    log(l) { this.#core.log(l); }
    info(i) { this.#core.info(i); }
    warn(w) { this.#core.warn(w); }
    error(e) { this.#core.error(e); }
    get core() { return this.#core; }
    get parent() { return this.#parent; }
    get layerConfig() { return this.#parent.layerConfig().layerConfig; }
    get list() { return this.#list; }
    get scale() { return this.#parent.parent.scale; }
    get time() { return this.#parent.parent.time; }
    start() {
        this.eventsListen();
    }
    destroy() {
        if (this.#list.size == 0)
            return;
        for (let k of this.#list.keys()) {
            this.removeOverlay(k);
        }
    }
    eventsListen() {
    }
    on(topic, handler, context = this) {
        this.#core.on(topic, handler, context);
    }
    off(topic, handler, context = this) {
        this.#core.off(topic, handler, context);
    }
    emit(topic, data) {
        this.#core.emit(topic, data);
    }
    get(overlay) {
        return this.#list.get(overlay);
    }
    addOverlays(overlays) {
        let result = [];
        let failed = [];
        let key, obj;
        for (let o of overlays) {
            try {
                obj = this.addOverlay(o[0], o[1]);
                key = obj.instance?.id || o[0];
                result.push([key, obj]);
            }
            catch (error) {
                failed.push({ key, error });
            }
        }
        if (failed.length)
            this.#core.error(`addOverlays() one or more overlays could not be added:`, failed);
        return result;
    }
    addOverlay(key, overlay) {
        const layer = new CEL.Layer(this.layerConfig);
        try {
            if (!overlay?.class?.isOverlay)
                throw new Error(`${overlay} is not an Overlay or a derivative`);
            if (isObject(overlay?.params))
                overlay.params.chart = this.#chart;
            else
                overlay.params = { chart: this.#chart };
            this.parent.viewport.addLayer(layer);
            overlay.layer = layer;
            overlay.instance = new overlay.class(layer, this.#parent.Timeline, this.#parent.Scale, this.#core.theme, overlay?.parent || this, overlay?.params);
            if (!isString(overlay.instance?.id))
                overlay.instance.id = String(key);
            this.#list.set(overlay.instance.id, overlay);
            return overlay;
        }
        catch (e) {
            layer.destroy();
            overlay.instance = undefined;
            this.#list.delete(key);
            let msg = `ERROR: Cannot instantiate ${key} overlay / indicator / tool : It will not be added to the chart.`;
            this.#core.error(msg);
            this.#core.error(e);
            throw new Error(msg, { cause: e });
        }
    }
    removeOverlay(key) {
        if (this.#list.has(key)) {
            const o = this.#list.get(key);
            if (!o.instance?.isIndicator)
                o.instance.destroy();
            o.layer.remove();
            this.#list.delete(key);
        }
    }
}

class chartGrid extends Overlay {
    constructor(target, xAxis = false, yAxis = false, theme, parent, params) {
        super(target, xAxis, yAxis, theme, parent, params);
        this.params.axes = params?.axes || "both";
    }
    set position(p) { this.target.setPosition(p[0], p[1]); }
    draw(axes) {
        if (!super.mustUpdate())
            return;
        axes = axes || this.params.axes;
        this.scene.clear();
        if (axes == "none")
            return;
        const ctx = this.scene.context;
        ctx.save();
        ctx.strokeStyle = this.core.theme.chart.GridColour || GridStyle.COLOUR_GRID;
        if (axes != "y") {
            const offset = 0;
            const xGrads = this.xAxis.xAxisGrads.values;
            for (let tick of xGrads) {
                let x = bRound(tick[1]);
                ctx.beginPath();
                ctx.moveTo(x + offset, 0);
                ctx.lineTo(x + offset, this.scene.height);
                ctx.stroke();
            }
        }
        if (axes != "x") {
            const yGrads = this.yAxis.yAxisGrads;
            for (let tick of yGrads) {
                let y = this.yAxis.yPos(tick[0]);
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(this.scene.width, y);
                ctx.stroke();
            }
        }
        ctx.restore();
        super.updated();
    }
    drawX() {
        this.draw("x");
        return;
    }
}

class chartCursor extends Overlay {
    #cursorPos = [0, 0];
    #update = true;
    #input;
    constructor(target, xAxis = false, yAxis = false, theme, parent, params) {
        super(target, xAxis, yAxis, theme, parent, params);
        this.core.on("main_mouseMove", this.onMouseMoveX, this);
        this.#input = new Input(this.target.viewport.container, { disableContextMenu: false });
        this.#input.on("pointermove", this.onMouseMove.bind(this));
        this.#input.on("pointerenter", this.onMouseMove.bind(this));
    }
    set position(p) { return; }
    get update() { return this.#update; }
    get always() { return true; }
    onMouseMoveX(e) {
        this.onMouseMove(e, true);
    }
    onMouseMove(e, b = false) {
        let t, x, y, pos = this.#cursorPos;
        if (isObject(e)) {
            t = e.timeStamp;
            x = Math.round(e.position.x);
            y = Math.round(e.position.y);
        }
        else {
            t = e[6];
            x = Math.round(e[0]);
            y = Math.round(e[1]);
        }
        if (b && pos[1] == y) {
            return;
        }
        if (pos[0] == x &&
            pos[1] == y) {
            return;
        }
        pos[0] = x;
        pos[1] = y;
        pos[6] = t;
        this.draw();
    }
    draw(drag = false) {
        const rect = this.target.viewport.container.getBoundingClientRect();
        let y = this.core.mousePos.y - rect.top;
        let x = this.core.mousePos.x - rect.left;
        if (!drag)
            x = this.xAxis.xPosSnap2CandlePos(x) + this.xAxis.scrollOffsetPx;
        this.scene.clear();
        const ctx = this.scene.context;
        ctx.save();
        ctx.setLineDash([5, 5]);
        const offset = this.xAxis.smoothScrollOffset || 0;
        ctx.strokeStyle = "#666";
        ctx.beginPath();
        ctx.moveTo(x + offset, 0);
        ctx.lineTo(x + offset, this.scene.height);
        ctx.stroke();
        if (this.chart.cursorActive) {
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.lineTo(this.scene.width, y);
            ctx.stroke();
        }
        ctx.restore();
        this.chart.scale.overlays.cursor.instance.scaleDraw();
    }
}
class ScaleCursor extends Overlay {
    #cursorPos = [0, 0];
    constructor(target, xAxis, yAxis, theme, parent, params) {
        parent = yAxis;
        yAxis = yAxis.yAxis;
        super(target, xAxis, yAxis, theme, parent, params);
        this.viewport = target.viewport;
    }
    set position(p) { this.target.setPosition(p[0], p[1]); }
    draw() { }
    scaleDraw() {
        if (!this.parent.parent.cursorActive)
            return;
        const rect = this.target.viewport.container.getBoundingClientRect();
        let y = this.core.mousePos.y - rect.top, price = this.parent.yPos2Price(y), nice = this.parent.nicePrice(price), options = {
            fontSize: this.theme.yAxis.fontSize * 1.05,
            fontWeight: this.theme.yAxis.fontWeight,
            fontFamily: this.theme.yAxis.fontFamily,
            txtCol: this.theme.yAxis.colourCursor,
            bakCol: this.theme.yAxis.colourCursorBG,
            paddingTop: 2,
            paddingBottom: 2,
            paddingLeft: 3,
            paddingRight: 3,
            width: this.viewport.width
        }, height = options.fontSize + options.paddingTop + options.paddingBottom, yPos = y - (height * 0.5);
        const ctx = this.scene.context;
        this.scene.clear();
        ctx.save();
        ctx.fillStyle = options.bakCol;
        ctx.fillRect(1, yPos, this.width, height);
        renderTextBG(ctx, `${nice}`, 1, yPos, options);
        ctx.restore();
    }
    erase() {
        this.scene.clear();
        this.target.viewport.render();
        return;
    }
}

class Graph {
    #core;
    #config;
    #theme;
    #parent;
    #chartPane;
    #viewport;
    #overlays;
    #elParent;
    #elViewport;
    #elCanvas;
    #layerWidth;
    constructor(parent, elViewport, overlays, node = false) {
        this.#parent = parent;
        this.#core = parent.core;
        this.#config = this.core.config;
        this.#theme = this.core.theme;
        this.#chartPane = this.getChartPane();
        this.#elParent = this.#parent.element;
        this.#elViewport = elViewport;
        this.createViewport(overlays, node);
    }
    get parent() { return this.#parent; }
    get chart() { return (this.#chartPane); }
    get core() { return this.#core; }
    get config() { return this.#config; }
    get width() { return this.#elParent.width; }
    get height() { return this.#elParent.height; }
    get dimensions() { return this.#elParent.dimensions; }
    set layerWidth(w) { this.#layerWidth = w || this.#elParent.width; }
    get layerWidth() { return this.#layerWidth; }
    get stateMachine() { return this.#parent.stateMachine; }
    get state() { return this.#core.getState(); }
    get data() { return this.#core.chartData; }
    get range() { return this.#core.range; }
    get stream() { return this.#core.stream; }
    get Timeline() { return this.#core.Timeline; }
    get xAxis() { return this.#core.Timeline.xAxis; }
    get Scale() { return this.#parent.scale; }
    get yAxis() { return this.#parent.scale.yAxis; }
    get viewport() { return this.#viewport; }
    get canvas() { return this.#elCanvas; }
    get overlays() { return this.#overlays; }
    get elViewport() { return this.#elViewport; }
    destroy() {
        this.#overlays.destroy();
        this.#viewport.destroy();
    }
    setSize(w, h, lw) {
        const oList = this.#overlays.list;
        this.#viewport.setSize(w, h);
        for (let [key, overlay] of oList) {
            overlay.instance.setSize(lw, h);
        }
        this.draw();
        this.render();
    }
    getChartPane() {
        let chartPane = this.parent;
        while (!!chartPane) {
            if (chartPane?.type !== "primaryPane" && chartPane?.type !== "secondaryPane")
                chartPane = chartPane?.parent;
            else
                break;
            if (chartPane === undefined)
                break;
        }
        return chartPane;
    }
    createViewport(overlays = [], node = false) {
        if (!isArray(overlays))
            overlays = [];
        const { width, height } = this.layerConfig();
        let viewport = (node) ? CEL.Node : CEL.Viewport;
        this.#viewport = new viewport({
            width: width,
            height: height,
            container: this.#elViewport
        });
        this.#elCanvas = this.#viewport.scene.canvas;
        this.#overlays = new Overlays(this, overlays);
    }
    layerConfig() {
        let viewportDims;
        if (isFunction(this.#elViewport?.getBoundingClientRect)) {
            viewportDims = this.#elViewport.getBoundingClientRect();
        }
        else
            viewportDims = this.#elViewport;
        const buffer = this.config?.buffer || BUFFERSIZE;
        const width = viewportDims.width;
        const height = viewportDims.height;
        this.layerWidth = Math.round(width * ((100 + buffer) * 0.01));
        const layerConfig = {
            width: this.layerWidth,
            height: height
        };
        return { width, height, layerConfig };
    }
    addOverlays(o) {
        return this.#overlays.addOverlays(o);
    }
    addOverlay(key, overlay) {
        return this.#overlays.addOverlay(key, overlay);
    }
    removeOverlay(key) {
        return this.#overlays.removeOverlay(key);
    }
    draw(range = this.range, update = false) {
        const fn = (k, overlay) => {
            if (!(overlay.instance instanceof Overlay))
                return;
            if (update)
                overlay.instance.setRefresh();
            if (isFunction(overlay.instance.draw))
                overlay.instance.draw();
            if (!overlay.fixed)
                overlay.instance.position = [this.#core.scrollPos, 0];
        };
        this.executeOverlayList(fn);
    }
    drawAll() {
        const fn = (k, o) => {
            if (!(o.instance instanceof Overlay))
                return;
            o.instance.setRefresh();
        };
        this.executeOverlayList(fn);
    }
    executeOverlayList(fn) {
        const oList = this.#overlays.list;
        if (!(oList instanceof xMap))
            return false;
        let result = [];
        for (let [key, overlay] of oList) {
            try {
                fn(key, overlay);
            }
            catch (e) {
                result.push({ overlay: key, error: e });
            }
        }
        if (result.length > 0) {
            for (let err of result) {
                this.#core.error(`ERROR: executeOverlayList() ${err.overlay}`);
                this.#core.error(err.error);
            }
        }
        else
            result = true;
        return result;
    }
    render() {
        if (this.overlays.list.has("tools"))
            this.overlays.list.get("tools").instance.render();
        this.#viewport.render();
    }
    refresh() {
        this.draw(this.range, true);
        this.render();
    }
}

class Component {
    #id;
    #core;
    #options;
    #parent;
    #stateMachine;
    #Graph;
    constructor(core, options = {}) {
        this.#core = core;
        this.#options = { ...options };
        this.#parent = this.#options?.parent;
    }
    log(l) { this.#core.log(l); }
    info(i) { this.#core.info(i); }
    warn(w) { this.#core.warn(w); }
    error(e) { this.#core.error(e); }
    set id(id) { this.#id = idSanitize(id); }
    get id() { return this.#id || `${this.#core.ID}-${this.name}`; }
    get core() { return this.#core; }
    get options() { return this.#options; }
    get config() { return this.#core.config; }
    get theme() { return this.core.theme; }
    get range() { return this.core.range; }
    get parent() { return this.#parent; }
    set stateMachine(config) { this.#stateMachine = new StateMachine(config, this); }
    get stateMachine() { return this.#stateMachine; }
    set graph(g) { if (g instanceof Graph)
        this.#Graph = g; }
    get graph() { return this.#Graph; }
    on(topic, handler, context = this) {
        this.#core.on(topic, handler, context);
    }
    off(topic, handler, context = this) {
        this.#core.off(topic, handler, context);
    }
    expunge(context = this) {
        this.#core.expunge(context);
    }
    emit(topic, data) {
        this.#core.emit(topic, data);
    }
}

var stateMachineConfig$5 = {
    id: "time",
    initial: "idle",
    context: {},
    states: {
        idle: {
            onEnter(data) {
            },
            onExit(data) {
            },
            on: {
                chart_pan: {
                    target: 'chart_pan',
                    action(data) {
                    },
                },
            }
        },
        resize: {
            onEnter(data) {
            },
            onExit(data) {
            },
            on: {}
        },
        chart_pan: {
            onEnter(data) {
            },
            onExit(data) {
            },
            on: {
                chart_pan: {
                    target: 'chart_pan',
                    action(data) {
                    },
                },
                chart_panDone: {
                    target: 'idle',
                    action(data) {
                    },
                },
            }
        },
    },
    guards: {},
};

class Slider {
    static #cnt;
    #id;
    #core;
    #elContainer;
    #elHandle;
    #containerDims = { w: 0, h: 0 };
    #handleDims = { w: 0, h: 0, x: 0, y: 0 };
    #constraint = { x: false, y: true };
    #cursorPos;
    #sliderPos = { x: 0, drag: false };
    #input;
    #callback;
    constructor(config) {
        this.#id = Slider.#cnt++;
        this.#core = config.core;
        this.#elContainer = (isHTMLElement(config.elContainer)) ? config.elContainer : false;
        this.#elHandle = (isHTMLElement(config.elHandle)) ? config.elHandle : false;
        this.#callback = (isFunction(config.callback)) ? config.callback : false;
        if (isHTMLElement(this.#elContainer) && isHTMLElement(this.#elHandle)) {
            this.mount();
            this.eventsListen();
        }
    }
    set cursor(c) { this.#elHandle.style.cursor = c; }
    get cursor() { return this.#elHandle.style.cursor; }
    eventsListen() {
        this.#input = new Input(this.#elHandle, { disableContextMenu: false });
        this.#input.on("mouseenter", debounce(this.onMouseEnter, 1, this, true));
        this.#input.on("mouseout", debounce(this.onMouseOut, 1, this, true));
        this.#input.on("drag", throttle(this.onHandleDrag, 100, this));
        this.#input.on("enddrag", this.onHandleDragDone.bind(this));
        this.#input.on("mousedown", debounce(this.onMouseDown, 100, this, true));
        this.#input.on("mouseup", this.onMouseUp.bind(this));
    }
    on(topic, handler, context = this) {
        this.#core.on(topic, handler, context);
    }
    off(topic, handler, context = this) {
        this.#core.off(topic, handler, context);
    }
    emit(topic, data) {
        this.#core.emit(topic, data);
    }
    onMouseEnter() {
        const backgroundColor = getComputedStyle(this.#elHandle).backgroundColor;
        if (backgroundColor) {
            this.colour = new Colour(backgroundColor);
            this.#elHandle.style.backgroundColor = this.colour.hex;
        }
    }
    onMouseOut() {
        this.#elHandle.style.backgroundColor = this.colour.hexa;
    }
    onMouseDown() {
    }
    onMouseUp(e) {
        this.onHandleDragDone(e);
    }
    onHandleDrag(e) {
        if (!this.#sliderPos.drag) {
            this.#sliderPos.drag = true;
            this.#sliderPos.x = e.position.x;
        }
        this.handlePos(e);
    }
    onHandleDragDone(e) {
        this.handlePos(e);
        this.#sliderPos.drag = false;
    }
    mount() {
        this.#containerDims.w = this.#elContainer.getBoundingClientRect().width;
        this.#containerDims.h = this.#elContainer.getBoundingClientRect().height;
        this.#elContainer.style.overflow = "hidden";
        this.#handleDims.w = this.#elHandle.getBoundingClientRect().width;
        this.#handleDims.h = this.#elHandle.getBoundingClientRect().height;
        this.#elHandle.style.marginRight = 0;
        this.#elHandle.style.position = "absolute";
    }
    handlePos(e) {
        let R = this.#core.range;
        let x = parseInt(this.#elHandle.style.marginLeft);
        let w = this.#elContainer.getBoundingClientRect().width;
        let h = this.#elHandle.getBoundingClientRect().width;
        let m = w - h;
        let d = e.position.x - this.#sliderPos.x;
        let p = limit(x + d, 0, m);
        let r = (R.dataLength + R.limitFuture + R.limitPast) / w;
        let s = Math.floor(p * r);
        this.setHandleDims(p, h);
        this.#core.jumpToIndex(s);
    }
    setHandleDims(p, w) {
        let c = this.#elContainer.getBoundingClientRect().width;
        w = w || this.#elHandle.getBoundingClientRect().width;
        p = p / c * 100;
        this.#elHandle.style.marginLeft = `${p}%`;
        w = w / c * 100;
        this.#elHandle.style.width = `${w}%`;
    }
}

class TimeLabels extends Overlay {
    #cursorPos = [0, 0];
    #xAxisGrads;
    #charW;
    constructor(target, xAxis = false, yAxis = false, theme, parent, params) {
        xAxis = parent.time.xAxis;
        super(target, xAxis, yAxis, theme, parent);
    }
    set position(p) { this.target.setPosition(p[0], p[1]); }
    draw(range) {
        if (!super.mustUpdate())
            return;
        this.scene.clear();
        const ctx = this.scene.context;
        const grads = this.xAxis.xAxisGrads.values;
        const offset = 0;
        const theme = this.theme.xAxis;
        const tickMarker = (isBoolean(theme.tickMarker)) ? theme.tickMarker : true;
        this.#charW = this.#charW || ctx.measureText(`M`).width;
        ctx.save();
        ctx.strokeStyle = theme.colourTick;
        ctx.fillStyle = theme.colourTick;
        ctx.font = `${theme.fontWeight} ${theme.fontSize}px ${theme.fontFamily}`;
        for (let tick of grads) {
            let x = tick[1];
            let w = Math.floor(tick[0].length * this.#charW * 0.5);
            ctx.fillText(tick[0], x - w + offset, this.xAxis.xAxisTicks + 12);
            if (tickMarker) {
                ctx.beginPath();
                ctx.moveTo(x + offset, 0);
                ctx.lineTo(x + offset, this.xAxis.xAxisTicks);
                ctx.stroke();
            }
        }
        ctx.restore();
        super.updated();
    }
}

class TimeOverlays extends Overlay {
    #cursorPos = [0, 0];
    #xAxisGrads;
    constructor(target, xAxis = false, yAxis = false, theme, parent, params) {
        xAxis = parent.time.xAxis;
        super(target, xAxis, yAxis, theme, parent);
    }
    set position(p) { this.target.setPosition(p[0], p[1]); }
    draw() {
        this.scene.clear();
        const ctx = this.scene.context;
        this.xAxis.xAxisGrads.values;
        this.theme.xAxis;
        ctx.save();
        ctx.restore();
    }
}

class TimeCursor extends Overlay {
    #cursorPos = [0, 0];
    #dateStrW;
    #opts;
    constructor(target, xAxis = false, yAxis = false, theme, parent) {
        xAxis = parent.time.xAxis;
        super(target, xAxis, yAxis, theme, parent);
        this.viewport = target.viewport;
        this.#opts = {
            fontSize: this.theme.xAxis.fontSize * 1.05,
            fontWeight: this.theme.xAxis.fontWeight,
            fontFamily: this.theme.xAxis.fontFamily,
            txtCol: this.theme.xAxis.colourCursor,
            bakCol: this.theme.xAxis.colourCursorBG,
            paddingTop: 5,
            paddingBottom: 3,
            paddingLeft: 4,
            paddingRight: 4,
        };
    }
    set position(p) { this.target.setPosition(p[0], p[1]); }
    dateUTCStringW() {
        if (!this.#dateStrW) {
            let ctx = this.scene.context, dateTimeStr = `Wed, 28 Aug 2024 20:00:00 GMT`;
            this.#dateStrW = getTextRectWidth(ctx, dateTimeStr, this.#opts);
        }
        return this.#dateStrW;
    }
    draw() {
        const ctx = this.scene.context;
        const rect = this.target.viewport.container.getBoundingClientRect();
        const x = this.core.mousePos.x - rect.left;
        let timestamp = this.xAxis.xPos2Time(x), date = new Date(timestamp), dateTimeStr = date.toUTCString(), txtW = this.dateUTCStringW(), xPos = x + this.core.bufferPx;
        xPos = this.xAxis.xPosSnap2CandlePos(xPos);
        xPos = xPos - Math.round(txtW * 0.5) - this.core.scrollPos - this.core.bufferPx;
        this.scene.clear();
        ctx.save();
        renderTextBG(ctx, dateTimeStr, xPos, 1, this.#opts);
        ctx.restore();
    }
}

const defaultOverlays$3 = [
    ["labels", { class: TimeLabels, fixed: false, required: true }],
    ["overlay", { class: TimeOverlays, fixed: false, required: true }],
    ["cursor", { class: TimeCursor, fixed: false, required: true }],
];
class Timeline extends Component {
    #name = "Timeline";
    #shortName = "time";
    #chart;
    #xAxis;
    #stateMachine;
    #element;
    #elViewport;
    #elNavigation;
    #elNavList;
    #elNavScrollBar;
    #elNavScrollHandle;
    #elRwdStart;
    #elFwdEnd;
    #Graph;
    #timeOverlays = new xMap();
    #additionalOverlays = [];
    #navigation;
    #layerLabels;
    #layerOverlays;
    #layerCursor;
    #input;
    #input2;
    #input3;
    #input4;
    #slider;
    #icons = {
        width: 20,
        height: 20,
        fill: "#aaa"
    };
    #jump = { end: false, start: false };
    constructor(core, options) {
        super(core, options);
        this.#element = options.elements.elTime;
        this.#chart = core.Chart;
        this.#xAxis = new xAxis(this);
        this.init();
    }
    get name() { return this.#name; }
    get shortName() { return this.#shortName; }
    get element() { return this.#element; }
    get elViewport() { return this.#elViewport; }
    get height() { return this.#element.height; }
    set width(w) { this.setWidth(w); }
    get width() { return this.#element.width; }
    get xAxis() { return this.#xAxis; }
    get xAxisWidth() { return this.#xAxis.width; }
    get xAxisRatio() { return this.#xAxis.xAxisRatio; }
    get layerCursor() { return this.#layerCursor; }
    get layerLabels() { return this.#layerLabels; }
    get layerOverlays() { return this.#layerOverlays; }
    get overlays() { return Object.fromEntries([...this.graph.overlays.list]); }
    get xAxisGrads() { return this.#xAxis.xAxisGrads; }
    get candleW() { return this.#xAxis.candleW; }
    get candlesOnLayer() { return this.#xAxis.candlesOnLayer; }
    get navigation() { return this.#navigation; }
    get pos() { return this.dimensions; }
    get dimensions() { return elementDimPos(this.#element); }
    get bufferPx() { return this.core.bufferPx; }
    get scrollPos() { return this.core.scrollPos; }
    get scrollOffsetPx() { return this.core.scrollPos % this.candleW; }
    get smoothScrollOffset() { return this.core.smoothScrollOffset; }
    get rangeScrollOffset() { return this.core.rangeScrollOffset; }
    get time() { return this; }
    init() {
        const el = this.#element;
        this.#elViewport = el.viewport;
        this.#elNavigation = el.overview;
        this.#elNavList = el.overview.icons;
        this.#elNavScrollBar = el.overview.scrollBar;
        this.#elNavScrollHandle = el.overview.handle;
        this.#elRwdStart = el.overview.rwdStart;
        this.#elFwdEnd = el.overview.fwdEnd;
        const sliderCfg = {
            core: this.core,
            elContainer: this.#elNavScrollBar,
            elHandle: this.#elNavScrollHandle,
            callback: null
        };
        this.#slider = new Slider(sliderCfg);
        if (this.core.theme?.time?.navigation === false)
            this.navigationDisplay(false);
    }
    setWidth(w) {
        this.#element.style.width = `${w}px`;
        this.#elViewport.style.width = `${w}px`;
    }
    setDimensions(dim) {
        const buffer = this.config.buffer || BUFFERSIZE;
        const width = dim.w;
        const height = this.height;
        const layerWidth = Math.round(width * ((100 + buffer) * 0.01));
        this.graph.setSize(width, height, layerWidth);
        this.draw();
    }
    navigationDisplay(visible) {
        if (visible) {
            this.#elFwdEnd.style['margin-top'] = 0;
            this.#elRwdStart.style['margin-top'] = 0;
        }
        else {
            const background = (this.core.theme.xAxis?.background) ?
                this.core.theme.xAxis.Background : this.core.theme.chart.Background;
            this.#elNavigation.style.visibility = "hidden";
            this.#elFwdEnd.style['margin-top'] = `${this.#elViewport.clientHeight * -1}px`;
            this.#elRwdStart.style['margin-top'] = `${this.#elViewport.clientHeight * -1}px`;
            this.#elFwdEnd.style.background = this.core.theme.chart.Background;
            this.#elRwdStart.style.background = background;
        }
    }
    start() {
        this.createGraph();
        this.onSetRange();
        this.#xAxis.initXAxisGrads();
        this.draw();
        this.eventsListen();
        stateMachineConfig$5.id = this.id;
        stateMachineConfig$5.context = this;
        this.stateMachine = stateMachineConfig$5;
        this.stateMachine.start();
        this.log(`Timeline ${this.#name} instantiated and running`);
    }
    destroy() {
        this.stateMachine.destroy();
        this.#input.destroy();
        this.#input2.destroy();
        this.#input3.destroy();
        this.core.hub.expunge(this);
        this.off("main_mouseMove", this.#layerCursor.draw, this.#layerCursor);
        this.#elFwdEnd.removeEventListener('click', debounce);
        this.#elRwdStart.removeEventListener('click', debounce);
        this.graph.destroy();
    }
    eventsListen() {
        this.#input = new Input(this.#elViewport, { disableContextMenu: false });
        this.#input.on("dblclick", this.onDoubleClick.bind(this));
        this.#input.on("pointerover", this.onPointerEnter.bind(this));
        this.#input.on("pointerout", this.onPointerLeave.bind(this));
        this.#input.on("pointerdrag", this.onPointerDrag.bind(this));
        this.#input2 = new Input(this.#elFwdEnd, { disableContextMenu: false });
        this.#input2.on("pointerover", () => this.showJump(this.#jump.end));
        this.#input2.on("pointerleave", () => this.hideJump(this.#jump.end));
        this.#input3 = new Input(this.#elRwdStart, { disableContextMenu: false });
        this.#input3.on("pointerover", () => this.showJump(this.#jump.start));
        this.#input3.on("pointerleave", () => this.hideJump(this.#jump.start));
        this.on("main_mouseMove", this.#layerCursor.draw, this.#layerCursor);
        this.on("range_set", this.onSetRange, this);
        this.#elFwdEnd.addEventListener('click', debounce(this.onPointerClick, 1000, this, true));
        this.#elRwdStart.addEventListener('click', debounce(this.onPointerClick, 1000, this, true));
    }
    onPointerClick(e) {
        const id = e?.currentTarget?.id || e.target.parentElement.id;
        switch (id) {
            case "fwdEnd":
                this.onFwdEnd();
                break;
            case "rwdStart":
                this.onRwdStart();
                break;
        }
    }
    onPointerEnter(e) {
        e.domEvent.target.style.cursor = "ew-resize";
        this.#elNavigation.style.visibility = "visible";
        this.hideCursorTime();
    }
    onPointerLeave(e) {
        if (this.core.theme?.time?.navigation === false &&
            !(this.#jump.end && this.#jump.start)) {
            this.#elNavigation.style.visibility = "hidden";
        }
    }
    onPointerDrag(e) {
        let r = this.range;
        let start = r.indexStart - e.movement.x;
        let end = r.indexEnd;
        r.set(start, end);
    }
    onDoubleClick(e) {
        this.core.jumpToEnd();
        this.core.MainPane.draw(undefined, true);
    }
    onFwdEnd() {
        this.core.jumpToEnd();
        this.core.MainPane.draw(undefined, true);
    }
    onRwdStart() {
        this.core.jumpToStart();
        this.core.MainPane.draw(undefined, true);
    }
    onSetRange() {
        let r = this.range;
        let start = r.indexStart;
        r.indexEnd;
        let scrollBarW = this.#elNavScrollBar.getBoundingClientRect().width;
        let rangeW = r.dataLength + r.limitFuture + r.limitPast;
        let ratio = scrollBarW / rangeW;
        let handleW = r.Length * ratio;
        let pos = ((start + r.limitPast) * ratio);
        this.#slider.setHandleDims(pos, handleW);
    }
    t2Index(ts) { return this.#xAxis.t2Index(ts); }
    xPos(time) { return this.#xAxis.xPos(time); }
    xPosSnap2CandlePos(x) { return this.#xAxis.xPosSnap2CandlePos(x); }
    xPos2Time(x) { return this.#xAxis.xPos2Time(x); }
    xPos2Index(x) { return this.#xAxis.xPos2Index(x); }
    xPosOHLCV(x) { return this.#xAxis.xPosOHLCV(x); }
    createGraph() {
        let overlays = doStructuredClone(defaultOverlays$3);
        this.graph = new Graph(this, this.#elViewport, overlays, false);
        this.#layerCursor = this.graph.overlays.get("cursor").instance;
        this.#layerLabels = this.graph.overlays.get("labels").instance;
        this.#layerOverlays = this.graph.overlays.get("overlay").instance;
        this.graph.addOverlays(this.#additionalOverlays);
    }
    addOverlays(overlays) {
        if (!isArray(overlays))
            return false;
        if (this.graph === undefined)
            this.#additionalOverlays.push(...overlays);
        else
            this.graph.addOverlays(overlays);
    }
    addOverlay(key, overlay) {
        if (!isObject(overlay))
            return false;
        if (this.graph === undefined)
            this.#additionalOverlays.push([key, overlay]);
        else {
            try {
                return this.graph.addOverlay(key, overlay);
            }
            catch (error) {
                this.error(`Timeline: Error attempting to add overlay ${key}`);
                this.error(error);
                return null;
            }
        }
    }
    render() {
        this.graph.render();
    }
    draw(range = this.range, update = true) {
        this.graph.draw(range, update);
    }
    hideCursorTime() {
        this.graph.overlays.list.get("cursor").layer.visible = false;
        this.core.MainPane.draw();
    }
    showCursorTime() {
        this.graph.overlays.list.get("cursor").layer.visible = true;
        this.core.MainPane.draw();
    }
    hideJump(j) {
        if (this.core.theme?.time?.navigation === false)
            this.#elNavigation.style.visibility = "hidden";
    }
    showJump(j) {
        this.#elNavigation.style.visibility = "visible";
        this.hideCursorTime();
    }
}

class RenderLoop {
    constructor(config) {
        this.renderQ = new xMap();
        this.rendered = [];
        this.renderLog = false;
        this.dropFrames = true;
        this.graphs = [];
        this.range = {};
        this.status = false;
        this.core = undefined;
        if (!isObject(config))
            throw new Error(`class RenderLoop requires a config of type object`);
        this.renderLog = config?.renderLog || false;
        this.dropFrames = config?.dropFrames || true;
        this.graphs = (isArray(config?.graphs)) ? [...config.graphs] : [];
        this.range = (isObject(config?.range)) ? config.range : {};
        this.core = config?.core || this.range?.core;
    }
    queueFrame(range = this.range, graphs = this.graphs, update = false) {
        if (this.renderQ.size > 1 && this.dropFrames)
            update = this.dropFrame() || update;
        const frameID = performance.now();
        range = range.snapshot();
        this.renderQ.set(frameID, { graphs, range, update });
        return frameID;
    }
    dropFrame(frame = -1) {
        let update = false;
        if (frame === -1)
            frame = this.renderQ.lastKey();
        if (this.renderQ.size > 1 && this.renderQ.has(frame)) {
            update = this.renderQ.get(frame).update;
            this.renderQ.delete(frame);
        }
        return update;
    }
    expungeFrames() {
        this.renderQ.clear();
    }
    getFrame(frame = 0) {
        if (this.renderQ.has(frame))
            return this.renderQ.get(frame);
        else
            return this.renderQ.firstValue();
    }
    frameDone() {
        if (this.renderQ.size === 0)
            return;
        const key = this.renderQ.firstKey();
        if (this.renderLog)
            this.rendered.push([key, performance.now()]);
        this.renderQ.delete(key);
    }
    start() {
        this.status = true;
        requestAnimationFrame(this.execute.bind(this));
    }
    stop() {
        this.status = false;
        this.renderQ.clear();
    }
    execute() {
        if (!this.status)
            return;
        try {
            requestAnimationFrame(this.execute.bind(this));
            if (this.renderQ.size === 0)
                return;
            const [ID, frame] = this.renderQ.firstEntry();
            if (!frame.range?.snapshot)
                return;
            for (let graph of frame.graphs) {
                if (isFunction(graph.draw) &&
                    graph?.status !== "destroyed")
                    graph.draw(frame.range, frame.update);
                if (isFunction(graph.render) &&
                    graph?.status !== "destroyed")
                    graph.render();
            }
            this.frameDone();
        }
        catch (error) {
            this.core.error(error);
        }
    }
}

const userSelect = [
    "-webkit-touch-callout",
    "-webkit-user-select",
    "-khtml-user-select",
    "-moz-user-select",
    "-ms-user-select",
    "user-select",
];
class Legends {
    #elTarget;
    #parent;
    #core;
    #theme;
    #input;
    #controls;
    #collapse;
    #collapseList = [];
    #controlsList;
    #list = {};
    #show;
    #hide;
    #toggle = "hide";
    constructor(target, parent) {
        this.#elTarget = target;
        this.#parent = parent;
        this.#core = parent.core;
        this.#theme = parent.core.theme.legend;
        this.init();
        this.eventsListen();
    }
    get elTarget() { return this.#elTarget; }
    get list() { return this.#list; }
    set collapse(c) { this.setCollapse(c); }
    get collapse() { return this.#collapse; }
    get visible() { return this.getVisible(); }
    getVisible() {
        const style = getComputedStyle(this.#elTarget);
        return style.display && style.visibility;
    }
    destroy() {
        this.#core.hub.expunge(this);
        for (let l in this.#list) {
            if (l === "collapse")
                continue;
            this.remove(l);
        }
        this.#elTarget.remove();
    }
    eventsListen() {
        this.#core.on("chart_pan", this.primaryPanePan, this);
        this.#core.on("chart_panDone", this.primaryPanePanDone, this);
    }
    init() {
        const legends = this.#elTarget.legends;
        this.#controls = legends.querySelector(`.controls`);
        this.#collapse = legends.querySelectorAll(`.control`);
        this.#show = legends.querySelector("#showLegends");
        this.#hide = legends.querySelector("#hideLegends");
        this.#controls.style.display = "none";
        this.icons(this.#collapse, { id: "collapse", parent: this });
        this.#elTarget.legends.classList.add("hide");
        this.#toggle = "hide";
        this.collapse = "show";
    }
    onPointerClick(e) {
        const which = (s) => {
            if (isString(s.dataset.icon))
                return { id: s.id, icon: s.dataset.icon, parent: s.parentElement };
            else if (s.parentElement.className !== "controls")
                return which(s.parentElement);
            else
                return { icon: "none" };
        };
        return which(e);
    }
    onMouseOver(e) {
    }
    onLegendAction(e) {
        const which = this.onPointerClick(e.currentTarget);
        this.setCollapse(which.icon);
    }
    setCollapse(c) {
        if (c === "show" && this.#toggle !== "show") {
            this.#toggle = c;
            this.#show.style.display = "none";
            this.#hide.style.display = "inline-block";
            this.#elTarget.legends.classList.toggle("hide");
        }
        else if (c === "hide" && this.#toggle !== "hide") {
            this.#toggle = c;
            this.#show.style.display = "inline-block";
            this.#hide.style.display = "none";
            this.#elTarget.legends.classList.toggle("hide");
        }
    }
    primaryPanePan() {
        for (let property of userSelect) {
            this.#elTarget.style.setProperty(property, "none");
        }
    }
    primaryPanePanDone() {
        for (let property of userSelect) {
            this.#elTarget.style.removeProperty(property);
        }
    }
    add(options) {
        if (!isObject(options))
            return undefined;
        const parentError = () => { this.#core.error("ERROR: Legend parent missing!"); };
        options.id = options?.id || uid("legend");
        options.type = options?.type || "overlay";
        options.title = options?.title || options?.parent.legendName;
        options.parent = options?.parent || parentError;
        options.visible = (isBoolean(options?.visible)) ? options.visible : true;
        const html = this.elTarget.buildLegend(options, this.#core.theme);
        this.#elTarget.legends.insertAdjacentHTML('beforeend', html);
        const legendEl = this.#elTarget.legends.querySelector(`#legend_${options.id}`);
        this.#controlsList = legendEl.querySelectorAll(`.control`);
        this.#list[options.id] = {
            el: legendEl,
            type: options.type,
            source: options?.source,
            click: []
        };
        this.icons(this.#controlsList, options);
        if (options.type == "indicator") {
            this.#controls.style.display = "block";
            if (!options.parent.primaryPane &&
                Object.keys(this.#list).length < 3)
                this.#controls.style.display = "none";
        }
        legendEl.style.display = (options.visible) ? "block" : "none";
        return options.id;
    }
    remove(id) {
        if (!(id in this.#list)
            || this.#list[id].type === "chart")
            return false;
        this.#list[id].el.remove();
        for (let c of this.#list[id].click) {
            c.el.removeEventListener('click', c.click);
        }
        delete this.#list[id];
        if (Object.keys(this.#list).length < 2)
            this.#controls.style.display = "none";
        return true;
    }
    update(id, data) {
        if (!(isObject(data)) ||
            !(id in this.#list) ||
            this.#core.range.data.length == 0)
            return false;
        let source = this.#list[id].source(data.pos);
        const html = this.#elTarget.buildInputs(source);
        this.#elTarget.legends.querySelector(`#legend_${id} dl`).innerHTML = html;
    }
    modify(id, properties) {
        if (!(id in this.#list) ||
            !(isObject(properties)))
            return false;
        const el = this.#list[id].el;
        for (let p in properties) {
            switch (p) {
                case "legendName":
                    const title = el.querySelectorAll(".title");
                    title[0].innerHTML = properties[p];
                    title[1].innerHTML = properties[p];
                    return true;
                case "legendVisibility":
                    const display = (!!properties[p]) ? "block" : "none";
                    const visible = (!!properties[p]) ? "visible" : "hidden";
                    el.style.display = display;
                    el.style.visibility = visible;
                    return true;
            }
        }
    }
    icons(icons, options) {
        let click;
        for (let el of icons) {
            let svg = el.querySelector('svg');
            svg.style.width = `${this.#theme.controlsW}px`;
            svg.style.height = `${this.#theme.controlsH}px`;
            svg.style.fill = `${this.#theme.controlsColour}`;
            svg.onpointerover = (e) => e.currentTarget.style.fill = this.#theme.controlsOver;
            svg.onpointerout = (e) => e.currentTarget.style.fill = this.#theme.controlsColour;
            click = options.parent.onLegendAction.bind(options.parent);
            if (options.id === "collapse")
                this.#collapseList.push({ el, click });
            else
                this.#list[options.id].click.push({ el, click });
            el.addEventListener('click', debounce(click, 1000, this, true));
        }
    }
}

var stateMachineConfig$4 = {
    id: "chart",
    initial: "idle",
    context: {},
    states: {
        idle: {
            onEnter(data) {
                this.context.origin.cursor = "crosshair";
            },
            onExit(data) {
            },
            on: {
                xAxis_scale: {
                    target: 'xAxis_scale',
                    action(data) {
                    },
                },
                chart_yAxisRedraw: {
                    target: 'chart_yAxisRedraw',
                    action(data) {
                    },
                },
                tool_activated: {
                    target: 'tool_activated',
                    action(data) {
                        this.context.origin.cursor = "default";
                    },
                },
            }
        },
        xAxis_scale: {
            onEnter(data) {
            },
            onExit(data) {
            },
            on: {
                Idle: {
                    target: 'idle',
                    action(data) {
                    },
                },
            }
        },
        chart_yAxisRedraw: {
            onEnter(data) {
            },
            onExit(data) {
            },
            on: {
                always: {
                    target: 'idle',
                    condition: 'yAxisRedraw',
                    action(data) {
                        this.context.origin.drawGrid();
                    },
                },
            }
        },
        tool_activated: {
            onEnter(data) {
            },
            onExit(data) {
            },
            on: {
                tool_targetSelected: {
                    target: 'idle',
                    condition: 'toolSelectedThis',
                    action(data) {
                        console.log("tool_targetSelected:", data);
                    },
                },
            }
        },
    },
    guards: {
        priceMaxMin() { return true; },
        toolSelectedThis(conditionType, condition) {
            if (this.eventData === this.context)
                return true;
            else
                return false;
        },
        yAxisRedraw() { return true; },
        zoomDone() { return true; },
    }
};

var _a$1;
class NodeState {
    static { this.idle = new NodeState("idle"); }
    static { this.hover = new NodeState("hover"); }
    static { this.selected = new NodeState("selected"); }
    static { this.active = new NodeState("active"); }
    constructor(name) {
        this.name = name;
    }
}
class ToolNode {
    static #cnt = 1;
    static get cnt() { return _a$1.#cnt++; }
    #id;
    #inCnt = _a$1.cnt;
    #state = NodeState.idle;
    #chart;
    #layer;
    #scene;
    #hit;
    #ctx;
    #ctxH;
    #hitV;
    #hitRGB;
    #theme;
    #themeDefault = doStructuredClone(drawingNode);
    #constraint = { x: false, y: false, fn: undefined };
    #tracking = [];
    #x;
    #y;
    constructor(id, x, y, constraint, tracking, layer, chart, theme = drawingNode) {
        this.#id = idSanitize(id) || uid("TX_Node_") + `_${this.#inCnt}`;
        this.x = x;
        this.y = y;
        this.#chart = chart;
        this.#layer = layer;
        this.#scene = layer.scene;
        this.#hit = layer.hit;
        this.#ctx = layer.scene.context;
        this.#ctxH = layer.hit.context;
        this.#hitV = this.#inCnt;
        this.#hitRGB = layer.hit.getIndexToRGB(this.#hitRGB);
        this.constraint = constraint;
        this.#tracking = tracking;
        const themed = (isObject(theme)) ? doStructuredClone(theme) : drawingNode;
        this.#theme = mergeDeep(this.#themeDefault, themed);
        this.eventsListen();
    }
    destroy() {
        this.#chart.expunge(this);
    }
    get id() { return this.#id; }
    get inCnt() { return this.#inCnt; }
    set state(s) { this.setState(s); }
    get state() { return this.#state; }
    get isActive() { return this.#state === NodeState.active; }
    get isSelected() { return this.#state === NodeState.selected; }
    get isHover() { return this.#state === NodeState.hover; }
    get isidle() { return this.#state === NodeState.idle; }
    get isConstrained() { return this.isNodeConstrained(); }
    get isTracking() { return this.#tracking; }
    set isTracking(t) { if (this.isArrayOfNodes(t))
        this.#tracking = t; }
    get core() { return this.#chart.core; }
    get chart() { return this.#chart; }
    get layer() { return this.#layer; }
    get scene() { return this.#scene; }
    get hit() { return this.#hit; }
    get ctx() { return this.#ctx; }
    get ctxH() { return this.#ctxH; }
    get hitV() { return this.#hitV; }
    get hitRGB() { return this.#hitRGB; }
    get theme() { return this.#theme; }
    get themeState() { return this.#theme[this.#state.name]; }
    set x(x) { if (isNumber(x))
        this.#x = x; }
    get x() { return this.#x; }
    set y(y) { if (isNumber(y))
        this.#y = y; }
    get y() { return this.#y; }
    set constraint(c) { this.setConstraint(c); }
    get constraint() { return this.#constraint; }
    setState(s) {
        if (!(s in NodeState))
            return;
        this.#state = NodeState[s];
    }
    setConstraint(c) {
        if (!isObject(c))
            return false;
        this.#constraint.x = (isNumber(c?.x)) ? c.x : false;
        this.#constraint.y = (isNumber(c?.y)) ? c.y : false;
        this.#constraint.fn = (isFunction(c?.fn)) ? c.fn : undefined;
    }
    eventsListen() {
        let core = this.core;
        let chart = this.#chart;
        core.on(`${chart.id}_pointerMove`, this.onPointerMove, this);
        core.on(`${chart.id}_pointerDown`, this.onPointerDown, this);
        core.on(`${chart.id}_pointerUp`, this.onPointerUp, this);
    }
    onPointerMove(pos) {
        if (this.#chart.stateMachine.state === "chart_pan")
            return;
    }
    onPointerDown(pos) {
        if (this.#chart.stateMachine.state === "chart_pan")
            return;
        debounce(this.isNodeSelected, HIT_DEBOUNCE, this)(pos);
    }
    onPointerUp(pos) {
    }
    onPointerDblClick(pos) {
    }
    onNodeDrag(pos) {
    }
    onVisible() {
    }
    onActive(e) {
    }
    isArrayOfNodes(a) {
        if (!isArray(a))
            return false;
        return a.every((i) => i instanceof _a$1);
    }
    isNodeConstrained() {
        const c = this.#constraint;
        if (!(c.x && c.y))
            return false;
        else
            return c;
    }
    isNodeSelected() {
    }
    draw() {
        const t = this.themeState;
        const ctx = this.#ctx;
        const ctxH = this.#ctxH;
        const hitV = this.#hit.getIndexToRGB(this.#hitV);
        const opts = { stroke: t.stroke, width: t.width, fill: t.fill };
        const optsH = { width: t.width, fill: hitV };
        ctx.save();
        renderCircle(ctx, this.#x, this.#y, t.radius, opts);
        ctx.restore();
        ctxH.save();
        renderCircle(ctxH, this.#x, this.#y, t.radius + t.width, optsH);
        ctxH.restore();
    }
}
_a$1 = ToolNode;

const toolsDialogue = {
    bounded: true,
    dragBar: false,
    closeIcon: false,
    content: "",
    styles: {
        window: {
            width: "15em",
            zindex: "10"
        },
        content: {
            overflow: "hidden",
            padding: "0 1em"
        }
    }
};
const nodeList = {
    definitions: [],
    instances: [],
    idle: [],
    active: [],
    selected: [],
    done: [],
    tracking: new xMap()
};
class ChartToolsHost extends Overlay {
    static #cnt = 0;
    static get inCnt() { return ChartToolsHost.#cnt++; }
    #id;
    #inCnt;
    #name = "Chart Tool Host";
    #shortName = "TX_ChartToolsHost";
    #type = "tool";
    #chartPane;
    #graph;
    #renderLoop;
    #pointer = {
        click: [0, 0],
        pos: [0, 0],
    };
    #activeTool = {
        instance: undefined,
        state: undefined,
        nodeList: doStructuredClone(nodeList)
    };
    #toolSelections = [];
    constructor(target, xAxis = false, yAxis = false, theme, parent, params) {
        super(target, xAxis, yAxis, theme, parent, params);
        this.#inCnt = ChartToolsHost.inCnt;
        this.settings = params?.settings || {};
        this.#chartPane = params.chart;
        this.#graph = new Graph(this, parent.parent.elViewport, [], true);
        const renderLoopConfig = {
            graphs: this.#graph,
            range: this.range,
            core: this.core
        };
        this.#renderLoop = new RenderLoop(renderLoopConfig);
        toolsDialogue.parent = this;
        this.eventsListen();
    }
    destroy() {
        this.clearToolSelections();
        const tools = Object.values(this.tools);
        tools.forEach((tool) => {
            this.remove(tool);
            tool.destroy();
        });
        this.#activeTool = null;
        super.destroy();
    }
    set id(id) { this.#id = idSanitize(id); }
    get id() { return this.#id || `${this.core.ID}-${uid(this.#shortName)}_${this.#inCnt}`; }
    get type() { return this.#type; }
    get inCnt() { return this.#inCnt; }
    get name() { return this.#name; }
    get shortName() { return this.#shortName; }
    get chartPane() { return this.#chartPane; }
    get graph() { return this.#graph; }
    get elCanvas() { return this.graph.viewport.scene.canvas; }
    get tools() { return this.overlays; }
    get renderLoop() { return this.#renderLoop; }
    get overlays() { return Object.fromEntries([...this.graph.overlays.list]); }
    get activeTool() { return this.#activeTool; }
    get pointer() { return this.#pointer; }
    emitMsg(msg, data) {
        if (!isString(msg))
            return;
        this.emit(msg, data);
        this.emit(`chart${this.#chartPane.id}_${msg}`, data);
    }
    eventsListen() {
    }
    add(tool, cfg = {}) {
        if (!isClass(tool.class) || !tool.class.isTool) {
            this.core.error(`Cannot add tool: not a valid tool.`);
            return null;
        }
        try {
            let cnt = ++ChartToolsHost.#cnt;
            tool.parent = this;
            tool.params = (isObject(tool.params)) ?
                { ...tool.params, ...cfg } :
                cfg;
            tool.params.chartPane = this.#chartPane;
            let key = cfg?.id || tool?.params.id || `Tool-${tool.class.prototype.constructor.name}-${cnt}`;
            let instance = this.#graph.addOverlay(key, tool);
            let active = this.#activeTool;
            active.instance = instance;
            active.nodeList = instance.nodeList;
            active.state = instance.stateMachine;
            this.emitMsg('toolAdded', tool);
            return instance;
        }
        catch (error) {
            this.core.error('Failed to add tool:');
            this.core.error(error);
            return null;
        }
    }
    remove(tool) {
        if (!tool || !tool?.isTool || !tool?.destroy)
            return false;
        if (tool.isEditing)
            this.toolEditDone(tool);
        if (tool.isActive)
            this.deactivateTool(tool);
        if (tool.isSelected)
            this.deselectTool(tool);
        tool.destroy();
        delete this.tools[tool.id];
        this.emitMsg('toolRemoved', tool);
        return true;
    }
    activateTool(tool) {
        if (!tool || !tool?.isTool)
            return false;
        if (tool.isActive)
            return true;
        let selections = this.#toolSelections;
        if (this.#toolSelections.length == 1) {
            this.deselectTool(selections[0]);
            selections.length = 0;
        }
        if (!!this.#activeTool.instance) {
            this.deselectTool(this.#activeTool.instance);
            this.deactivateTool(this.#activeTool.instance);
        }
        this.#activeTool = {
            instance: tool,
            state: tool.stateMachine,
            nodeList: { ...tool.nodeList }
        };
        tool.isActive = true;
        tool.isSelected = true;
        this.emitMsg('toolActivated', tool);
        return true;
    }
    deactivateTool(tool) {
        if (!tool || !tool?.isTool)
            return false;
        if (!tool.isActive)
            return true;
        tool.isActive = false;
        this.emitMsg('toolDeactivated', tool);
        return true;
    }
    selectTool(tool) {
        if (!tool || !tool?.isTool)
            return false;
        if (tool.isSelected)
            return true;
        tool.isSelected = true;
        this.emitMsg('toolSelected', tool);
        return true;
    }
    deselectTool(tool) {
        if (!tool || !tool?.isTool)
            return false;
        if (!tool.isSelected)
            return true;
        tool.isSelected = false;
        this.deactivateTool(tool);
        this.emitMsg('toolDeselected', tool);
        return true;
    }
    multiSelectTools(tool) {
        if (!tool || !tool?.isTool)
            return false;
        const selection = this.#toolSelections.find((selected) => selected === tool);
        if (!!selection)
            return true;
        this.selectTool(tool);
        this.#toolSelections.push(tool);
        return true;
    }
    clearToolSelections() {
        this.#toolSelections.forEach((tool) => {
            this.deselectTool(tool);
        });
        this.#toolSelections.length = 0;
    }
    editTool(tool) {
        if (!tool || !tool?.isTool)
            return false;
        if (tool.isEditing)
            return true;
        tool.isEditing = true;
        this.emitMsg('toolEditStarted', tool);
        return true;
    }
    toolEditDone(tool) {
        if (!tool || !tool?.isTool)
            return false;
        if (!tool.isEditing)
            return true;
        tool.isEditing = false;
        this.emitMsg('toolEditDone', tool);
        return true;
    }
    getAll() {
        return Object.values(this.tools);
    }
    getByID(ID) {
        if (!ID || typeof ID !== 'string')
            return null;
        return this.getAll().find((tool) => tool.id === ID);
    }
    getByType(type) {
        if (!type || !isString(type))
            return this.getAll();
        else
            return this.getAll().filter((tool) => tool.shortName === type);
    }
    render() {
        this.draw();
        this.graph.render();
        const scene = this.scene;
        scene.clear();
        const ctx = this.scene.context;
        ctx.save();
        ctx.scale(1, 1);
        ctx.drawImage(this.graph.viewport.scene.canvas, 0, 0, this.graph.viewport.width, this.graph.viewport.height);
        ctx.restore();
        this.target.viewport.render();
    }
    draw(range = this.range, update = false) {
        this.graph.draw(range, update);
    }
}
class ChartTool extends Overlay {
    static #cnt = 0;
    static get inCnt() { return ChartTool.#cnt++; }
    static #instances = {};
    static { this.isOverlay = true; }
    static { this.isTool = true; }
    #id;
    #inCnt;
    #name = "Chart Tool";
    #shortName = "TX_Tool";
    #stateMachine;
    #configDialogue;
    #chartPane;
    #cursorPos = [0, 0];
    #boundingBox = { TL: [0, 0], BR: [0, 0] };
    #nodeList = doStructuredClone(nodeList);
    #active = false;
    #selected = false;
    #editing = false;
    constructor(target, xAxis = false, yAxis = false, theme, parent, params) {
        super(target, xAxis, yAxis, theme, parent, params);
        this.#inCnt = ChartTool.inCnt;
        this.id = params?.id || `${this.core.ID}-${uid(this.shortName)}_${this.inCnt}`;
        this.#configDialogue = this.core.WidgetsG.insert("ConfigDialogue", toolsDialogue);
        this.#configDialogue.start();
        this.#chartPane = params.chartPane;
        this.#cursorPos = this.parent.pointer || [0, 0];
        this.instantiateNodes();
        this.eventsListen();
    }
    destroy() {
        const chart = this.chartPane;
        this.core.off(`${chart.id}_pointerMove`, this.onPointerMove, this);
        this.core.off(`${chart.id}_pointerDown`, this.onPointerDown, this);
        this.core.off(`${chart.id}_pointerUp`, this.onPointerUp, this);
        this.core.off(`${chart.id}_pointerDrag`, this.onPointerDrag, this);
        this.cleanupNodes();
        if (this.#configDialogue) {
            this.#configDialogue.destroy();
        }
        super.destroy();
    }
    set id(id) { this.#id = idSanitize(id); }
    get id() { return this.#id || `${this.core.ID}-${uid(this.shortName)}_${this.inCnt}`; }
    get inCnt() { return this.#inCnt; }
    get name() { return this.#name; }
    get shortName() { return this.#shortName; }
    get settings() { return this.params.settings; }
    set settings(s) { this.validateSettings(s); }
    set position(p) { this.target.setPosition(p[0], p[1]); }
    get data() { return this.overlay.data; }
    set stateMachine(config) { this.#stateMachine = new StateMachine(config, this); }
    get stateMachine() { return this.#stateMachine; }
    get isTool() { return true; }
    get isInRange() { return this.isToolInRange(); }
    set isActive(a) { this.setToolActive(a); }
    get isActive() { return this.#active; }
    set isSelected(s) { this.setToolSelected(s); }
    get isSelected() { return this.#selected; }
    set isEditing(e) { this.setToolEditing(e); }
    get isEditing() { return this.#editing; }
    get chartPane() { return this.#chartPane; }
    get nodeList() { return this.#nodeList; }
    instantiateNodes() {
        try {
            this.#nodeList.definitions = (isArrayOfType(this.nodeDefinitions, "object")) ? this.nodeDefinitions : [];
            if (!this.#nodeList.definitions.length)
                return;
            for (let node of this.#nodeList.definitions) {
                let instance = new ToolNode(node?.id, 0, 0, node?.constraint, node?.tracking, this.scene.layer, this.chart);
                this.#nodeList.instances.push(instance);
            }
            this.nodeTracking();
        }
        catch (error) {
            let msg = 'Failed to instantiate ChartTool nodes';
            this.core.error(msg, error);
            throw new Error(msg, { cause: error });
        }
    }
    nodeTracking() {
        const nodes = this.#nodeList;
        const definitions = this.nodeDefinitions;
        for (let instance of nodes.instances) {
            let id = instance.id;
            let tracking = [];
            for (let node of definitions) {
                if (node.id !== id)
                    continue;
                tracking.push(this.getNodeByID(id));
            }
            nodes.tracking.set(instance, tracking);
        }
    }
    cleanupNodes() {
        Object.values(this.#nodeList.instances).forEach(node => {
            node.destroy();
        });
        this.#nodeList = null;
    }
    eventsListen() {
        const chart = this.chartPane;
        this.core.on(`${chart.id}_pointerMove`, this.onPointerMove, this);
        this.core.on(`${chart.id}_pointerDown`, debounce(this.onPointerDown, HIT_DEBOUNCE * 10, this, true), this);
        this.core.on(`${chart.id}_pointerUp`, this.onPointerUp, this);
        this.core.on(`${chart.id}_pointerDrag`, this.onPointerDrag, this);
    }
    onPointerMove(pos) {
        if (this.chartPane.stateMachine.state === "chart_pan")
            return;
    }
    onPointerDown(pos) {
        if ((this.oldPos === pos[2]) ||
            (this.core.MainPane.stateMachine.state === "chart_pan") ||
            (!this.isToolInRange()) ||
            (!this.isToolPointerSelected(pos) && !this.isToolIncomplete())) {
            this.#active = false;
            return;
        }
        this.oldPos = this.#cursorPos;
        this.#cursorPos = pos;
        if (!this.isToolNodeSelected(pos) && this.isToolIncomplete()) {
            this.addToolNode();
        }
        this.setToolActive(true);
    }
    onPointerUp(pos) {
    }
    onPointerDrag(pos) {
    }
    isToolInRange(range = this.range) {
        return true;
    }
    isToolPointerSelected(e) {
        const [x, y, k] = this.getHitIntersection(e);
        return k !== -1;
    }
    isToolNodeSelected(e) {
        const n = this.#nodeList;
        const [x, y, k] = this.getHitIntersection(e);
        if (k == -1)
            return false;
        n.selected = [];
        for (let o of n.instances) {
            if (o.hitV === k) {
                n.selected.push(o);
                return o;
            }
        }
        return false;
    }
    isToolIncomplete() {
        return this.#nodeList.done.length < this.#nodeList.definitions.length;
    }
    isVisible(range = this.range) {
        return this.isToolInRange(range);
    }
    convertPointerToCanvasXY(e) {
        let evt = e[2].domEvent.srcEvent;
        let DOM = (evt.target || evt.srcElement).getBoundingClientRect();
        let x = evt.clientX - (DOM.right - DOM.width);
        let y = evt.clientY - DOM.top;
        return [x, y];
    }
    getHitIntersection(e) {
        let [x, y] = this.convertPointerToCanvasXY(e);
        let k = this.hit.getIntersection(x, y);
        return [x, y, k];
    }
    getNodeByID(id) {
        return this.#nodeList.instances.find((node) => { return node.id === id; });
    }
    setToolActive(state) {
        this.#active = !!state;
        this.setRefresh();
        this.draw();
    }
    setToolSelected(state) {
        this.#selected = !!state;
        this.setRefresh();
        this.draw();
    }
    setToolEditing(state) {
        this.#editing = !!state;
    }
    addToolNode() {
        let n = this.#nodeList;
        let done = n.done.length;
        let def = n.definitions.length;
        let pos = this.#cursorPos;
        if (done >= def)
            return false;
        let idx = limit(done, 0, def - 1);
        n.instances[idx].x = pos[0];
        n.instances[idx].y = pos[1];
        n.done.push(n.instances[idx]);
        return true;
    }
    draw(range = this.core.range) {
        if (this.core.config?.tools?.display === false ||
            !this.isVisible(range) ||
            !super.mustUpdate())
            return;
        this.hit.clear();
        this.scene.clear();
        const ctx = this.scene.context;
        this.render(ctx, this.scene);
        ctx.save();
        this.theme.tools;
        let o = this.core.rangeScrollOffset;
        range.indexStart - o;
        range.Length + (o * 2);
        this.drawNodes();
        ctx.restore();
        super.updated();
    }
    drawNodes() {
        let nodes = this.#nodeList;
        const nodesToDraw = new Set([
            ...nodes.done,
            ...nodes.selected,
            ...nodes.active
        ]);
        nodesToDraw.forEach(node => node.draw());
    }
}

let nameShort$6 = "Cursor";
let nameLong$6 = 'Cursor';
class Cursor extends ChartTool {
    static #cnt = 0;
    static get inCnt() { return Cursor.#cnt++; }
    get name() { return nameLong$6; }
    get shortName() { return nameShort$6; }
    constructor(cfg) {
        const { target, xAxis = false, yAxis = false, theme, parent, params } = cfg;
        super(target, xAxis, yAxis, theme, parent, params);
        this.settings = params.settings;
        State.importData("tradesPositions", this.data, this.state, this.state.time.timeFrame);
    }
    get inCnt() { return Cursor.#cnt; }
    draw() { }
}

let nameShort$5 = "fib";
let nameLong$5 = 'Fibonacci';
class Fibonacci extends ChartToolsHost {
    static #cnt = 0;
    static get inCnt() { return Fibonacci.#cnt++; }
    get name() { return nameLong$5; }
    get shortName() { return nameShort$5; }
    constructor(cfg) {
        const { target, xAxis = false, yAxis = false, theme, parent, params } = cfg;
        super(target, xAxis, yAxis, theme, parent, params);
        this.validateSettings(params?.settings);
    }
    draw() { }
}

const LINECONFIG = {
    colour: "#ffffff",
    width: 1.5
};
let nameShort$4 = "line";
let nameLong$4 = 'Line';
let nodeDefinitions = [
    { id: "node1", tracking: [undefined] },
    { id: "node2", tracking: ["node2"] },
];
class Line extends ChartTool {
    get name() { return nameLong$4; }
    get shortName() { return nameShort$4; }
    static #cnt = 0;
    static get inCnt() { return Line.#cnt++; }
    #colour = LINECONFIG.colour;
    #lineWidth = LINECONFIG.width;
    #stateMachine;
    constructor(target, xAxis = false, yAxis = false, theme, parent, params) {
        super(target, xAxis, yAxis, theme, parent, params);
        this.validateSettings(params?.settings);
        this.start();
    }
    get inCnt() { return Line.#cnt; }
    set colour(colour) {
        let c = new Colour(colour);
        this.#colour = (c.isValid) ? colour : this.#colour;
    }
    get colour() { return this.#colour; }
    set lineWidth(width) { this.#lineWidth = (isNumber(width)) ? width : this.#lineWidth; }
    get lineWidth() { return this.#lineWidth; }
    get nodeDefinitions() { return nodeDefinitions; }
    validateSettings(s) {
        if (!isObject(s))
            return false;
        this.colour = s?.colour;
        this.lineWidth = s?.width;
    }
    start() {
        this.eventsListen();
    }
    destroy() {
        this.stateMachine.destroy();
    }
    render(ctx, scene) {
        let n = this.nodeList;
        if (n.done.length !== 2)
            return;
        let x1 = n.done[0].x;
        let y1 = n.done[0].y;
        let x2 = n.done[1].x;
        let y2 = n.done[1].y;
        ctx.save();
        ctx.lineWidth = this.lineWidth;
        ctx.strokeStyle = this.colour;
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.stroke();
        ctx.closePath();
        ctx.restore();
    }
}

let nameShort$3 = "measure";
let nameLong$3 = 'Measure';
class Measure extends ChartTool {
    static #cnt = 0;
    static get inCnt() { return Measure.#cnt++; }
    get name() { return nameLong$3; }
    get shortName() { return nameShort$3; }
    constructor(cfg) {
        const { target, xAxis = false, yAxis = false, theme, parent, params } = cfg;
        super(target, xAxis, yAxis, theme, parent, params);
        this.validateSettings(params?.settings);
    }
    draw() { }
}

let nameShort$2 = "range";
let nameLong$2 = 'Range';
class RangeTool extends ChartTool {
    static #cnt = 0;
    static get inCnt() { return RangeTool.#cnt++; }
    get name() { return nameLong$2; }
    get shortName() { return nameShort$2; }
    constructor(cfg) {
        const { target, xAxis = false, yAxis = false, theme, parent, params } = cfg;
        super(target, xAxis, yAxis, theme, parent, params);
        this.validateSettings(params?.settings);
    }
    draw() { }
}

let nameShort$1 = "text";
let nameLong$1 = 'Text';
class Text extends ChartTool {
    static #cnt = 0;
    static get inCnt() { return Text.#cnt++; }
    get name() { return nameLong$1; }
    get shortName() { return nameShort$1; }
    constructor(cfg) {
        const { target, xAxis = false, yAxis = false, theme, parent, params } = cfg;
        super(target, xAxis, yAxis, theme, parent, params);
        this.validateSettings(params?.settings);
    }
    draw() { }
}

let nameLong = "Trade Posiition";
let nameShort = "tradepos";
class TradePosition extends ChartTool {
    static #cnt = 0;
    static get inCnt() { return TradePosition.#cnt++; }
    get name() { return nameLong; }
    get shortName() { return nameShort; }
    constructor(cfg) {
        const { target, xAxis = false, yAxis = false, theme, parent, params } = cfg;
        super(target, xAxis, yAxis, theme, parent, params);
        this.settings = params.settings;
        State.importData("tradesPositions", this.data, this.state, this.state.time.timeFrame);
    }
    get inCnt() { return TradePosition.#cnt; }
    start() {
        this.eventsListen();
    }
    destroy() {
        this.stateMachine.destroy();
    }
    doSettings(s) {
        if (!isObject(s))
            return false;
        let t = this.theme.trades;
        for (let e in s) {
            if (s[e] === undefined)
                continue;
            t[e] = s[e];
        }
    }
    onPrimaryPointerDown(e) {
        if (this.core.MainPane.stateMachine.state !== "chart_pan")
            debounce(this.isTradePositionSelected, HIT_DEBOUNCE, this)(e);
    }
    isTradePositionSelected(e) {
        const evt = e[2].domEvent.srcEvent;
        const DOM = (evt.target || evt.srcElement).getBoundingClientRect();
        const x = evt.clientX - (DOM.right - DOM.width);
        const y = evt.clientY - DOM.top;
        const k = this.hit.getIntersection(x, y);
        if (this.core.config?.tradesPositions?.display === false ||
            this.core.config?.tools?.display === false ||
            k == -1)
            return false;
        else
            return true;
    }
    canTradePositionDraw() {
        if (!super.mustUpdate() ||
            !isObject(this.data) ||
            Object.keys(this.data).length == 0 ||
            this.core.config?.tools?.display === false)
            return false;
        else
            return true;
    }
    draw(range = this.core.range) {
        if (!this.canTradePositionDraw())
            return;
        this.hit.clear();
        this.scene.clear();
        super.updated();
    }
}

var tools = [
    {
        id: "cursor",
        name: "Cursor",
        icon: cursor,
        event: "tool_activated",
        enable: false,
        diplay: true,
        active: true,
        class: Cursor
    },
    {
        id: "line",
        name: "Line",
        icon: line,
        event: "tool_activated",
        enable: false,
        diplay: true,
        class: Line,
        sub: [
            {
                id: "ray",
                name: "Ray",
                icon: line,
                event: "tool_activated",
                class: Line,
            },
            {
                id: "hRay",
                name: "Horizontal Ray",
                icon: line,
                event: "tool_activated",
                class: Line,
            },
            {
                id: "vRay",
                name: "Vertical Ray",
                icon: line,
                event: "tool_activated",
                class: Line,
            },
        ]
    },
    {
        id: "fibonacci",
        name: "Fibonacci",
        icon: fibonacci,
        event: "tool_activated",
        enable: false,
        diplay: true,
        class: Fibonacci,
        sub: [
            {
                id: "fib",
                name: "Not Implemented Yet",
                icon: line,
            }
        ]
    },
    {
        id: "range",
        name: "Range",
        icon: range,
        event: "tool_activated",
        enable: false,
        diplay: true,
        class: RangeTool,
        sub: [
            {
                id: "rng",
                name: "Not Implemented Yet",
                icon: line,
            }
        ]
    },
    {
        id: "trade",
        name: "Trade Position",
        icon: tradePosition,
        event: "tool_activated",
        enable: true,
        diplay: true,
        class: TradePosition,
    },
    {
        id: "text",
        name: "Text",
        icon: text,
        event: "tool_activated",
        enable: false,
        diplay: true,
        class: Text,
        sub: [
            {
                id: "txt",
                name: "Not Implemented Yet",
                icon: line,
            }
        ]
    },
    {
        id: "measure",
        name: "Measure",
        icon: measure,
        event: "tool_activated",
        enable: false,
        diplay: true,
        class: Measure,
    },
    {
        id: "delete",
        name: "Delete",
        icon: del,
        event: "tool_activated",
        enable: false,
        diplay: true,
        class: undefined,
    }
];

class Toolbox {
    static #list = [];
    static #listByGroup = [];
    static register(tools$1 = tools, merge = true) {
        let keys = ["id", "name", "icon", "event", "class"];
        let sub = [];
        let validateTool = (t) => {
            let k = Object.keys(t);
            return valuesInArray(keys, k) && Toolbox.isTool(t.class);
        };
        let processTools = (entries, arr) => {
            for (let tool of entries) {
                if (isArrayOfType(tool?.sub, "object")) {
                    sub = processTools(tool.sub, []);
                    if (sub.length > 0)
                        tool.sub = sub;
                }
                if (validateTool(tool)) {
                    arr.push(tool);
                    Toolbox.#list.push(tool);
                }
            }
            return arr;
        };
        let result = [];
        if (isArray(tools$1) && tools$1.length == 0)
            result = [];
        else if (isArrayOfType(tools$1, "object") && tools$1.length > 0) {
            result = processTools(tools$1, []);
        }
        else
            result = processTools(tools, []);
        this.#listByGroup = result;
    }
    static isTool(tool) {
        return (isClass(tool) &&
            isFunction(tool.prototype?.draw) &&
            prototypeHas("isTool", tool));
    }
    static isToolInstance(tool) {
        return Toolbox.instances.find((instance) => instance === tool);
    }
    static get list() {
        return Toolbox.#list;
    }
    static get listByGroup() {
        return Toolbox.#listByGroup;
    }
    constructor(core) {
        this.core = core;
    }
    get static() { return Toolbox; }
    get chartToolHosts() {
        return Object.fromEntries(this.core.ChartPanes);
    }
    get instances() {
        let instances = [];
        for (let host of this.core.ChartPanes.values()) {
            instances = [...instances, ...host.tools.getAll()];
        }
        return instances;
    }
    get instancesByType() {
        let byType = {};
        for (let instance of this.instances) {
            let type = instance.shortName;
            if (!byType[type])
                byType[type] = [];
            byType[type].push(instance);
        }
        return byType;
    }
    get instancesByChartPane() {
        let instances = {};
        let hosts = this.chartToolHosts;
        for (let host in hosts) {
            instances[host] = hosts[host].tools.instances;
        }
        return instances;
    }
    getInstance(tool) {
        let instance;
        let instances = this.instances;
        if (isString(tool)) {
            instance = instances.find((ins) => { ins.id === tool; });
        }
        else if (this.static.isToolInstance(tool))
            instance = tool;
        else {
            return false;
        }
        return instance;
    }
    getByType(type) {
        return this.instancesByType[type];
    }
    add(tool, paneID, params = {}) {
        let pane = this.core.ChartPanes.get(paneID);
        if (!pane)
            throw new Error(`Class Toolbox add() requires a valid pane id`);
        if (!isObject(params))
            params = {};
        const toolParams = { ...params, chartPane: pane };
        return pane.tools.add(tool, toolParams);
    }
    remove(tool) {
        const instance = this.getInstance(tool);
        if (!instance) {
            this.core.error(`Class Toolbox remove() cannot remove an invalid tool`);
            return;
        }
        return tool.chartPane.tools.remove(instance);
    }
    activate(tool) {
        const instance = this.getInstance(tool);
        if (!instance) {
            this.core.error(`Class Toolbox activate() cannot activate an invalid tool`);
            return;
        }
        return tool.chartPane.tools.activateTool(instance);
    }
    deactivate(tool) {
        const instance = this.getInstance(tool);
        if (!instance) {
            this.core.error(`Class Toolbox deactivate() cannot deactivate an invalid tool`);
            return;
        }
        return tool.chartPane.tools.deactivateTool(instance);
    }
}
class Tools {
    #chart;
    #stateMachine;
    get Toolbox() { return Toolbox; }
    constructor(chart) {
        if (!(chart instanceof Chart))
            throw new Error("Class Tools requires a valid Chart instance.");
        this.#chart = chart;
    }
    get core() { return this.#chart.core; }
    get chart() { return this.#chart; }
    get stateMachine() { return this.#stateMachine; }
    get mainStateMachine() { return this.core.MainPane.stateMachine; }
    get toolHostOverlay() { return this.#chart.graph.overlays.list.get("tools").instance; }
    get viewport() { return this.toolHostOverlay.layer.viewport; }
    get instances() { return this.toolHostOverlay.tools; }
    onToolBegin() {
    }
    onToolEnd() {
    }
    hasType(type) {
        return this.core.Tools.static.list.find((tool) => tool.id === type);
    }
    add(tool, params = {}) {
        const toolType = this.hasType(tool);
        if (!toolType) {
            this.core.warn(`Class Tools requires a valid tool type. Type ${tool} not found.`);
            return null;
        }
        if (!isObject(params))
            params = {};
        try {
            return this.toolHostOverlay.add(toolType, params);
        }
        catch (error) {
            this.core.error(`Failed to add tool ${toolType} because ${error.message}`);
            return null;
        }
    }
    remove(tool) {
        return this.toolHostOverlay.remove(tool);
    }
    activate(tool) {
        const active = this.getTool(tool);
        if (!active) {
            this.core.warn(`Cannot activate invalid tool`);
            return null;
        }
        this.toolHostOverlay.activateTool(active);
        return active;
    }
    deactivate(tool) {
        const active = this.getTool(tool);
        if (!active) {
            this.core.warn(`Cannot deactivate invalid tool`);
            return null;
        }
        this.toolHostOverlay.deactivateTool(active);
        return active;
    }
    edit(tool) {
    }
    getTool(tool) {
        if (isString(tool))
            return this.getByID(tool);
        else if (!!this.Toolbox.isToolInstance(tool))
            return tool;
        else
            return null;
    }
    getAll() {
        return this.toolHostOverlay.getAll();
    }
    getByID(ID) {
        return this.toolHostOverlay.getByID(ID);
    }
    getByType(type) {
        return this.toolHostOverlay.getByType(type);
    }
}

var stateMachineConfig$3 = {
    id: "scale",
    initial: "idle",
    context: {},
    states: {
        idle: {
            onEnter(data) {
                this.context.origin.cursor = "ns-resize";
            },
            onExit(data) {
            },
            on: {
                resize: {
                    target: 'resize',
                    action(data) {
                    },
                },
                setRange: {
                    target: 'setRange',
                    action(data) {
                    },
                },
            }
        },
        resize: {
            onEnter(data) {
            },
            onExit(data) {
            },
            on: {}
        },
        setRange: {
            onEnter(data) {
            },
            onExit(data) {
            },
            on: {
                always: {
                    target: 'idle',
                    condition: 'zoomDone',
                    action(data) {
                        this.context.origin.draw();
                    },
                },
            }
        },
    },
    guards: {
        receiver() { return (this.eventData.scale.id == this.context.origin.id); },
        zoomDone() { return true; },
    }
};

class ScaleLabels extends Overlay {
    constructor(target, xAxis, yAxis, theme, parent, params) {
        parent = yAxis;
        yAxis = yAxis.yAxis;
        super(target, xAxis, yAxis, theme, parent, params);
        this.viewport = target.viewport;
    }
    set position(p) { this.target.setPosition(p[0], p[1]); }
    get always() { return true; }
    draw() {
        if (!super.mustUpdate())
            return;
        const ctx = this.scene.context;
        const yAxis = this.yAxis;
        const grads = yAxis.yAxisGrads || [];
        const theme = this.theme.yAxis;
        const tickMarker = (isBoolean(theme.tickMarker)) ? theme.tickMarker : true;
        let tickPos = [];
        let y;
        switch (theme?.location) {
            case "left":
                tickPos = [this.width, this.width - yAxis.yAxisTicks];
                break;
            case "right":
            default:
                tickPos = [1, yAxis.yAxisTicks];
                break;
        }
        this.scene.clear();
        ctx.save();
        ctx.strokeStyle = theme.colourTick;
        ctx.fillStyle = theme.colourTick;
        ctx.font = `${theme.fontWeight} ${theme.fontSize}px ${theme.fontFamily}`;
        for (let tick of grads) {
            y = yAxis.yPos(tick[0]);
            ctx.fillText(tick[0], yAxis.yAxisTicks + 5, y + (theme.fontSize * 0.3));
            if (tickMarker) {
                ctx.beginPath();
                ctx.moveTo(tickPos[0], y);
                ctx.lineTo(tickPos[1], y);
                ctx.stroke();
            }
        }
        ctx.restore();
        super.updated();
    }
}

class ScaleOverly extends Overlay {
    constructor(target, xAxis, yAxis, theme, parent, params) {
        parent = yAxis;
        yAxis = yAxis.yAxis;
        super(target, xAxis, yAxis, theme, parent, params);
        this.viewport = target.viewport;
    }
    set position(p) { this.target.setPosition(p[0], p[1]); }
    draw() {
        const ctx = this.scene.context;
        this.yAxis.yAxis;
        this.scene.clear();
        ctx.save();
        ctx.restore();
    }
}

const priceLineTxtScaling = 1.05;
class ScalePriceLine extends Overlay {
    #opts;
    #txtH;
    constructor(target, xAxis, yAxis, theme, parent, params) {
        parent = yAxis;
        yAxis = yAxis.yAxis;
        super(target, xAxis, yAxis, theme, parent, params);
        this.viewport = target.viewport;
        this.#opts = {
            fontSize: YAxisStyle.FONTSIZE * priceLineTxtScaling,
            fontWeight: YAxisStyle.FONTWEIGHT,
            fontFamily: YAxisStyle.FONTFAMILY,
            txtCol: "#FFFFFF",
            bakCol: YAxisStyle.COLOUR_CURSOR_BG,
            paddingTop: 2,
            paddingBottom: 2,
            paddingLeft: 5,
            paddingRight: 3,
            width: this.viewport.width
        };
        this.#txtH = getTextRectHeight(this.#opts);
    }
    set position(p) { this.target.setPosition(p[0], p[1]); }
    draw(candle) {
        if (candle === undefined ||
            !this.parent.parent.isPrimary)
            return;
        const ctx = this.scene.context;
        let price = candle[4], nice = this.parent.nicePrice(price), options = { ...this.#opts }, x = 0, h = this.#txtH, y = this.parent.yPos(price) - (h * 0.5);
        this.scene.clear();
        ctx.save();
        if (candle[4] >= candle[1])
            options.bakCol = this.theme.candle.UpBodyColour;
        else
            options.bakCol = this.theme.candle.DnBodyColour;
        renderTextBG(ctx, nice, x, y, options);
        if (this.core.isStreaming) {
            nice = this.core.stream.countDownUpdate();
            options.fontSize = options?.fontSize / 1.1;
            renderTextBG(ctx, nice, x, y + h, options);
        }
        ctx.restore();
        this.viewport.render();
    }
}

const defaultOverlays$2 = [
    ["labels", { class: ScaleLabels, fixed: true, required: true }],
    ["overlay", { class: ScaleOverly, fixed: true, required: true }],
    ["price", { class: ScalePriceLine, fixed: true, required: true }],
    ["cursor", { class: ScaleCursor, fixed: true, required: true }],
];
class ScaleBar extends Component {
    #name = "Y Scale Axis";
    #shortName = "scale";
    #chart;
    #target;
    #yAxis;
    #element;
    #elViewport;
    #layerLabels;
    #layerOverlays;
    #layerPriceLine;
    #layerCursor;
    #scaleOverlays = new xMap();
    #additionalOverlays = [];
    #digitCnt;
    #digitW = 12;
    #input;
    #priceLine;
    #cursorPos;
    #position = {};
    constructor(core, options) {
        super(core, options);
        this.#element = this.options.elScale;
        this.#chart = this.options.chart;
        this.id = `${this.parent.id}_scale`;
        this.#elViewport = this.#element.viewport || this.#element;
    }
    destroy(all = true) {
        this.core.hub.expunge(this);
        this.off(`${this.parent.id}_pointerOut`, this.#layerCursor.erase, this.#layerCursor);
        this.off(STREAM_UPDATE, this.onStreamUpdate, this.#layerPriceLine);
        this.graph.destroy();
        this.#input.destroy();
        if (!!all) {
            this.stateMachine.destroy();
            this.element.remove();
        }
        this.#layerCursor = null;
        this.#layerLabels = null;
        this.#layerOverlays = null;
        this.#layerPriceLine = null;
    }
    get name() { return this.#name; }
    get shortName() { return this.#shortName; }
    get height() { return this.#element.getBoundingClientRect().height; }
    get width() { return this.#element.getBoundingClientRect().width; }
    get element() { return this.#element; }
    set cursor(c) { this.#element.style.cursor = c; }
    get cursor() { return this.#element.style.cursor; }
    get layerCursor() { return this.#layerCursor; }
    get layerLabels() { return this.#layerLabels; }
    get layerOverlays() { return this.#layerOverlays; }
    get layerPriceLine() { return this.#layerPriceLine; }
    get overlays() { return Object.fromEntries([...this.graph.overlays.list]); }
    get yAxis() { return this.#yAxis; }
    set yAxisType(t) { this.#yAxis.yAxisType = YAXIS_TYPE.valid(t); }
    get yAxisType() { return this.#yAxis.yAxisType; }
    get yAxisHeight() { return this.#yAxis.height; }
    get yAxisRatio() { return this.#yAxis.yAxisRatio; }
    get yAxisGrads() { return this.#yAxis.yAxisGrads; }
    get pos() { return this.dimensions; }
    get dimensions() { return elementDimPos(this.#element); }
    get digitCnt() { return this.#digitCnt; }
    set scaleRange(r) { this.setScaleRange(r); }
    get range() { return this.#yAxis.range; }
    set rangeMode(m) { this.#yAxis.mode = m; }
    get rangeMode() { return this.#yAxis.mode; }
    set rangeYFactor(f) { this.core.range.yFactor(f); }
    set yOffset(o) { this.#yAxis.offset = o; }
    get yOffset() { return this.#yAxis.offset; }
    get scale() { return this; }
    get Scale() { return this; }
    start() {
        const ctx = this.core.MainPane.graph.viewport.scene.context;
        const t = this.theme.yAxis;
        this.setYAxis();
        ctx.font = createFont(t.fontSize, t.fontWeight, t.fontFamily);
        this.#digitW = calcTextWidth(ctx, "0");
        let w = this.calcScaleWidth();
        this.setDimensions({ w });
        this.createGraph();
        this.#yAxis.calcGradations();
        this.draw();
        this.eventsListen();
        const newConfig = doStructuredClone(stateMachineConfig$3);
        newConfig.id = this.id;
        newConfig.context = this;
        this.stateMachine = newConfig;
        this.stateMachine.start();
    }
    eventsListen() {
        let canvas = this.graph.viewport.scene.canvas;
        this.#input = new Input(canvas, { disableContextMenu: false });
        this.#input.setCursor("ns-resize");
        this.#input.on("pointerdrag", this.onDrag.bind(this));
        this.#input.on("pointerdragend", this.onDragDone.bind(this));
        this.#input.on("wheel", this.onMouseWheel.bind(this));
        this.#input.on("dblclick", this.resetScaleRange.bind(this));
        this.on(`${this.parent.id}_pointerMove`, this.onMouseMove, this);
        this.on(`${this.parent.id}_pointerOut`, this.#layerCursor.erase, this.#layerCursor);
        this.on(STREAM_UPDATE, this.onStreamUpdate, this);
        this.on(`range_set`, this.draw, this);
    }
    onResize(dimensions) {
        this.setDimensions(dimensions);
    }
    onMouseMove(e) {
        this.#cursorPos = (isArray(e)) ? e : [Math.floor(e.position.x), Math.floor(e.position.y)];
        this.#layerCursor.draw(this.#cursorPos);
    }
    onDrag(e) {
        this.#cursorPos = [
            Math.floor(e.position.x), Math.floor(e.position.y),
            e.dragstart.x, e.dragstart.y,
            e.movement.x, e.movement.y
        ];
        this.setScaleRange(Math.sign(e.movement.y));
    }
    onDragDone(e) {
    }
    onMouseWheel(e) {
        e.domEvent.preventDefault();
        this.setScaleRange(Math.sign(e.wheeldelta) * -2);
    }
    onStreamUpdate(e) {
        let draw = false;
        if (this.#yAxis.mode == "manual") {
            if (this.parent.isPrimary) {
                if (e[4] > this.range.max) {
                    this.range.max = e[4];
                    draw = true;
                }
                if (e[4] < this.range.min) {
                    this.range.max = e[4];
                    draw = true;
                }
            }
            else {
                let chart = this.parent;
                let range = this.core.range;
                let id = chart.view[0].id;
                let mm = this.core.range.secondaryMaxMin?.[id]?.data;
                if (!!mm) {
                    let stream = range.value(undefined, id);
                    stream.forEach((value, index, array) => {
                        if (index == 0)
                            return;
                        if (value > mm.max)
                            mm.max = value;
                        else if (value < mm.min)
                            mm.min = value;
                    });
                    draw = true;
                }
            }
        }
        if (draw)
            this.draw();
        else {
            this.#layerPriceLine.draw(e);
        }
    }
    onChartDrag(e) {
        if (this.#yAxis.mode !== "manual")
            return;
        this.#yAxis.offset = e.domEvent.srcEvent.movementY;
        this.draw();
    }
    #setHeight(h) {
        this.#element.style.height = `${h}px`;
    }
    #setWidth(w) {
        this.#element.style.width = `${w}px`;
    }
    setDimensions(dim = {}) {
        dim = (isObject(dim)) ? dim : {};
        const w = dim?.w || this.width || YAXIS_MINDIGITS * YAxisStyle.FONTSIZE * priceLineTxtScaling;
        const h = dim?.h || this.parent.height;
        this.#setWidth(w);
        this.#setHeight(h);
        if (this.graph instanceof Graph) {
            this.graph.setSize(w, h, w);
            this.draw();
        }
        if (this.#layerCursor instanceof ScaleCursor)
            this.calcPriceDigits();
    }
    setYAxis() {
        const range = (this.options.yAxisType === YAXIS_TYPE.default) ?
            undefined : this.parent.localRange;
        this.#yAxis = new yAxis(this, this, this.options.yAxisType, range);
        this.#yAxis.yAxisPadding =
            (isNumber(this.options?.yAxisPadding) &&
                this.options.yAxisPadding >= 1) ?
                this.options.yAxisPadding : 1;
    }
    setScaleRange(r = 0) {
        if (this.#yAxis.mode == "automatic")
            this.#yAxis.mode = "manual";
        this.#yAxis.zoom = r;
        this.draw(this.range, true);
        this.core.MainPane.draw();
    }
    resetScaleRange() {
        this.#yAxis.mode = "automatic";
        this.draw(this.range, true);
        this.core.MainPane.draw();
    }
    yPos(yData) { return this.#yAxis.yPos(yData); }
    yPosStream(yData) { return this.#yAxis.lastYData2Pixel(yData); }
    yPos2Price(y) { return this.#yAxis.yPos2Price(y); }
    nicePrice($, p) {
        return limitPrecision($, p);
    }
    createGraph() {
        let overlays = doStructuredClone(defaultOverlays$2);
        this.graph = new Graph(this, this.#elViewport, overlays, false);
        this.#layerCursor = this.graph.overlays.get("cursor").instance;
        this.#layerLabels = this.graph.overlays.get("labels").instance;
        this.#layerOverlays = this.graph.overlays.get("overlay").instance;
        this.#layerPriceLine = this.graph.overlays.get("price")?.instance;
        this.graph.addOverlays(this.#additionalOverlays);
        this.#layerPriceLine.target.moveTop();
        this.#layerCursor.target.moveTop();
        this.calcPriceDigits();
    }
    calcPriceDigits() {
        let count = YAXIS_MINDIGITS, nice = "0";
        if (this.core.range.dataLength > 0 &&
            this.#yAxis instanceof yAxis) {
            if (this.#chart.isPrimary) {
                nice = this.niceValue(this.range.valueMax);
            }
            else {
                for (let i in this.#chart.indicators) {
                    let max = this.range.secondaryMaxMin?.[i]?.data?.max || YAXIS_MINDIGITS;
                    let maxStr = this.niceValue(max);
                    if (maxStr.length > nice.length)
                        nice = maxStr;
                }
            }
            count = `${nice}`.length + 2 || YAXIS_MINDIGITS;
        }
        this.#digitCnt = (count < YAXIS_MINDIGITS) ? YAXIS_MINDIGITS : count;
        return this.#digitCnt;
    }
    niceValue(v) {
        const step = this.#yAxis.niceNumber(v);
        let nice = limitPrecision(step, this.core.pricePrecision);
        return nice.match(/^0*(\d+(?:\.(?:(?!0+$)\d)+)?)/)[1];
    }
    calcScaleWidth() {
        const max = this.calcPriceDigits();
        return (max + 2) * this.#digitW * priceLineTxtScaling;
    }
    addOverlays(overlays) {
        if (!isArray(overlays))
            return false;
        if (this.graph === undefined)
            this.#additionalOverlays.push(...overlays);
        else
            this.graph.addOverlays(overlays);
    }
    addOverlay(key, overlay) {
        if (!isString(key) ||
            !isObject(overlay ||
                !isClass(overlay)))
            return null;
        if (this.graph === undefined)
            this.#additionalOverlays.push([key, overlay]);
        else {
            try {
                let o = this.graph.addOverlay(key, overlay);
                this.#layerPriceLine.target.moveTop();
                this.#layerCursor.target.moveTop();
                return o;
            }
            catch (error) {
                this.error(`Scale: Error attempting to add overlay ${key}`);
                this.error(error);
                return null;
            }
        }
    }
    render() {
        this.graph.render();
    }
    draw(range = this.range, update = true) {
        this.#yAxis.calcGradations();
        this.graph.draw(range, update);
        this.parent.drawGrid(update);
        this.parent.draw(range, true);
    }
    resize(width = this.width, height = this.height) {
        this.setDimensions({ w: width, h: height });
    }
}

class chartWatermark extends Overlay {
    constructor(target, xAxis = false, yAxis = false, theme, parent, params) {
        super(target, xAxis, yAxis, theme, parent, params);
        this.watermark = {};
        this.params.content = params?.content || "";
    }
    set position(p) { this.target.setPosition(0, 0); }
    draw() {
        const watermark = this.config?.watermark;
        super.mustUpdate();
        if (watermark?.display === false)
            return;
        if (watermark?.imgURL) {
            this.watermark.imgURL = watermark.imgURL;
            isImage(watermark?.imgURL, this.renderImage.bind(this));
        }
        else if (isString(watermark?.text)) {
            this.watermark.text = watermark.text;
            this.scene.clear();
            const ctx = this.scene.context;
            ctx.save();
            this.renderText(watermark.text);
            ctx.restore();
        }
        else
            return;
        super.updated();
    }
    renderText(txt) {
        const ratio = Math.floor(this.core.height / CHART_MINH);
        const size = this.core.config?.watermark?.fontSize;
        const weight = this.core.config?.watermark?.fontWeight;
        const family = this.core.config?.watermark?.fontFamily;
        const colour = this.core.config?.watermark?.textColour;
        const options = {
            fontSize: (size || this.theme.watermark.FONTSIZE) * ratio,
            fontWeight: weight || this.theme.watermark.FONTWEIGHT,
            fontFamily: family || this.theme.watermark.FONTFAMILY,
            txtCol: colour || this.theme.watermark.COLOUR,
        };
        const ctx = this.scene.context;
        ctx.font = createFont(options?.fontSize, options?.fontWeight, options?.fontFamily);
        ctx.textBaseline = 'top';
        ctx.fillStyle = options.txtCol;
        const height = getTextRectHeight(options);
        const width = getTextRectWidth(ctx, txt, options);
        const x = (this.scene.width - width) / 2;
        const y = (this.core.Chart.height - height) / 2;
        ctx.fillText(txt, x, y);
    }
    renderImage(i) {
        if (!i)
            return;
        const height = this.core.config?.watermark?.imgHeight || this.theme.watermark.IMGHEIGHT;
        const width = this.core.config?.watermark?.imgWidth || this.theme.watermark.IMGWIDTH;
        const x = (this.scene.width - width) / 2;
        const y = (this.scene.height - height) / 2;
        this.scene.clear();
        const ctx = this.scene.context;
        ctx.save();
        renderImage(ctx, i, x, y, height, width);
        ctx.restore();
    }
}

class chartVolume extends Overlay {
    #volumeBar;
    #volH;
    constructor(target, xAxis = false, yAxis = false, theme, parent, params) {
        super(target, xAxis, yAxis, theme, parent, params);
        this.#volumeBar = new VolumeBar(target.scene, theme);
        this.theme.volume.Height = limit(theme?.volume?.Height, 0, 100) || 100;
    }
    set position(p) { this.target.setPosition(p[0], p[1]); }
    draw(range = this.core.range) {
        if (!super.mustUpdate())
            return;
        this.scene.clear();
        const data = range.data;
        const zeroPos = this.scene.height;
        const offset = this.xAxis.smoothScrollOffset || 0;
        let w = Math.max(this.xAxis.candleW - 1, 1);
        w = candleW(w);
        const volume = {
            x: 0 + offset - this.xAxis.candleW,
            w: w,
            z: zeroPos
        };
        const volH = Math.floor(zeroPos * this.theme.volume.Height / 100);
        let o = this.core.rangeScrollOffset;
        let v = range.indexStart - o;
        let i = range.Length + (o * 2);
        let j = i;
        let u = v;
        let x;
        let maxVol = 0;
        while (j--) {
            x = range.value(u);
            if (x[4] !== null) {
                maxVol = (x[5] > maxVol) ? x[5] : maxVol;
            }
            u++;
        }
        while (i--) {
            x = range.value(v);
            volume.x = bRound(this.xAxis.xPos(x[0]) - (w / 2));
            if (x[4] !== null) {
                volume.h = volH - (volH * ((maxVol - x[5]) / maxVol));
                volume.raw = data[v];
                this.#volumeBar.draw(volume);
            }
            v++;
        }
        super.updated();
    }
}

class chartCandles extends Overlay {
    #candle;
    constructor(target, xAxis = false, yAxis = false, theme, parent) {
        super(target, xAxis, yAxis, theme, parent);
        this.#candle = new Candle(target.scene, theme);
    }
    set position(p) { this.target.setPosition(p[0], p[1]); }
    draw(range = this.core.range) {
        if (!super.mustUpdate())
            return;
        this.scene.clear();
        let render;
        let type = this.theme.candle.Type;
        switch (type) {
            case CandleType.AREA:
            case CandleType.LINE:
                render = (candle) => { this.#candle.area({ ...candle }); };
                break;
            default:
                render = (candle) => { this.#candle.draw(candle); };
                break;
        }
        const offset = this.xAxis.smoothScrollOffset || 0;
        const candle = {
            x: offset - this.xAxis.candleW,
            w: this.xAxis.candleW
        };
        let o = this.core.rangeScrollOffset;
        let c = range.indexStart - o;
        let i = range.Length + (o * 2);
        let x;
        while (i) {
            if (c >= 0) {
                x = range.value(c);
                candle.x = this.xAxis.xPos(x[0]);
                if (x?.[7]) {
                    this.core.stream.lastXPos = candle.x;
                    this.core.stream.lastYPos = { ...candle };
                    break;
                }
                if (x[4] !== null) {
                    candle.o = this.yAxis.yPos(x[1]);
                    candle.h = this.yAxis.yPos(x[2]);
                    candle.l = this.yAxis.yPos(x[3]);
                    candle.c = this.yAxis.yPos(x[4]);
                    candle.raw = x;
                    render(candle);
                }
            }
            c++;
            i--;
        }
        if (type === CandleType.AREA ||
            type === CandleType.LINE)
            this.#candle.areaRender();
        super.updated();
    }
}

class chartCandleStream extends Overlay {
    #candle;
    constructor(target, xAxis = false, yAxis = false, theme, parent, params) {
        super(target, xAxis, yAxis, theme, parent, params);
        this.#candle = new Candle(target.scene, theme);
        this.theme.priceLineStyle = this.theme?.priceLineStyle || PriceLineStyle;
    }
    set position(p) { this.setPosition(p[0], p[1]); }
    setPosition(x, y) {
        if (this.core.stream === undefined)
            return;
        this.target.setPosition(x, y);
        this.core.stream.lastScrollPos = this.core.scrollPos;
    }
    draw() {
        if (this.core.stream === undefined ||
            !isArray(this.chart.streamCandle))
            return;
        this.scene.clear();
        const r = this.core.range;
        const stream = this.chart.streamCandle;
        const render = (this.theme.candle.Type === CandleType.AREA ||
            this.theme.candle.Type === CandleType.LINE) ?
            (candle) => { this.areaRender(candle); } :
            (candle) => { this.#candle.draw(candle); };
        this.xAxis.smoothScrollOffset || 0;
        const pos = this.core.stream.lastXPos;
        const candle = {
            x: pos,
            w: this.xAxis.candleW
        };
        candle.o = this.yAxis.yPos(stream[1]);
        candle.h = this.yAxis.yPos(stream[2]);
        candle.l = this.yAxis.yPos(stream[3]);
        candle.c = this.yAxis.yPos(stream[4]);
        candle.raw = stream;
        if (r.inRenderRange(stream[0])) {
            render(candle);
        }
        if (stream[4] >= stream[1])
            this.theme.priceLineStyle.stroke = this.core.theme.candle.UpBodyColour;
        else
            this.theme.priceLineStyle.stroke = this.core.theme.candle.DnBodyColour;
        renderLineHorizontal(this.scene.context, candle.c, 0, this.target.width, this.theme.priceLineStyle);
    }
    areaRender(candle) {
        const r = this.core.range;
        const raw = r.value(r.data.length - 2);
        if (raw === null)
            return;
        const prev = {
            x: this.xAxis.xPos(raw[0]),
            o: this.yAxis.yPos(raw[1]),
            h: this.yAxis.yPos(raw[2]),
            l: this.yAxis.yPos(raw[3]),
            c: this.yAxis.yPos(raw[4]),
        };
        const ctx = this.scene.context;
        const cfg = this.theme;
        const bodyColour = cfg.candle.UpBodyColour || cfg.candle.DnBodyColour;
        Math.max(candle.w - 1, 1);
        candle.x;
        let fill;
        ctx.save();
        ctx.fillStyle = bodyColour;
        ctx.strokeStyle = bodyColour;
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(candle.x, candle.c);
        ctx.lineTo(prev.x, prev.h);
        if (cfg.candle.Type === CandleType.AREA) {
            fill = ctx.createLinearGradient(0, 0, 0, this.scene.height);
            if (isArray(cfg.candle.AreaFillColour)) {
                for (let [index, value] of cfg.candle.AreaFillColour.entries()) {
                    fill.addColorStop(index, value);
                }
            }
            else if (isString(cfg.candle.AreaFillColour))
                fill = cfg.candle.AreaFillColour;
            else
                fill = cfg.candle.UpBodyColour || cfg.candle.DnBodyColour;
            ctx.stroke();
            ctx.lineTo(prev.x, this.scene.height);
            ctx.lineTo(candle.x, this.scene.height);
            ctx.fillStyle = fill;
            ctx.closePath();
            ctx.fill();
        }
        else
            ctx.stroke();
        ctx.restore();
    }
}

const defaults = {
    colour: "#4444cc88",
    wdith: 1,
    dash: [1, 0]
};
class ChartHighLow extends Overlay {
    constructor(target, xAxis = false, yAxis = false, theme, parent, params) {
        super(target, xAxis, yAxis, theme, parent, params);
        const hiLo = { class: ScaleHighLow, fixed: true, required: false };
        if (this.core.config?.highLow === true) {
            try {
                this.scaleOverly = this.chart.scale.addOverlay("hiLo", hiLo);
            }
            catch (error) {
                this.core.error(`Chart overlay ChartHighLow cannot add Scale overly ScaleHighLow`);
                this.core.error(error);
            }
        }
    }
    set position(p) { this.target.setPosition(0, 0); }
    draw(range = this.core.range) {
        if (this.core.config?.highLow !== true ||
            !super.mustUpdate())
            return;
        this.scene.clear();
        let txt, x, y;
        let r = this.scene.width;
        let w = 35;
        let opts = {};
        let inRange = this.core.stream.inRange;
        const hi = (!inRange) ? range.valueHi : Math.max(range.valueHi, range.valueLiveMax);
        const lo = (!inRange) ? range.valueLo : Math.min(range.valueLo, range.valueLiveMin);
        range.valueLive;
        const theme = { ...this.theme.yAxis };
        const ctx = this.scene.context;
        theme.colourCursorBG = this.theme?.hilo?.colour || defaults.colour;
        ctx.save();
        ctx.strokeStyle = this.theme?.highLow?.colour || defaults.colour;
        ctx.strokeWidth = this.theme?.highLow?.width || defaults.width;
        ctx.setLineDash(this.theme?.highLow?.dash || defaults.dash);
        y = this.yAxis.yPos(hi);
        renderLineHorizontal(ctx, y, 0, r, opts);
        txt = "High";
        x = (this.theme.yAxis.location == "left") ? 0 : r - (w + 25);
        drawText(ctx, txt, x, y, w, theme);
        y = this.yAxis.yPos(lo);
        renderLineHorizontal(ctx, y, 0, r, opts);
        txt = "Low";
        drawText(ctx, txt, x, y, w, theme);
        ctx.restore();
        super.updated();
        if ("hiLo" in this.chart.scale.overlays) {
            this.chart.scale.overlays.hiLo.instance.setRefresh();
            this.chart.scale.overlays.hiLo.instance.scaleDraw();
        }
    }
}
class ScaleHighLow extends Overlay {
    constructor(target, xAxis = false, yAxis = false, theme, parent, params) {
        super(target, xAxis, yAxis, theme, parent, params);
        this.viewport = target.viewport;
        this.on(STREAM_UPDATE, this.onStreamUpdate, this);
    }
    set position(p) { this.target.setPosition(0, 0); }
    onStreamUpdate() {
        if ("hiLo" in this.chart.scale.overlays) {
            this.setRefresh();
            this.scaleDraw();
        }
    }
    draw() { }
    scaleDraw(range = this.core.range) {
        if (!super.mustUpdate())
            return;
        this.scene.clear();
        let txt, x, yHi, yLo, w;
        let options;
        let inRange = this.core.stream.inRange;
        const hi = (!inRange) ? range.valueHi : Math.max(range.valueHi, range.valueLiveMax);
        const lo = (!inRange) ? range.valueLo : Math.min(range.valueLo, range.valueLiveMin);
        const theme = { ...this.theme.yAxis };
        const ctx = this.scene.context;
        theme.colourCursorBG = this.theme?.hilo?.colour || defaults.colour;
        txt = this.chart.Scale.nicePrice(hi);
        x = 1;
        yHi = this.yAxis.yPos(hi) + 1;
        w = this.viewport.width;
        options = drawText(ctx, txt, x, yHi, w, theme);
        txt = this.chart.Scale.nicePrice(lo);
        yLo = this.yAxis.yPos(lo) + 1;
        drawText(ctx, txt, x, yLo, w, theme);
        let livePrice = this.core.stream.lastTick[4];
        if (this.core.isStreaming && !!livePrice) {
            let diff = hi - lo;
            let hiPercent = (hi - livePrice) / diff * 100;
            let loPercent = (livePrice - lo) / diff * 100;
            let hiP100Txt = this.chart.Scale.nicePrice(hiPercent);
            let loP100Txt = this.chart.Scale.nicePrice(loPercent);
            let offset = options.fontSize + options.paddingTop + options.paddingBottom;
            drawText(ctx, `+${hiP100Txt}%`, x, yHi + offset, w, theme);
            drawText(ctx, `-${loP100Txt}%`, x, yLo + offset, w, theme);
        }
        super.updated();
    }
}
function drawText(ctx, txt, x, y, w, theme) {
    let options = {
        fontSize: theme.fontSize * 1.05,
        fontWeight: theme.fontWeight,
        fontFamily: theme.fontFamily,
        txtCol: theme.colourCursor,
        bakCol: theme.colourCursorBG,
        paddingTop: 2,
        paddingBottom: 2,
        paddingLeft: 3,
        paddingRight: 3,
        width: w
    }, height = options.fontSize + options.paddingTop + options.paddingBottom, yPos = y - (height * 0.5);
    ctx.save();
    ctx.fillStyle = options.bakCol;
    ctx.fillRect(x, yPos, w, height);
    renderTextBG(ctx, `${txt}`, x, yPos, options);
    ctx.restore();
    return options;
}

class NewsEvent {
    constructor(target, theme) {
        this.scene = target.scene;
        this.hit = target.hit;
        this.ctx = this.scene.context;
        this.ctxH = this.hit.context;
        this.width = this.scene.width;
        this.cfg = theme.events;
        this.dims = { w: this.cfg.iconWidth, h: this.cfg.iconHeight };
        this.icon = svgToImage(this.cfg.iconEvent, this.cfg.iconColour, this.dims);
    }
    draw(data) {
        this.data = data;
        const i = this.icon;
        const c = this.cfg;
        const k = this.hit.getIndexToRGB(data.key);
        const hit = fillMask(k, i);
        const h = limit(data.w, c.iconMinDim, c.iconHeight);
        const w = limit(data.w, c.iconMinDim, c.iconWidth);
        const x = this.data.x;
        const y = this.data.y;
        const ctx = this.ctx;
        const ctxH = this.ctxH;
        ctx.save();
        ctx.drawImage(i, x, y, w, h);
        ctx.restore();
        ctxH.save();
        ctxH.drawImage(hit, x, y, w, h);
        ctxH.restore();
        return { x, y, w, h, k };
    }
}

const newsConfig = {
    bounded: true,
    dragBar: false,
    closeIcon: false,
    content: "",
    styles: {
        window: {
            width: "15em",
            zindex: "10"
        },
        content: {
            overflow: "hidden",
            padding: "0 1em"
        }
    }
};
class chartNewsEvents extends Overlay {
    #event;
    #events = [];
    #dialogue;
    constructor(target, xAxis = false, yAxis = false, theme, parent, params) {
        super(target, xAxis, yAxis, theme, parent, params);
        this.#event = new NewsEvent(target, theme);
        this.core.on("chart_primaryPointerDown", this.onPrimaryPointerDown, this);
        newsConfig.parent = this;
        this.#dialogue = this.core.WidgetsG.insert("Dialogue", newsConfig);
        this.#dialogue.start();
    }
    set position(p) { this.target.setPosition(p[0], p[1]); }
    get data() { return this.overlay.data; }
    onPrimaryPointerDown(e) {
        if (this.core.MainPane.stateMachine.state !== "chart_pan")
            debounce(this.isNewsEventSelected, HIT_DEBOUNCE, this)(e);
    }
    isNewsEventSelected(e) {
        const x = e[0];
        const y = e[1];
        const k = this.hit.getIntersection(x, y);
        if (this.core.config?.events?.display === false ||
            this.core.config?.events?.displayInfo === false ||
            k == -1) {
            this.#dialogue.close();
            return;
        }
        const d = this.theme.events;
        const w = limit(this.xAxis.candleW, d.iconMinDim, d.iconHeight);
        const ts = this.xAxis.pixel2T(x);
        const o = this.xAxis.scrollOffsetPx;
        const iPos = this.core.dimensions;
        let tr = Object.keys(this.data)[k] * 1;
        let tx = this.xAxis.xPos(ts) + o;
        let ty = (y - (w * 1.5)) - iPos.height;
        let content = ``;
        for (let t of this.data[tr]) {
            content += this.buildNewsEventHTML(t);
        }
        const config = {
            dimensions: { h: undefined, w: 150 },
            position: { x: tx + (w / 2) + 1, y: ty },
            content: content,
            offFocus: HIT_DEBOUNCE + 1
        };
        this.core.emit("event_selected", tr);
        this.#dialogue.open(config);
    }
    buildNewsEventHTML(h) {
        let t = h?.title;
        let c = `<style>
    h1, p {display: inline-block; font-size: 0.9em;
    max-width: 98%;
    </style>`;
        if (isString(h?.url))
            t = `<a href="${h?.url}" target="${h?.target}">${t}</a>`;
        c += `<h1>${t}</h1>`;
        c += `<p>${h?.content}</p>`;
        return c;
    }
    canNewsEventsDraw() {
        if (!super.mustUpdate() ||
            !isObject(this.data) ||
            Object.keys(this.data).length == 0 ||
            this.core.config?.events?.display === false)
            return false;
        else
            return true;
    }
    draw(range = this.core.range) {
        if (!this.canNewsEventsDraw())
            return;
        this.hit.clear();
        this.scene.clear();
        this.#events.length = 0;
        const offset = this.xAxis.smoothScrollOffset || 0;
        const event = {
            x: offset - this.xAxis.candleW,
            w: this.xAxis.candleW
        };
        let d = this.theme.events;
        let o = this.core.rangeScrollOffset;
        let c = range.indexStart - o;
        let i = range.Length + (o * 2);
        let x, t, k;
        while (i) {
            x = range.value(c);
            t = `${x[0]}`;
            k = Object.keys(this.data).indexOf(t);
            if (k >= 0) {
                for (let tr of this.data[t]) {
                    event.x = this.xAxis.xPos(x[0]) - (this.xAxis.candleW / 2);
                    event.y = this.scene.height - (limit(this.xAxis.candleW, d.iconMinDim, d.iconHeight) * 1.5);
                    event.key = k;
                    this.#events.push(this.#event.draw(event));
                }
            }
            c++;
            i--;
        }
        super.updated();
    }
}

class Trade {
    constructor(target, theme) {
        this.dims = { w: 0, h: 0 };
        this.scene = target.scene;
        this.hit = target.hit;
        this.ctx = this.scene.context;
        this.ctxH = this.hit.context;
        this.width = this.scene.width;
        this.cfg = theme.trades;
        this.dims = { w: this.cfg.iconWidth, h: this.cfg.iconHeight };
        this.buy = svgToImage(this.cfg.iconBuy, this.cfg.buyColour, this.dims);
        this.sell = svgToImage(this.cfg.iconSell, this.cfg.sellColour, this.dims);
    }
    draw(data) {
        this.data = data;
        let c = this.cfg;
        let i = (data.side === "buy") ? this.buy : this.sell;
        let k = this.hit.getIndexToRGB(data.key);
        let hit = fillMask(k, i);
        let h = limit(data.w, c.iconMinDim, c.iconHeight);
        let w = limit(data.w, c.iconMinDim, c.iconWidth);
        let x = this.data.x;
        let y = this.data.y;
        let ctx = this.ctx;
        let ctxH = this.ctxH;
        ctx.save();
        ctx.drawImage(i, x, y, w, h);
        ctx.restore();
        ctxH.save();
        ctxH.drawImage(hit, x, y, w, h);
        ctxH.restore();
        return { x, y, w, h, k };
    }
}

const tradeDialogue = {
    bounded: true,
    dragBar: false,
    closeIcon: false,
    content: "",
    styles: {
        window: {
            width: "15em",
            zindex: "10"
        },
        content: {
            overflow: "hidden",
            padding: "0 1em"
        }
    }
};
class chartTrades extends Overlay {
    #trade;
    #trades;
    #data;
    #dialogue;
    #currentSelected;
    #lastSelected;
    constructor(target, xAxis = false, yAxis = false, theme, parent, params) {
        super(target, xAxis, yAxis, theme, parent, params);
        this.settings = params.settings;
        State.importData("trades", this.data, this.state, this.state.time.timeFrame);
        this.#trade = new Trade(target, theme);
        this.core.on("chart_primaryPointerDown", this.onPrimaryPointerDown, this);
        tradeDialogue.parent = this;
        this.#dialogue = this.core.WidgetsG.insert("Dialogue", tradeDialogue);
        this.#dialogue.start();
    }
    destroy() {
        this.core.off("chart_primaryPointerDown", this.onPrimaryPointerDown, this);
    }
    set position(p) { this.target.setPosition(p[0], p[1]); }
    get data() { return this.overlay.data; }
    get settings() { return this.params.settings; }
    set settings(s) { this.doSettings(s); }
    doSettings(s) {
        if (!isObject(s))
            return false;
        let t = this.theme.trades;
        for (let e in s) {
            if (s[e] === undefined)
                continue;
            t[e] = s[e];
        }
    }
    onPrimaryPointerDown(e) {
        if (this.core.MainPane.stateMachine.state !== "chart_pan")
            debounce(this.isTradeSelected, HIT_DEBOUNCE, this)(e);
    }
    isTradeSelected(e) {
        const evt = e[2].domEvent.srcEvent;
        const DOM = (evt.target || evt.srcElement).getBoundingClientRect();
        const x = evt.clientX - (DOM.right - DOM.width);
        const y = evt.clientY - DOM.top;
        const k = this.hit.getIntersection(x, y);
        if (this.core.config?.trades?.display === false ||
            this.core.config?.trades?.displayInfo === false ||
            k == -1) {
            this.#dialogue.close();
            return;
        }
        const d = this.theme.trades;
        const w = limit(this.xAxis.candleW, d.iconMinDim, d.iconWidth);
        const ts = this.xAxis.pixel2T(x);
        this.core.range.valueByTS(ts);
        const o = this.xAxis.scrollOffsetPx;
        const iPos = this.core.dimensions;
        let tr = this.#trades[k].trade.entry;
        let tx = this.xAxis.xPos(ts) + o;
        let ty = (y - (w * 1.5)) - iPos.height;
        let content = this.buildTradeHTML(tr);
        const config = {
            dimensions: { h: undefined, w: 150 },
            position: { x: tx + (w / 2) + 1, y: ty },
            content: content,
            offFocus: HIT_DEBOUNCE + 1
        };
        this.#lastSelected = this.#currentSelected;
        this.#currentSelected = tr;
        this.core.emit("trade_selected", tr);
        if (this.#lastSelected === this.#currentSelected &&
            this.#dialogue.state === WinState.closed)
            this.#dialogue.open(config);
        else if (this.#lastSelected !== this.#currentSelected) {
            this.#dialogue.close();
            this.#dialogue.open(config);
        }
    }
    buildTradeHTML(h) {
        let c = `<style>
    dt, dd {display: inline-block; font-size: 0.9em;}
    dt {min-width: 40%;}
    dd {min-width: 60%; margin: 0;}
    </style>`;
        c += `<dl>`;
        for (let k in h) {
            if (k == "timestamp")
                continue;
            c += `<dt>${k}</dt><dd>${h[k]}</dd>`;
        }
        c += `</dl>`;
        return c;
    }
    canTradesDraw() {
        if (!super.mustUpdate() ||
            !isObject(this.data) ||
            Object.keys(this.data).length == 0 ||
            this.core.config?.events?.display === false)
            return false;
        else
            return true;
    }
    draw(range = this.core.range) {
        if (!this.canTradesDraw())
            return;
        this.hit.clear();
        this.scene.clear();
        this.#trades = [];
        const w = this.xAxis.candleW;
        const offset = this.xAxis.smoothScrollOffset || 0;
        const tradeObj = {
            x: offset - w,
            w: w
        };
        let d = this.theme.trades;
        let h = limit(w, d.iconMinDim, d.iconHeight);
        let o = this.core.rangeScrollOffset;
        let c = range.indexStart - o;
        let i = range.Length + (o * 2);
        let j = 0;
        let x, t, k;
        let yb, ys;
        let hit, trade;
        while (i) {
            x = range.value(c);
            t = `${x[0]}`;
            k = Object.keys(this.data).indexOf(t);
            if (k >= 0) {
                yb = this.yAxis.yPos(x[3]) + (limit(w, d.iconMinDim, d.iconHeight) * 0.5);
                ys = this.yAxis.yPos(x[2]) - (limit(w, d.iconMinDim, d.iconHeight) * 1.5);
                for (let tr of this.data[t]) {
                    trade = { ...tradeObj };
                    trade.x = this.xAxis.xPos(x[0]) - (w / 2);
                    trade.entry = tr;
                    trade.side = tr.side;
                    trade.key = j;
                    trade.y = (tr.side === "buy") ? yb : ys;
                    hit = this.#trade.draw(trade);
                    this.#trades[j] = {
                        key: j,
                        trade,
                        hit
                    };
                    j++;
                    if (tr.side === "buy")
                        yb += h;
                    else
                        ys -= h;
                }
            }
            c++;
            i--;
        }
        super.updated();
    }
}

const defaultOverlays$1 = {
    primaryPane: [
        ["watermark", { class: chartWatermark, fixed: true, required: true, params: { content: null } }],
        ["grid", { class: chartGrid, fixed: true, required: true, params: { axes: "y" } }],
        ["candles", { class: chartCandles, fixed: false, required: true }],
        ["hiLo", { class: ChartHighLow, fixed: true, required: false }],
        ["stream", { class: chartCandleStream, fixed: false, required: true }],
        ["tools", { class: ChartToolsHost, fixed: false, required: true }],
        ["cursor", { class: chartCursor, fixed: true, required: true }]
    ],
    secondaryPane: [
        ["grid", { class: chartGrid, fixed: true, required: true, params: { axes: "y" } }],
        ["tools", { class: ChartToolsHost, fixed: false, required: true }],
        ["cursor", { class: chartCursor, fixed: true, required: true }]
    ]
};
const standardOverlays = {
    primaryPane: {
        "watermark": { class: chartWatermark, fixed: true, required: true, params: { content: null } },
        "grid": { class: chartGrid, fixed: true, required: true, params: { axes: "y" } },
        "candles": { class: chartCandles, fixed: false, required: true },
        "hiLo": { class: ChartHighLow, fixed: true, required: false },
        "stream": { class: chartCandleStream, fixed: false, required: true },
        "tools": { class: ChartToolsHost, fixed: false, required: true },
        "cursor": { class: chartCursor, fixed: true, required: true }
    },
    secondaryPane: {
        "grid": { class: chartGrid, fixed: true, required: true, params: { axes: "y" } },
        "tools": { class: ChartToolsHost, fixed: false, required: true },
        "cursor": { class: chartCursor, fixed: true, required: true }
    }
};
const optionalOverlays = {
    primaryPane: {
        "trades": { class: chartTrades, fixed: false, required: false },
        "events": { class: chartNewsEvents, fixed: false, required: false },
        "volume": { class: chartVolume, fixed: false, required: true, params: { maxVolumeH: VolumeStyle.ONCHART_VOLUME_HEIGHT } },
    },
    secondaryPane: {
        "candles": { class: chartCandles, fixed: false, required: true },
    }
};
const chartLegend = {
    id: "chart",
    title: "",
    type: "chart",
    parent: undefined,
    source: () => { },
    visible: true
};
class Chart extends Component {
    static #cnt = 0;
    static get cnt() { return Chart.#cnt++; }
    #id;
    #name;
    #shortName;
    #titleStr;
    #chartCnt;
    #type;
    #status = "idle";
    #collapsed = {
        state: false,
        height: null,
        rowsHeight: null,
        rowsCnt: 1
    };
    #elTarget;
    #elScale;
    #Scale;
    #Time;
    #Legends;
    #Divider;
    #Stream;
    #Tools;
    #ConfigDialogue;
    #streamCandle;
    #view;
    #layersTools = new xMap();
    #overlayTools = new xMap();
    #cursorPos = [0, 0];
    #cursorActive = false;
    #cursorClick;
    #input;
    #yAxisType;
    #localRange = {
        valueMax: 110,
        valueMin: -10,
        valueDiff: 120
    };
    #indicatorDeleteList = {};
    constructor(core, options = {}) {
        super(core, options);
        this.#chartCnt = Chart.cnt;
        if (!isObject(options))
            throw new Error(`TradeX-Chart: ${core.ID} : Chart (pane) constructor failed: Expected options typeof object`);
        this.#name = this.options.name;
        this.#shortName = this.options.shortName;
        this.#titleStr = this.options.title;
        this.#type = (this.options.type == "primary") ? "primaryPane" : "secondaryPane";
        this.#view = this.options.view;
        this.#elScale = this.options.elements.elScale;
        this.#elTarget = this.options.elements.elTarget;
        this.#elTarget.id = this.id;
        this.legend = new Legends(this.elLegend, this);
        if (this.isPrimary) {
            chartLegend.type = "chart";
            chartLegend.title = this.title;
            chartLegend.parent = this;
            chartLegend.source = this.legendInputs.bind(this);
            this.legend.add(chartLegend);
            this.yAxisType = YAXIS_TYPE.relative;
        }
        else {
            let type = this.core.indicatorClasses[options.view[0].type].scale;
            chartLegend.type = "secondary";
            chartLegend.title = "";
            chartLegend.parent = this;
            chartLegend.source = () => { return { inputs: {}, colours: [], labels: [] }; };
            this.legend.add(chartLegend);
            this.yAxisType = YAXIS_TYPE.valid(type);
        }
        this.setScaleBar();
        this.#status = "init";
    }
    set id(id) { this.#id = idSanitize(id); }
    get id() { return this.#id || idSanitize(`${this.core.ID}-${this.#name}_${this.#chartCnt}`); }
    get name() { return this.#name; }
    get shortName() { return this.#shortName; }
    set title(t) { this.setTitle(t); }
    get title() { return `${this.#titleStr} : ${this.range.timeFrame} :`; }
    get type() { return this.#type; }
    get status() { return this.#status; }
    get collapsed() { return this.#collapsed; }
    get isPrimary() { return this.options?.view?.primary || (this.#type === "primaryPane") || false; }
    get element() { return this.#elTarget; }
    get pos() { return this.dimensions; }
    get dimensions() { return elementDimPos(this.#elTarget); }
    set width(w) { this.setWidth(w); }
    get width() { return this.#elTarget.getBoundingClientRect().width; }
    set height(h) { this.setHeight(h); }
    get height() { return this.#elTarget.getBoundingClientRect().height; }
    get localRange() { return this.#localRange; }
    get stream() { return this.#Stream; }
    get streamCandle() { return this.#streamCandle; }
    set cursor(c) { this.element.style.cursor = c; }
    get cursor() { return this.element.style.cursor; }
    get cursorPos() { return this.#cursorPos; }
    set cursorActive(a) { this.#cursorActive = a; }
    get cursorActive() { return this.#cursorActive; }
    get cursorClick() { return this.#cursorClick; }
    get candleW() { return this.core.Timeline.candleW; }
    get scrollPos() { return this.core.scrollPos; }
    get bufferPx() { return this.core.bufferPx; }
    get elCanvas() { return this.graph.viewport.scene.canvas; }
    get elScale() { return this.#elScale; }
    get elLegend() { return this.#elTarget.legend; }
    get elViewport() { return this.#elTarget.viewport; }
    set layerWidth(w) { this.graph.layerWidth = w; }
    get layerWidth() { return this.graph.layerWidth; }
    set legend(l) { this.#Legends = l; }
    get legend() { return this.#Legends; }
    set time(t) { this.#Time = t; }
    get time() { return this.#Time; }
    set scale(s) { this.#Scale = s; }
    get scale() { return this.#Scale; }
    set yAxisType(t) { this.setYAxisType(t); }
    get yAxisType() { return this.#yAxisType; }
    get axes() { return "x"; }
    get view() { return this.#view; }
    get viewport() { return this.graph.viewport; }
    get layerGrid() { return this.graph.overlays.get("grid").layer; }
    get overlays() { return Object.fromEntries([...this.graph.overlays.list]); }
    get overlayGrid() { return this.graph.overlays.get("grid").instance; }
    get overlayTools() { return this.graph.overlays.get("tools").instance; }
    get overlaysDefault() { return defaultOverlays$1[this.type]; }
    get indicators() { return this.getIndicators(); }
    get indicatorDeleteList() { return this.#indicatorDeleteList; }
    get tools() { return this.#Tools; }
    get Divider() { return this.#Divider; }
    get siblingPrev() { return this.sibling("prev"); }
    get siblingNext() { return this.sibling("next"); }
    start() {
        this.#Time = this.core.Timeline;
        this.createGraph();
        this.#Scale.start();
        this.#Tools = new Tools(this);
        this.draw(this.range);
        const stateMachineCfg = doStructuredClone(stateMachineConfig$4);
        stateMachineCfg.id = this.id;
        stateMachineConfig$4.context = this;
        this.stateMachine = stateMachineCfg;
        this.stateMachine.start();
        this.eventsListen();
        if (this.isPrimary)
            this.setTitle(this.core.state.symbol);
        let cfg = { chartPane: this };
        this.#Divider = this.core.WidgetsG.insert("Divider", cfg);
        this.#Divider.start();
        const content = `Configure chart ${this.id}`;
        let cfg2 = {
            title: "Chart Config",
            content,
            parent: this,
            openNow: false
        };
        this.#ConfigDialogue = this.core.WidgetsG.insert("ConfigDialogue", cfg2);
        this.#ConfigDialogue.start();
        this.#status = "running";
        this.log(`TradeX-Chart: ${this.core.ID} : Chart Pane : ${this.name} : instantiated and running`);
    }
    destroy() {
        if (this.#status === "destroyed")
            return;
        if (!this.core.MainPane.chartDeleteList[this.id]) {
            this.core.warn(`Cannot "destroy()": ${this.id} !!! Use "remove()" or "chartPaneRemove()" instead.`);
            return;
        }
        this.core.log(`Deleting chart pane: ${this.id}`);
        this.deactivate(true);
        this.#status = "destroyed";
    }
    remove() {
        this.emit("chart_paneDestroy", this.id);
    }
    deactivate(indicators = false) {
        this.core.hub.expunge(this);
        if (!!indicators)
            this.removeAllIndicators();
        this.stateMachine.destroy();
        this.#Divider.destroy();
        this.#Scale.destroy();
        this.graph.destroy();
        this.#input.destroy();
        this.legend.destroy();
        this.#Divider = undefined;
        this.#Legends = undefined;
        this.#Scale = undefined;
        this.graph = undefined;
        this.#input = undefined;
        this.element.remove();
    }
    snapshot() {
        return new ChartPaneSnapshot(this);
    }
    eventsListen() {
        this.#input = new Input(this.#elTarget, { disableContextMenu: false });
        this.#input.on("pointerdrag", this.onChartDrag.bind(this));
        this.#input.on("pointerdragend", this.onChartDragDone.bind(this));
        this.#input.on("pointermove", this.onPointerMove.bind(this));
        this.#input.on("pointerenter", this.onPointerEnter.bind(this));
        this.#input.on("pointerout", this.onPointerOut.bind(this));
        this.#input.on("pointerdown", this.onPointerDown.bind(this));
        this.#input.on("pointerup", this.onPointerUp.bind(this));
        this.on(STREAM_LISTENING, this.onStreamListening, this);
        this.on(STREAM_NEWVALUE, this.onStreamNewValue, this);
        this.on(STREAM_UPDATE, this.onStreamUpdate, this);
        this.on(STREAM_FIRSTVALUE, this.onStreamNewValue, this);
        this.on("range_valueMaxMin", this.onValueMaxMin, this);
        this.on("range_timeframeSet", this.onTimeframeSet, this);
        this.on(`${this.id}_removeIndicator`, this.onDeleteIndicator, this);
        if (this.isPrimary)
            this.on("chart_yAxisRedraw", this.onYAxisRedraw, this);
    }
    onChartDrag(e) {
        this.cursor = "grab";
        this.core.MainPane.onChartDrag(e);
        this.scale.onChartDrag(e);
    }
    onChartDragDone(e) {
        this.core.MainPane.onChartDragDone(e);
        this.cursor = "crosshair";
    }
    onPointerMove(e) {
        this.core.MainPane.onPointerActive(this);
        this.scale.layerCursor.visible = true;
        this.graph.overlays.list.get("cursor").layer.visible = true;
        this.#cursorPos = [Math.round(e.position.x), Math.round(e.position.y)];
        this.#Scale.onMouseMove(this.#cursorPos);
        this.emit(`${this.id}_pointerMove`, this.#cursorPos);
    }
    onPointerEnter(e) {
        this.core.MainPane.onPointerActive(this);
        this.#cursorPos = [Math.round(e.position.x), Math.round(e.position.y)];
        this.core.MainPane.onMouseEnter();
        this.scale.layerCursor.visible = true;
        this.graph.overlays.list.get("cursor").layer.visible = true;
        this.emit(`${this.id}_pointerEnter`, this.#cursorPos);
    }
    onPointerOut(e) {
        this.#cursorActive = false;
        this.#cursorPos = [Math.round(e.position.x), Math.round(e.position.y)];
        this.scale.layerCursor.visible = false;
        this.emit(`${this.id}_pointerOut`, this.#cursorPos);
    }
    onPointerDown(e) {
        this.core.pointerButtons[e.domEvent.srcEvent.button] = true;
        this.#cursorClick = [Math.floor(e.position.x), Math.floor(e.position.y), e];
        if (this.stateMachine.state === "tool_activated")
            this.emit("tool_targetSelected", { target: this, position: e });
        else if (this.isPrimary)
            this.emit("chart_primaryPointerDown", this.#cursorClick);
        else if (!this.isPrimary)
            this.emit("chart_secondaryPointerDown", this.#cursorClick);
        this.emit("chart_pointerDown", { charPane: this, pos: this.#cursorClick });
        this.emit(`${this.id}_pointerDown`, this.#cursorClick);
    }
    onPointerUp(e) {
        this.core.pointerButtons[e.domEvent.srcEvent.button] = false;
    }
    onStreamListening(stream) {
        if (this.#Stream !== stream)
            this.#Stream = stream;
    }
    onStreamNewValue(value) {
        this.draw(this.range, true);
    }
    onStreamUpdate(candle) {
        if (this.isPrimary) {
            this.#streamCandle = candle;
            this.chartStreamCandle.draw();
            this.layerStream.setPosition(this.core.stream.lastScrollPos, 0);
            this.updateLegends(this.cursorPos, candle);
        }
        else
            this.updateLegends();
        this.core.MainPane.draw();
    }
    onYAxisRedraw() {
        if (this.isPrimary)
            this.refresh();
    }
    onDeleteIndicator(i) {
        this.removeIndicator(i.id);
    }
    onTimeframeSet() {
        let title = `${this.#titleStr}`;
        chartLegend.title = title;
        this.setTitle(title);
    }
    onValueMaxMin(m) {
    }
    setScaleBar() {
        const opts = { ...this.options };
        opts.parent = this;
        opts.chart = this;
        opts.elScale = this.elScale;
        opts.yAxisType = this.yAxisType;
        this.scale = new ScaleBar(this.core, opts);
    }
    setTitle(t) {
        let txt = this.#titleStr;
        let vis;
        if (isObject(t)) {
            if (isString(t?.text))
                txt = t.text;
            vis = (!!t?.display) ? "display" : "none";
        }
        else if (isString(t)) {
            txt = t;
        }
        else
            return false;
        this.#titleStr = txt;
        chartLegend.title = this.title;
        const title = this.legend.list.chart.el.querySelectorAll(".title");
        for (let n of title) {
            n.innerHTML = this.title;
            n.style.display = vis || n.style.display;
        }
        return true;
    }
    setWatermark(w) {
        if (isString(w.text) || isString(w))
            this.core.config.watermark.text = w;
        else if ("imgURL" in w)
            this.core.config.watermark.imgURL = w.imgURL;
    }
    setHeight(h) {
        if (!isNumber(h))
            h = this.height || this.core.MainPane.rowsH;
        if (h > this.core.MainPane.rowsH)
            h = this.core.MainPane.rowsH;
        this.#elTarget.style.height = `${h}px`;
        this.#elScale.style.height = `${h}px`;
        this.elViewport.style.height = `${h}px`;
        this.#Scale.setDimensions({ w: null, h: h });
        this.Divider?.setPos();
        this.Divider?.setWidth();
    }
    setDimensions(dims = { w: this.width, h: this.height }) {
        if (!isObject(dims))
            dims = { w: this.width, h: this.height };
        const buffer = this.config.buffer || BUFFERSIZE;
        let w = (isNumber(dims?.w)) ? dims.w : this.width;
        let h = (isNumber(dims?.h)) ? dims.h : this.height;
        this.setHeight(h);
        if (this.graph instanceof Graph) {
            this.layerWidth = Math.round(w * ((100 + buffer) * 0.01));
            this.graph.setSize(w, h, this.layerWidth);
            this.draw(undefined, true);
            this.core.MainPane.draw(undefined, false);
            this.Divider.setPos();
            this.Divider.setWidth();
        }
    }
    setLocalRange(min, max) {
        if (!isNumber(max) ||
            !isNumber(min))
            return false;
        if (min > max)
            [min, max] = [max, min];
        this.#localRange = {
            valueMax: max,
            valueMin: min,
            valueDiff: max - min
        };
    }
    setYAxisType(t) {
        let type = YAXIS_TYPE.valid(t);
        if ((this.type == "primaryPane" && type == YAXIS_TYPE.percent))
            this.#yAxisType = YAXIS_TYPE.default;
        else
            this.#yAxisType = type;
        return true;
    }
    addOverlays(overlays) {
        if (!isArray(overlays) || overlays.length < 1)
            return false;
        const overlayList = [];
        for (let o of overlays) {
            const config = { fixed: false, required: false };
            if (o.type in this.core.indicatorClasses) {
                config.cnt = this.core.indicatorClasses[o.type].cnt;
                config.id = `${this.id}-${o.type}_${config.cnt}`;
                config.class = this.core.indicatorClasses[o.type];
                config.oType = "indicator";
            }
            else if (o.type in optionalOverlays[this.type]) {
                config.cnt = 1;
                config.id = `${this.id}-${o.type}`;
                config.class = optionalOverlays[this.type][o.type].class;
                config.oType = "overlayOptional";
            }
            else if (o.type in this.core.customOverlays[this.type]) {
                config.cnt = 1;
                config.id = `${this.id}-${o.type}`;
                config.class = this.core.customOverlays[this.type][o.type].class;
                config.oType = "overlayCustom";
            }
            else
                continue;
            config.params = { overlay: o, };
            o.id = config.id;
            o.paneID = this.id;
            o.key = indicatorHashKey(o);
            overlayList.push([o.id, config]);
        }
        this.graph.addOverlays(overlayList);
        return true;
    }
    addIndicator(i) {
        const primaryPane = this.type === "primaryPane";
        const indClass = this.core.indicatorClasses[i.type];
        const isPrimary = !!i.settings?.isPrimary;
        if (i?.type in this.core.indicatorClasses &&
            primaryPane === isPrimary) {
            i.paneID = this.id;
            i.key = indicatorHashKey(i);
            const config = {
                class: indClass,
                params: {
                    overlay: i,
                }
            };
            try {
                let indicator = this.graph.addOverlay(i.name, config);
                this.core.log(`Chart Pane ${this.id} added indicator: ${i.name}`);
                return indicator;
            }
            catch (e) {
                this.core.error(`ERROR: Chart Pane: ${this.id} cannot add Indicator: ${i?.name} Error: ${e.message}`);
                return undefined;
            }
        }
        else
            return undefined;
    }
    isDuplicate(key) {
        let ind = this.findIndicatorByKey(key);
        if (!ind)
            return false;
        else
            return ind.id;
    }
    findIndicatorByKey(key) {
        let iList = Object.values(this.getIndicators());
        for (let i of iList) {
            if (i.key = key)
                return i;
        }
        return undefined;
    }
    getIndicators() {
        const indicators = Object.keys(this.core.indicatorClasses);
        const ind = {};
        for (let [key, value] of Object.entries(this.overlays)) {
            if (indicators.includes(value.params?.overlay?.type)) {
                let id = value.id || value.instance.id;
                ind[id] = value;
            }
        }
        return ind;
    }
    removeIndicator(id, state = true) {
        if (!isString(id) || !(id in this.indicators))
            return false;
        this.#indicatorDeleteList[id] = true;
        if (Object.keys(this.indicators).length === 0 && !this.isPrimary)
            this.emit("chart_paneDestroy", this.id);
        else {
            this.indicators[id].instance.destroy(state);
            this.graph.removeOverlay(id);
            this.draw();
            delete this.#indicatorDeleteList[id];
        }
        return true;
    }
    removeAllIndicators(state) {
        const result = {};
        const all = this.getIndicators();
        for (let id in all) {
            result[id] = this.removeIndicator(id, state);
        }
        return result;
    }
    indicatorVisible(id, v) {
        if (!isString(id) || !(id in this.indicators))
            return false;
        return this.indicators[id].instance.visible(v);
    }
    indicatorSettings(id, s) {
        if (!isString(id) || !(id in this.indicators))
            return false;
        return this.indicators[id].instance.settings(s);
    }
    addTool(tool) {
        let { layerConfig } = this.layerConfig();
        let layer = new CEL.Layer(layerConfig);
        this.#layersTools.set(tool.id, layer);
        this.viewport.addLayer(layer);
        tool.layerTool = layer;
        this.#overlayTools.set(tool.id, tool);
    }
    addTools(tools) { }
    overlayToolAdd(tool) {
        this.#overlayTools.set(tool.id, tool);
    }
    overlayToolDelete(tool) {
        this.#overlayTools.delete(tool);
    }
    refresh() {
        this.emit("chart_paneRefresh", this);
        this.scale.draw();
        this.draw(undefined, this.isPrimary);
    }
    legendsVisibility(v) {
        this.legend.setCollapse(v);
    }
    updateLegends(pos = this.#cursorPos, candle = false) {
        if (this.core.IDEmpty || !isObject(this.#Legends))
            return;
        for (const legend in this.#Legends.list) {
            this.#Legends.update(legend, { pos, candle });
        }
    }
    legendInputs() {
        const labels = [true, true, true, true, true];
        const pos = this.cursorPos;
        const idx = this.time.xPos2Index(pos[0] - this.core.scrollPos);
        const index = limit(idx, 0, this.range.data.length - 1);
        const ohlcv = this.range.data[index];
        const theme = this.theme.candle;
        const inputs = {};
        const keys = ["T", "O", "H", "L", "C", "V"];
        let colours = [];
        if (isArray(ohlcv)) {
            colours = (ohlcv[4] >= ohlcv[1]) ?
                new Array(5).fill(theme.UpWickColour) :
                new Array(5).fill(theme.DnWickColour);
            for (let i = 1; i < 6; i++) {
                inputs[keys[i]] = this.scale.nicePrice(ohlcv[i]);
            }
        }
        return { inputs, colours, labels };
    }
    onLegendAction(e) {
        const action = this.#Legends.onPointerClick(e.currentTarget);
        switch (action.icon) {
            case "up":
                this.reorderUp();
                return;
            case "down":
                this.reorderDown();
                return;
            case "maximize":
                this.core.MainPane.chartPaneMaximize(this);
                return;
            case "restore":
                this.core.MainPane.chartPaneMaximize(this);
                return;
            case "collapse":
                this.core.MainPane.chartPaneCollapse(this);
                return;
            case "expand":
                this.core.MainPane.chartPaneCollapse(this);
                return;
            case "remove":
                this.remove();
                return;
            case "config":
                this.configDialogue();
                return;
            default: return;
        }
    }
    reorderUp() {
        const { el, prevEl, parentEl, scaleEl, prevScaleEl, parentScaleEl, prevPane, } = { ...this.currPrevNext() };
        if (!isObject(prevEl) || !isObject(prevScaleEl))
            return false;
        parentEl.insertBefore(el, prevEl);
        parentScaleEl.insertBefore(scaleEl, prevScaleEl);
        this.Divider.setPos();
        if (prevPane !== null) {
            prevPane.Divider.setPos();
            prevPane.Divider.show();
            this.core.ChartPanes.swapKeys(this.id, prevEl.id);
        }
        if (el.previousElementSibling === null)
            this.Divider.hide();
        return true;
    }
    reorderDown() {
        const { el, nextEl, parentEl, scaleEl, nextScaleEl, parentScaleEl, nextPane } = { ...this.currPrevNext() };
        if (!isObject(nextEl) || !isObject(nextScaleEl))
            return false;
        parentEl.insertBefore(nextEl, el);
        parentScaleEl.insertBefore(nextScaleEl, scaleEl);
        this.Divider.setPos();
        if (nextPane !== null) {
            nextPane.Divider.setPos();
            this.Divider.show();
            this.core.ChartPanes.swapKeys(this.id, nextEl.id);
        }
        if (nextEl.previousElementSibling === null)
            nextPane.Divider.hide();
        return true;
    }
    createGraph() {
        let overlays = doStructuredClone(this.overlaysDefault);
        this.graph = new Graph(this, this.elViewport, overlays, false);
        if (this.isPrimary) {
            this.layerStream = this.graph.overlays.get("stream")?.layer;
            this.chartStreamCandle = this.graph.overlays.get("stream")?.instance;
        }
        this.addOverlays(this.view);
    }
    render() {
        this.graph.render();
        this.#Scale.render();
    }
    draw(range = this.range, update = false) {
        this.graph.draw(range, update);
    }
    drawGrid() {
        this.layerGrid.setPosition(this.core.scrollPos, 0);
        this.overlayGrid.setRefresh();
        this.overlayGrid.draw("y");
        this.core.MainPane.draw();
    }
    resize(height) {
        const active = this;
        const prev = this.sibling();
        if (prev === null)
            return { active: null, prev: null };
        let activeHeight = this.element.clientHeight;
        const rowMinH = this.core.MainPane.rowMinH;
        const prevHeight = prev.element.clientHeight;
        const total = activeHeight + prevHeight;
        let yDelta, activeH, prevH;
        if (isNumber(height) && height > rowMinH) {
            activeH = height;
        }
        else {
            yDelta = this.core.MainPane.cursorPos[5];
            activeH = activeHeight - yDelta;
            activeH = limit(activeH, rowMinH, total - rowMinH);
            prevH = total - activeH;
        }
        active.setDimensions({ w: undefined, h: activeH });
        prev.setDimensions({ w: undefined, h: prevH });
        active.Divider.setPos();
        active.element.style.userSelect = 'none';
        prev.element.style.userSelect = 'none';
        return { active, prev };
    }
    collapse(h) {
        const vis = this.graph.viewport.scene.canvas.style;
        const col = this.#collapsed;
        const scale = this.#Scale.graph.viewport.scene.canvas.style;
        if (col.state) {
            this.setDimensions({ w: undefined, h });
            scale.visibility = "visible";
            vis.display = "block";
            col.state = false;
        }
        else {
            scale.visibility = "hidden";
            vis.display = "none";
            col.state = true;
            col.height = this.element.clientHeight;
            col.rowsHeight = this.core.MainPane.rowsH;
            col.rowsCnt = this.core.ChartPanes.size;
            this.setDimensions({ w: undefined, h: COLLAPSEDHEIGHT });
        }
    }
    zoomRange() {
        this.draw(this.range, true);
        this.emit("chart_zoomDone", true);
    }
    time2XPos(time) {
        return this.time.xPos(time);
    }
    price2YPos(price) {
        return this.scale.yPos(price);
    }
    currPrevNext() {
        const el = this.element;
        const prevEl = el.previousElementSibling;
        const nextEl = el.nextElementSibling;
        const parentEl = el.parentNode;
        const scaleEl = this.scale.element;
        const prevScaleEl = scaleEl.previousElementSibling;
        const nextScaleEl = scaleEl.nextElementSibling;
        const parentScaleEl = scaleEl.parentNode;
        const prevPane = (prevEl !== null) ? this.core.ChartPanes.get(prevEl.id) : null;
        const nextPane = (nextEl !== null) ? this.core.ChartPanes.get(nextEl.id) : null;
        return {
            el,
            prevEl,
            nextEl,
            parentEl,
            scaleEl,
            prevScaleEl,
            nextScaleEl,
            parentScaleEl,
            prevPane,
            nextPane
        };
    }
    sibling(s) {
        s = (["prev", "next"].includes(s)) ? s : "prev";
        let chartPanes = [...this.core.ChartPanes.keys()];
        let i = chartPanes.indexOf(this.id);
        if (s == "prev")
            --i;
        else
            ++i;
        return this.core.ChartPanes.get(chartPanes[i]) || null;
    }
    configDialogue() {
        const cd = this.#ConfigDialogue;
        if (cd.state.name === "closed")
            cd.open();
    }
}
class ChartPaneSnapshot {
    static { this.isPrimary = "boolean"; }
    static { this.maximized = "boolean"; }
    static { this.collapsed = "object"; }
    static { this.height = "number"; }
    static { this.indicators = "object"; }
    static get types() {
        let { ...types } = ChartPaneSnapshot;
        return types;
    }
    constructor(that) {
        let maxed = that.core.MainPane.chartPaneMaximized?.instance;
        this.isPrimary = that.isPrimary;
        this.maximized = (maxed?.id == that.id);
        this.collapsed = { ...that.collapsed };
        this.height = that.height;
        this.indicators = Object.keys(that.indicators).reduce((ind, key) => {
            ind[key] = that.indicators[key].instance.snapshot();
            return ind;
        }, {});
    }
}

var stateMachineConfig$2 = {
    id: "main",
    initial: "idle",
    context: {},
    states: {
        idle: {
            onEnter(data) {
            },
            onExit(data) {
            },
            on: {
                global_resize: {
                    target: 'global_resize',
                    action(data) {
                    },
                },
                chart_paneMaximize: {
                    target: 'chart_paneMaximize',
                    action(data) { }
                },
                range_set: {
                    target: 'range_set',
                    action(data) {
                    },
                },
                chart_pan: {
                    target: 'chart_pan',
                    action(data) {
                    },
                },
                chart_scrollTo: {
                    target: 'chart_scrollTo',
                    action(data) {
                    },
                },
                divider_pointerDrag: {
                    target: 'divider_pointerDrag',
                    action(data) {
                        this.context.currCursor = this.context.origin.cursor;
                        this.context.origin.cursor = "row-resize";
                    },
                },
                chart_IndicatorAdd: {
                    target: 'chart_IndicatorAdd',
                    action(data) {
                    },
                },
                chart_ToolActive: {
                    target: 'chart_ToolActive',
                    action(data) {
                    },
                },
                chart_ToolInactive: {
                    target: 'chart_ToolInactive',
                    action(data) {
                    },
                },
            }
        },
        global_resize: {
            onEnter(data) {
                this.context.origin.setDimensions();
            },
            onExit(data) {
            },
            on: {
                always: {
                    target: 'idle',
                    condition: 'resizeDone',
                    action(data) {
                    },
                },
            },
        },
        chart_paneMaximize: {
            onEnter(data) { },
            onExit(data) { },
            on: {
                always: {
                    target: 'idle',
                    action(data) {
                        this.context.maximize = "some pane pointer";
                    },
                },
            }
        },
        range_set: {
            onEnter(data) {
            },
            onExit(data) {
            },
            on: {
                always: {
                    target: 'idle',
                    condition: 'zoomDone',
                    action(data) {
                        this.context.origin.zoomRange(data);
                    },
                },
            }
        },
        chart_pan: {
            onEnter(data) {
                this.context.origin.cursor = "grab";
            },
            onExit(data) {
            },
            on: {
                chart_pan: {
                    target: 'chart_pan',
                    action(data) {
                        this.context.origin.updateRange(data);
                        this.context.origin.cursor = "grab";
                    },
                },
                chart_panDone: {
                    target: 'idle',
                    action(data) {
                        this.context.origin.updateRange(data);
                        this.context.origin.cursor = "default";
                    },
                },
            }
        },
        chart_scrollTo: {
            onEnter(data) {
            },
            onExit(data) {
            },
            on: {
                always: {
                    target: 'idle',
                    action(data) {
                        this.context.origin.updateRange(data);
                    },
                },
            }
        },
        divider_pointerDrag: {
            onEnter(data) {
            },
            onExit(data) {
            },
            on: {
                divider_pointerDrag: {
                    target: "divider_pointerDrag",
                    action(data) {
                    },
                },
                divider_pointerDragEnd: {
                    target: "idle",
                    action(data) {
                        this.context.origin.cursor = this.context.currCursor;
                    },
                },
            }
        },
        chart_IndicatorAdd: {
            onEnter(data) {
                this.context.origin.addIndicator(data);
            },
            onExit(data) {
            },
            on: {
                chart_IndicatorAddDone: {
                    target: "idle",
                    action(data) {
                    },
                }
            }
        },
        chart_ToolActive: {
            onEnter(data) {
            },
            onExit(data) {
            },
            on: {
                chart_ToolInactive: {
                    target: "chart_ToolInactive",
                    action(data) {
                    },
                }
            }
        },
        chart_ToolInactive: {
            onEnter(data) {
            },
            onExit(data) {
            },
            on: {
                always: {
                    target: "idle",
                    action(data) {
                    },
                }
            }
        },
    },
    guards: {
        zoomDone() { return true; },
        resizeDone() { return true; },
    },
    actions: {
        removeProperty() {
            let active = this.context.pair.active, prev = this.context.pair.prev;
            if (isObject(active))
                active.element.style.removeProperty('user-select');
            if (isObject(prev))
                prev.element.style.removeProperty('user-select');
        }
    }
};

const defaultOverlays = [
    ["grid", { class: chartGrid, fixed: false, required: true, params: { axes: "x" } }],
];
const nonIndicators = ["candles", "trades", "events"];
class MainPane extends Component {
    #name = "MainPane";
    #shortName = "Main";
    #destruction = false;
    #elMain;
    #elRows;
    #elTime;
    #elScale;
    #elGrid;
    #elCanvas;
    #elViewport;
    #Graph;
    #RenderLoop;
    #layerGrid;
    #layerWatermark;
    #Chart;
    #Time;
    #chartGrid;
    #chartDeleteList = {};
    #viewDefaultH = SECONDARYDEFAULTHEIGHT;
    #rowMinH = ROWMINHEIGHT;
    #position = {};
    #cursorPos = [0, 0];
    #drag = {
        active: false,
        start: [0, 0],
        prev: [0, 0],
        delta: [0, 0]
    };
    #buffer;
    #controller;
    #input;
    #scaleW = 0;
    #scaleWOld = 0;
    constructor(core, options) {
        options.parent = core;
        super(core, options);
        this.init(options);
    }
    get name() { return this.#name; }
    get shortName() { return this.#shortName; }
    get chart() { return this.#Chart; }
    get chartPanes() { return this.core.state.chartPanes; }
    get chartPaneMaximized() { return this.core.state.chartPaneMaximized; }
    get chartDeleteList() { return this.#chartDeleteList; }
    get time() { return this.#Time; }
    get element() { return this.#elMain; }
    get elRows() { return this.#elMain.rows; }
    get elPrimary() { return this.#elMain.rows.primary; }
    get elSecondary() { return this.#elMain.rows.secondary; }
    get elPanes() { return this.#elMain.rows.chartPanes; }
    get elPaneSlot() { return this.#elMain.rows.chartPaneSlot; }
    get width() { return this.#elMain.getBoundingClientRect().width; }
    get height() { return this.#elMain.getBoundingClientRect().height; }
    get chartW() { return this.elPrimary.getBoundingClientRect().width; }
    get chartH() { return this.elPrimary.getBoundingClientRect().height; }
    get rowsW() { return this.#elRows.getBoundingClientRect().width; }
    get rowsH() { return this.#elRows.getBoundingClientRect().height; }
    get rowMinH() { return this.#rowMinH; }
    set rowMinH(h) { if (isNumber(h))
        this.#rowMinH = Math.abs(h); }
    get pos() { return this.dimensions; }
    get dimensions() { return elementDimPos(this.#elMain); }
    set cursor(c) { this.element.style.cursor = c; }
    get cursor() { return this.element.style.cursor; }
    get cursorPos() { return this.#cursorPos; }
    get candleW() { return this.#Time.candleW; }
    get buffer() { return this.#buffer; }
    get bufferPx() { return this.getBufferPx(); }
    get scrollPos() { return this.core.scrollPos; }
    get renderLoop() { return this.#RenderLoop; }
    get inventory() { return this.core.state.data.inventory; }
    get indicators() { return this.getIndicators(); }
    get indicatorClasses() { return this.core.indicatorClasses; }
    get elements() {
        return {
            elRows: this.elRows,
            elPrimary: this.elPrimary,
            elSecondary: this.elSecondary,
            elTime: this.#elTime,
            elScale: this.#elScale
        };
    }
    init(options) {
        this.core;
        this.#elMain = this.core.elMain;
        this.#elRows = this.#elMain.rows;
        this.#elTime = this.#elMain.time;
        this.#elGrid = this.#elMain.rows.grid;
        this.#elViewport = this.#elMain.viewport;
        this.#elScale = this.core.elBody.scale;
        options.name = "Chart";
        options.shortName = "Chart";
        options.parent = this;
        options.rangeLimit = this.core.rangeLimit;
        options.settings = this.core.settings;
        options.elements = { ...options.elements, ...this.elements };
        if (this.core.theme?.time?.navigation === false) {
            const timeHeight = { height: TIMESCALEH };
            this.core.theme.time = { ...this.core.theme?.time, ...timeHeight };
        }
        this.#Time = new Timeline(this.core, options);
        this.chartPanes.clear();
        this.chartPanesRegister(options);
        this.#buffer = isNumber(this.config.buffer) ? this.config.buffer : BUFFERSIZE;
        this.#rowMinH = isNumber(this.config.rowMinH) ? this.config.rowMinH : ROWMINHEIGHT;
        this.#viewDefaultH = isNumber(this.config.secondaryPaneDefaultH) ? this.config.secondaryPaneDefaultH : SECONDARYDEFAULTHEIGHT;
        this.rowsOldH = this.rowsH;
        const renderLoopConfig = {
            graphs: [this.graph],
            range: this.range,
            core: this.core
        };
        this.#RenderLoop = new RenderLoop(renderLoopConfig);
    }
    start() {
        this.#elMain.start(this.theme);
        this.#Time.start();
        this.createGraph();
        this.rowsOldH = this.rowsH;
        this.chartPanesStart();
        this.chartPanesSizeToInventory();
        this.setScaleWidth();
        this.draw(this.range, true);
        this.renderLoop.start();
        this.renderLoop.queueFrame(this.range, [this.graph], false);
        this.eventsListen();
        stateMachineConfig$2.id = this.id;
        stateMachineConfig$2.context = this;
        this.stateMachine = stateMachineConfig$2;
        this.stateMachine.start();
        this.log(`Main Pane ${this.#name} instantiated and running`);
    }
    destroy(indicators = true) {
        this.#destruction = true;
        this.renderLoop.stop();
        this.stateMachine.destroy();
        this.chartPanes.forEach((chartPane, key) => {
            if (!!indicators)
                chartPane.remove();
            else
                chartPane.deactivate();
            delete this.#chartDeleteList[key];
        });
        this.graph.destroy();
        this.time.destroy();
        this.core.hub.expunge(this);
        this.#input.destroy();
        this.graph = null;
    }
    reset() {
        let indicators = this.core.Indicators;
        for (let p in indicators) {
            for (let i in indicators[p]) {
                this.core.removeIndicator(i);
            }
        }
        return;
    }
    removeAllRowElements() {
        this.#elMain.rows.shadowRoot = "";
        this.#elScale.shadowRoot = "";
    }
    eventsListen() {
        this.#input = new Input(this.#elRows, { disableContextMenu: false });
        this.#input.on("keydown", this.onChartKeyDown.bind(this));
        this.#input.on("keyup", this.onChartKeyUp.bind(this));
        this.#input.on("wheel", this.onMouseWheel.bind(this));
        this.#input.on("pointerenter", this.onMouseEnter.bind(this));
        this.#input.on("pointerout", this.onMouseOut.bind(this));
        this.#input.on("pointerup", this.onChartDragDone.bind(this));
        this.#input.on("pointermove", this.onMouseMove.bind(this));
        this.on(STREAM_FIRSTVALUE, this.onFirstStreamValue, this);
        this.on(STREAM_NEWVALUE, this.onNewStreamValue, this);
        this.on("range_set", this.onSetRange, this);
        this.on("chart_scrollUpdate", this.draw, this);
        this.on("chart_render", this.draw, this);
        this.on("chart_paneDestroy", this.chartPaneRemove, this);
    }
    onSetRange() {
        this.#scaleWOld = this.#scaleW;
        this.#scaleW = this.chart.scale.calcScaleWidth();
        if (this.#scaleWOld != this.#scaleW) {
            this.core.elBody.setYAxisWidth(this.#scaleW);
            this.setDimensions();
            this.draw();
        }
    }
    onMouseWheel(e) {
        const direction = Math.sign(e.wheeldelta) * -1;
        e.domEvent.preventDefault();
        if (this.core.pointerButtons[0]) {
            e.dragstart.x = this.#cursorPos[0];
            e.dragstart.y = this.#cursorPos[1];
            e.position.x = this.#cursorPos[0] + direction;
            e.position.y = this.#cursorPos[1];
            this.onChartDrag(e);
            return;
        }
        const range = this.range;
        let newStart = range.indexStart - Math.floor(direction * XAXIS_ZOOM * range.Length);
        let newEnd = range.indexEnd + Math.ceil(direction * XAXIS_ZOOM * range.Length);
        if (range.isPastLimit(newStart))
            newStart = range.indexPastLimit + 1;
        if (range.isFutureLimit(newEnd))
            newEnd = range.indexFutureLimit - 1;
        if (newEnd - newStart > range.maxCandles ||
            newEnd - newStart < range.minCandles)
            return;
        this.core.setRange(newStart, newEnd);
        this.draw(this.range, true);
    }
    onMouseMove(e) {
        const p = this.#position;
        p.d2x = p?.d1x || null;
        p.d2y = p?.d1y || null;
        p.d1x = e.movement.x;
        p.d1y = e.movement.y;
        p.dx = Math.floor((p.d1x + p.d2x) / 2);
        p.dy = Math.floor((p.d1y + p.d2y) / 2);
        p.ts2 = p?.ts1 || null;
        p.ts1 = Date.now();
        this.#cursorPos = [
            e.position.x, e.position.y,
            e.dragstart.x, e.dragstart.y,
            p.dx, p.dy,
            p.ts1, p.ts1 - p.ts2
        ];
        this.core.Timeline.showCursorTime();
        this.core.Chart.graph.overlays.list.get("cursor").layer.visible = true;
        for (let [key, secondaryPane] of this.chartPanes) {
            secondaryPane.graph.overlays.list.get("cursor").layer.visible = true;
        }
        this.emit("main_mouseMove", this.#cursorPos);
    }
    onMouseEnter(e) {
        this.core.Timeline.showCursorTime();
        this.core.Chart.graph.overlays.list.get("cursor").layer.visible = true;
        this.core.Chart.graph.render();
        for (let [key, secondaryPane] of this.chartPanes) {
            secondaryPane.graph.overlays.list.get("cursor").layer.visible = true;
            secondaryPane.graph.render();
        }
    }
    onMouseOut(e) {
        this.onPointerActive(false);
        this.core.Timeline.hideCursorTime();
        this.core.Chart.graph.overlays.list.get("cursor").layer.visible = false;
        this.core.Chart.graph.render();
        for (let [key, secondaryPane] of this.chartPanes) {
            secondaryPane.graph.overlays.list.get("cursor").layer.visible = false;
            secondaryPane.graph.render();
        }
        this.draw();
    }
    onChartDrag(e) {
        const d = this.#drag;
        if (!d.active) {
            d.active = true;
            d.start = [e.position.x, e.position.y];
            d.prev = d.start;
            d.delta = [0, 0];
        }
        else {
            d.delta = [
                e.position.x - d.prev[0],
                e.position.y - d.prev[1]
            ];
            d.prev = [
                e.position.x,
                e.position.y
            ];
        }
        this.#cursorPos = [
            e.position.x, e.position.y,
            ...d.start,
            ...d.delta
        ];
        this.emit("chart_pan", this.#cursorPos);
    }
    onChartDragDone(e) {
        const d = this.#drag;
        d.active = false;
        d.delta = [0, 0];
        this.#cursorPos = [
            ...d.prev,
            ...d.start,
            ...d.delta
        ];
        this.emit("chart_panDone", this.#cursorPos);
    }
    onChartKeyDown(e) {
        let step = (this.candleW > 1) ? this.candleW : 1;
        switch (e.key) {
            case "ArrowLeft":
                this.emit("chart_pan", [0, null, step, null, step * -1, null]);
                break;
            case "ArrowRight":
                this.emit("chart_pan", [step, null, 0, null, step, null]);
                break;
            case "ArrowUp":
                e.wheeldelta = -1;
                e.domEvent = e.srcEvent;
                this.onMouseWheel(e);
                break;
            case "ArrowDown":
                e.wheeldelta = 1;
                e.domEvent = e.srcEvent;
                this.onMouseWheel(e);
                break;
        }
    }
    onChartKeyUp(e) {
        let step = (this.candleW > 1) ? this.candleW : 1;
        switch (e.key) {
            case "ArrowLeft":
                this.emit("chart_panDone", [0, null, step, null, step * -1, null]);
                break;
            case "ArrowRight":
                this.emit("chart_panDone", [step, null, 0, null, step, null]);
                break;
        }
    }
    onFirstStreamValue(value) {
    }
    onNewStreamValue(value) {
    }
    onPointerActive(chart) {
        if (chart) {
            chart.cursorActive = true;
            chart.scale.layerCursor.visible = true;
        }
        if (chart !== this.chart) {
            this.chart.cursorActive = false;
            this.chart.scale.layerCursor.visible = false;
            this.chart.scale.layerCursor.erase();
        }
        this.chartPanes.forEach((secondaryPane, key) => {
            if (chart !== secondaryPane) {
                secondaryPane.cursorActive = false;
                secondaryPane.scale.layerCursor.visible = false;
                secondaryPane.scale.layerCursor.erase();
            }
        });
    }
    setDimensions() {
        this.#elRows.previousDimensions();
        let siblings = this.core.elBody.shadowRoot.children;
        let width = this.core.elBody.offsetWidth;
        for (let s of siblings) {
            if (s.tagName != "TRADEX-MAIN")
                width -= s?.offsetWidth || 0;
        }
        let resizeH = this.#elRows.heightDeltaR;
        let chartH = Math.round(this.chartH * resizeH);
        let height = this.rowsH;
        let layerWidth = Math.round(width * ((100 + this.#buffer) * 0.01));
        let dimensions = {
            resizeH: resizeH,
            mainH: this.element.height,
            mainW: width,
            rowsH: this.rowsH,
            rowsW: this.rowsW,
        };
        this.core.scrollPos = -1;
        this.#elViewport.style.width = `${width}px`;
        this.#elViewport.style.height = `${height}px`;
        this.#Time.setDimensions({ w: width });
        this.graph.setSize(width, height, layerWidth);
        this.#elViewport.style.width = `${width}px`;
        if (this.chartPanes.size == 1 && chartH != this.#elRows.height) {
            this.#Chart.setDimensions({ w: width, h: this.#elRows.height });
        }
        else {
            this.chartPanes.forEach((chartPane, key) => {
                chartH = Math.round(chartPane.element.height * resizeH);
                chartPane.setDimensions({ w: width, h: chartH });
            });
        }
        this.rowsOldH = this.rowsH;
        this.emit("chart_rowsResize", dimensions);
        this.draw(undefined, true);
    }
    setScaleWidth(draw = false) {
        const { expanded: exp } = this.chartPanesState();
        let scaleW = 0;
        if (this.chartPanes.size === 1) {
            scaleW = this.chartPanes.values().next().value.scale.calcScaleWidth();
        }
        else {
            for (let o of exp) {
                let w = o.scale.calcScaleWidth();
                scaleW = (w > scaleW) ? w : scaleW;
            }
        }
        this.core.elBody.setYAxisWidth(scaleW);
    }
    getBufferPx() {
        let w = Math.round(this.width * this.buffer / 100);
        let r = w % this.candleW;
        return w - r;
    }
    chartPanesRegister(options) {
        this.#elRows.previousDimensions();
        this.validateIndicators();
        for (let p of this.inventory) {
            if (p instanceof ChartPaneSnapshot) {
                options.type = (p.isPrimary) ? "primary" : "secondary";
                options.view = p.indicators;
                options.state = p;
            }
            else if (isArray(p) && p.length > 1) {
                options.type = (p[0] == "primary") ? p[0] : "secondary";
                options.view = (isArrayOfType(p[1], "object")) ? p[1] : [p[1]];
                options.state = p[2];
            }
            this.chartPaneAdd(options);
        }
    }
    chartPanesSizeToInventory() {
        if (!this.chartPanes.size ||
            !isObject(this.#Chart.options?.state))
            return;
        const heights = {};
        let collapsed = false;
        let total = 0;
        let h, colRowsH;
        this.chartPanes.forEach((pane, key) => {
            let state = pane.options.state;
            h = state.height;
            state.collapsed.height;
            heights[key] = h;
            total += h;
            collapsed = collapsed || state.collapsed.height;
            if (isNumber(state.collapsed.rowsHeight)) {
                colRowsH = state.collapsed.rowsHeight;
                state.collapsed.rowsCnt;
            }
        });
        if (!collapsed)
            return;
        if (colRowsH != this.rowsH) {
            console.log("total does not match Row Height");
            this.rowsH - total;
        }
        this.chartPanes.forEach((pane, key) => {
            pane.setDimensions({ h: heights[key] });
        });
        this.chartPanes.forEach((pane, key) => {
            if (!!pane.options?.state?.collapsed?.state) {
                this.chartPaneCollapse(pane);
            }
            if (!!pane.options?.state?.maximized) {
                this.chartPaneMaximize(pane);
            }
        });
    }
    chartPanesStart() {
        let i = 0;
        this.chartPanes.forEach((pane, key) => {
            pane.start(i++);
            if (i === 1) {
                pane.Divider.hide();
            }
        });
    }
    chartPanesState() {
        const state = {
            list: [...this.chartPanes.values()],
            collapsed: [],
            expanded: [],
            maximized: this.chartPaneMaximized?.instance
        };
        for (let o of state.list) {
            if (o.collapsed.state)
                state.collapsed.push(o);
            else
                state.expanded.push(o);
        }
        return state;
    }
    chartPaneAdd(params) {
        const { expanded: exp } = this.chartPanesState();
        const heights = this.chartPaneHeightsCalc(params?.state);
        const n = heights.new;
        let h;
        for (h in heights) {
            if (this.chartPanes.has(h)) {
                let o = this.chartPanes.get(h);
                if (exp.indexOf(o) > -1)
                    o.setDimensions({ w: this.rowsW, h: heights[h] });
            }
        }
        let row = this.#elMain.addRow(params.type, "", this.core, n);
        let axis = this.#elMain.addScaleRow(params.type, n, this.#elScale);
        params.elements.elTarget = row;
        params.elements.elScale = axis;
        let o;
        if (params.type == "primary") {
            o = new Chart(this.core, params);
            this.#Chart = o;
        }
        else {
            params.type = "secondary";
            params.name = params.view?.[0]?.name || "Secondary";
            params.shortName = params.view?.[0]?.type || "Secondary";
            o = new Chart(this.core, params);
        }
        this.chartPanes.set(o.id, o);
        const tally = this.chartPaneHeightsTally();
        if (tally.total > this.#elMain.height) ;
        this.chartPaneDividersSet();
        this.emit("chart_paneAdd", o);
        return o;
    }
    chartPaneRemove(paneID) {
        if (!isString(paneID) ||
            !this.chartPanes.has(paneID) ||
            paneID in this.#chartDeleteList)
            return false;
        const chartPane = this.chartPanes.get(paneID);
        if (chartPane.isPrimary && !this.#destruction) {
            this.core.error(`Cannot remove primary chart pane! ${paneID}`);
            return false;
        }
        this.#chartDeleteList[paneID] = true;
        const { expanded: exp } = this.chartPanesState();
        let i = exp.indexOf(chartPane);
        if (i > -1)
            exp.splice(i, 1);
        let h = chartPane.viewport.height;
        let x = Math.floor(h / (exp.length));
        let r = h % x;
        if (chartPane.status !== "destroyed") {
            chartPane.destroy();
            this.#elMain.removeRow(chartPane.id);
        }
        this.chartPanes.delete(paneID);
        this.setScaleWidth();
        if (this.chartPanes.size === 1) {
            let o = this.chartPanes.values().next().value;
            if (o.collapsed)
                o.collapsed.state = false;
            o.setDimensions({ w: undefined, h: this.rowsH });
        }
        else {
            for (let o of exp) {
                h = o.viewport.height;
                o.setDimensions({ w: undefined, h: h + x + r });
                r = 0;
            }
        }
        this.chartPaneDividersSet();
        this.draw(this.range, true);
        return true;
    }
    chartPaneRemoveRows() {
    }
    chartPaneHeightsTally() {
        const panes = this.chartPanes.entries();
        const heights = { panes: {}, total: 0 };
        for (let [key, value] of panes) {
            heights.panes[key] = value;
            heights.total += value.height;
        }
        return heights;
    }
    chartPaneHeightsCalc(newPane) {
        const { collapsed: col, expanded: exp } = this.chartPanesState();
        const cnt = this.chartPanes.size + 1;
        const a = this.#viewDefaultH * (cnt - 1), ratio = (a / Math.log10(a * 2)) / 100; Math.round(this.rowsH * ratio); const sizes = {}, paneH = (o) => { return o.height; };
        if (cnt === 1) {
            sizes.new = this.rowsH;
        }
        else if (cnt === 2 || exp.length === 1) {
            let height = this.rowsH;
            const newPane = Math.round(height * this.#viewDefaultH / 100);
            sizes[exp[0].id] = height - newPane;
            sizes.new = newPane;
        }
        else if (exp.length === 2) {
            const first = paneH(exp[0]);
            const second = paneH(exp[1]);
            const height = first + second;
            const newPane = Math.round(height * this.#viewDefaultH / 100);
            const ratio = height / (height + newPane);
            sizes[exp[0].id] = Math.floor(first * ratio);
            sizes[exp[1].id] = Math.floor(second * ratio);
            sizes.new = Math.floor(newPane * ratio);
            sizes.new += height - (sizes[exp[0].id] + sizes[exp[1].id] + sizes.new);
        }
        else if (exp.length >= 3) {
            let height = this.rowsH;
            let total = 0;
            let ratio;
            for (let o of col) {
                height -= paneH(o);
            }
            sizes.new = Math.floor(height / (exp.length + 1));
            ratio = height / (height + sizes.new);
            sizes.new *= ratio;
            for (let o of exp) {
                sizes[o.id] = paneH(o) * ratio;
                total += sizes[o.id];
            }
        }
        return sizes;
    }
    chartPaneMaximize(p) {
        if (!(p instanceof Chart))
            return false;
        const maxMin = this.chartPaneMaximized;
        const controls = p.legend.list.chart.el.querySelector(".controls");
        let style;
        controls.classList.toggle("maximized");
        controls.classList.toggle("restored");
        if (p === maxMin.instance) {
            this.chartPanesRestore();
            maxMin.instance = null;
            maxMin.panes = {};
            if (p.collapsed.state) {
                p.graph.viewport.scene.canvas.style.display = "none";
                p.scale.graph.viewport.scene.canvas.style.visibility = "hidden";
            }
        }
        else {
            this.chartPanesRestore();
            maxMin.instance = p;
            maxMin.rowsH = this.rowsH;
            for (let [k, v] of this.chartPanes.entries()) {
                maxMin.panes[k] = v.element.clientHeight;
                style = v.element.style;
                if (p === v) {
                    style.display = "block";
                    v.setDimensions({ w: undefined, h: this.rowsH });
                    v.graph.viewport.scene.canvas.style.display = "block";
                    v.scale.graph.viewport.scene.canvas.style.visibility = "visible";
                }
                else {
                    style.display = "none";
                    v.scale.element.style.display = "none";
                }
            }
            this.chartPaneDividersHide();
        }
        this.emit("chart_paneRefresh", this);
        return true;
    }
    chartPanesRestore() {
        const maxMin = this.chartPaneMaximized;
        let i = 0;
        this.emit("chart_paneRefresh", this);
        if (this.dimensions.height == maxMin.height) ;
        for (let [k, v] of this.chartPanes.entries()) {
            v.element.style.display = "block";
            v.scale.element.style.display = "block";
            if (k in maxMin.panes)
                if (i++ > 0)
                    v.Divider.show();
            v.setDimensions({ w: undefined, h: maxMin.panes[k] });
        }
    }
    chartPaneCollapse(p) {
        if (!(p instanceof Chart))
            return false;
        this.emit("chart_paneRefresh", this);
        const controls = p.legend.list.chart.el.querySelector(".controls");
        const pc = p.collapsed;
        let h = p.element.clientHeight;
        let i, j, n;
        const { list: v, collapsed: col, expanded: exp } = this.chartPanesState();
        i = col.indexOf(p);
        if (i > -1)
            col.splice(i, 1);
        i = exp.indexOf(p);
        if (i > -1)
            exp.splice(i, 1);
        if (p.collapsed.state) {
            controls.classList.remove("collapsed");
            controls.classList.add("expanded");
            if (pc.rowsCnt !== v.length) {
                h = pc.height * (pc.rowsCnt / v.length);
            }
            else if (pc.rowsHeight !== this.rowsH) {
                h = pc.height * (pc.rowsHeight / this.rowsH);
            }
            else {
                h = pc.height;
            }
            j = (h - COLLAPSEDHEIGHT) / exp.length;
            for (let o of exp) {
                n = o.element.clientHeight - j;
                o.setDimensions({ w: undefined, h: n });
            }
            p.collapse(h);
        }
        else {
            controls.classList.add("collapsed");
            controls.classList.remove("expanded");
            if (v.length < 2)
                return false;
            if (exp.length < 1)
                return false;
            h = (p.element.clientHeight - COLLAPSEDHEIGHT) / exp.length;
            for (let o of exp) {
                n = o.element.clientHeight + h;
                o.setDimensions({ w: undefined, h: n });
            }
            p.collapse();
        }
        this.chartPaneDividersSet();
        return true;
    }
    chartPaneDividersSet() {
        const { list: v } = this.chartPanesState();
        let i = 0;
        for (let o of v) {
            if (o.Divider instanceof Divider &&
                i++ > 0) {
                o.Divider.setWidth();
                o.Divider.setPos();
                o.Divider.show();
            }
        }
    }
    chartPaneDividersHide() {
        const { list: v } = this.chartPanesState();
        for (let o of v) {
            if (o.Divider instanceof Divider) {
                o.Divider.hide();
            }
        }
    }
    validateIndicators() {
        const isValidIndicatorObj = (o) => {
            return isObject(o) &&
                (o.type in this.core.indicatorClasses ||
                    nonIndicators.includes(o.type));
        };
        const isValidArr = (o) => {
            if (!isArray(o))
                return false;
            o.forEach((value, index) => {
                if (!isValidIndicatorObj(value)) {
                    this.core.log(`TradeX-Chart: ${this.core.ID} : indicator ${value?.type} not added: not supported.`);
                    o.splice(index, 1);
                }
            });
            return !o.length;
        };
        this.inventory.forEach((v, i) => {
            isValidArr(v[1]);
        });
    }
    addIndicator(i, name = i, params = {}) {
        let instance, pane;
        let isPrimary = this.indicatorClasses[i]?.primaryPane;
        if (!isString(i) ||
            !(i in this.indicatorClasses) ||
            !isString(name))
            return undefined;
        this.log(`Adding the ${name} : ${i} indicator`);
        if (!isObject(params))
            params = { data: [], settings: [] };
        else {
            if (!isArray(params?.data))
                params.data = [];
            if (!isObject(params?.settings))
                params.settings = {};
        }
        switch (isPrimary) {
            case true:
            case false:
                break;
            case undefined:
            case "both":
                isPrimary = (isBoolean(params.settings?.isPrimary)) ?
                    params.settings.isPrimary : true;
        }
        params.settings.isPrimary = isPrimary;
        if (isPrimary) {
            const indicator = {
                type: i,
                name: name,
                ...params
            };
            instance = this.#Chart.addIndicator(indicator);
            if (!instance)
                return undefined;
            pane = "primary";
        }
        else {
            if (!isArray(params.view))
                params.view = [{ name, type: i, ...params }];
            for (let v = 0; v < params.view.length; v++) {
                if (!isObject(params.view[v]) || !valuesInArray(["name", "type"], Object.keys(params.view[v])))
                    params.view.splice(v, 1);
            }
            if (params.view.length == 0)
                return undefined;
            params.parent = this;
            params.title = name;
            params.elements = { ...this.elements };
            params.yAxisPadding = this.core.indicatorClasses[i]?.yAxisPadding || 1;
            instance = this.chartPaneAdd(params);
            if (!instance)
                return undefined;
            instance.start();
            pane = "secondary";
            this.emit("chart_secondaryAdd", instance);
        }
        const id = ("instance" in instance) ? instance.instance.id : instance.id;
        this.refresh();
        this.core.state.addIndicator(instance, pane);
        this.core.log(`Added indicator:`, id);
        this.emit("chart_IndicatorAddDone", instance);
        return instance;
    }
    getIndicators() {
        const ind = {};
        this.chartPanes.forEach((value, key) => {
            ind[key] = value.indicators;
        });
        return ind;
    }
    getIndicatorsByType(t) {
        const r = [];
        if (!isString(t))
            return r;
        for (let p of this.chartPanes.values()) {
            for (let i in p.indicators) {
                let inst = p.indicators[i].instance;
                if (inst.shortName == t ||
                    inst.libName == t)
                    r.push(inst);
            }
        }
        return r;
    }
    getIndicator(i) {
        if (!isString(i))
            return false;
        for (const p of this.chartPanes.values()) {
            if (i in p.indicators) {
                return p.indicators[i].instance;
            }
        }
        return false;
    }
    removeIndicator(i) {
        if (isString(i)) {
            for (const p of this.chartPanes.values()) {
                if (i in p.indicators) {
                    i = p.indicators[i].instance;
                }
            }
        }
        if (!(i instanceof Indicator))
            return false;
        if (i.chart.type === "primaryPane" ||
            Object.keys(i.chart.indicators).length > 1) {
            i.remove();
            this.emit("chart_paneRefresh", this);
        }
        else
            i.chart.remove();
        return true;
    }
    indicatorSettings(i, s) {
        if (isString(i)) {
            for (const p of this.chartPanes.values()) {
                if (i in p.indicators) {
                    return p.indicators[i].instance.settings(s);
                }
            }
        }
        else if (i instanceof Indicator) {
            return i.settings(s);
        }
        else
            return false;
    }
    createGraph() {
        let overlays = doStructuredClone(defaultOverlays);
        this.graph = new Graph(this, this.#elViewport, overlays);
    }
    draw(range = this.range, update = false) {
        range = (isObject(range)) ? range : this.range;
        const graphs = [
            this.graph,
            this.#Time,
        ];
        this.time.xAxis.doCalcXAxisGrads(range);
        this.chartPanes.forEach((chartPane, key) => {
            if (chartPane.status !== "destroyed")
                graphs.push(chartPane);
            else
                this.error(`ERROR: attempted to draw destroyed pane: ${chartPane.id}`);
        });
        this.renderLoop.queueFrame(this.range, graphs, update);
    }
    refresh() {
        if (!(this.core.Chart?.graph instanceof Graph))
            return;
        this.renderLoop.expungeFrames();
        this.core.Chart.graph.refresh();
        for (let [key, secondaryPane] of this.chartPanes) {
            secondaryPane?.graph?.refresh();
        }
        this.draw(this.range, true);
    }
    updateRange(pos) {
        this.core.updateRange(pos);
    }
    zoomRange() {
        this.draw(this.range, true);
    }
}

const SECOND_MS = 1000;
const MINUTE_MS = SECOND_MS * 60;
const HOUR_MS = MINUTE_MS * 60;
const DAY_MS = HOUR_MS * 24;
const MONTHR_MS = DAY_MS * 30;
const YEAR_MS = DAY_MS * 365;
const defaultTimeFramesShort = {
    "1m": MINUTE_MS,
    "2m": MINUTE_MS * 2,
    "3m": MINUTE_MS * 3,
    "5m": MINUTE_MS * 5,
    "10m": MINUTE_MS * 10,
    "15m": MINUTE_MS * 15,
    "30m": MINUTE_MS * 30,
    "1h": HOUR_MS,
    "2h": HOUR_MS * 2,
    "3h": HOUR_MS * 3,
    "4h": HOUR_MS * 4,
    "1d": DAY_MS,
    "1w": DAY_MS * 7,
    "1M": MONTHR_MS,
    "3M": MONTHR_MS * 3,
    "6M": MONTHR_MS * 6,
    "1y": YEAR_MS
};
class DataSource {
    static #chartList = new xMap();
    static #sourceList = new xMap();
    static #sourceCnt = 0;
    static get defaultTimeFrames() { return defaultTimeFramesShort; }
    static create(cfg, state) {
        if (!isObject(cfg) ||
            !(state.core instanceof TradeXchart) ||
            !(state instanceof State))
            return undefined;
        let dataSource = new DataSource(cfg, state);
        DataSource.#sourceList.set(dataSource, state);
        return dataSource;
    }
    static delete(key) {
        if (key instanceof DataSource ||
            !State.has(key))
            return false;
        DataSource.#sourceList.delete(key);
    }
    static has(key) {
        return DataSource.#sourceList.has(key);
    }
    static get(key) {
        return DataSource.#sourceList.get(key);
    }
    static list(chart) {
        let sources = DataSource.sourceList(chart)?.sources;
        if (!sources)
            return undefined;
        return Array.from(sources, ([key, value]) => ({ key, value }));
    }
    static sourceList(chart) {
    }
    #cnt;
    #id;
    #core;
    #cfg;
    #source = doStructuredClone(DEFAULT_STATE.dataSource.source);
    #symbol;
    #state;
    #range;
    #stream;
    #timeFrames = {};
    #timeFrameCurr;
    #waiting = false;
    #fetching = false;
    constructor(cfg, state) {
        this.#cfg = cfg;
        this.#state = state;
        this.#core = state.core;
        this.#cnt = ++DataSource.#sourceCnt;
        this.symbolsAdd(cfg?.symbols);
        this.sourceSet(cfg?.source);
        this.symbolSet(cfg?.symbol);
        this.#id = uid(`${SHORTNAME}_dataSource_${this.#symbol}`);
        this.timeFramesAdd(cfg?.timeFrames, DataSource);
        this.timeFrameUse(cfg?.timeFrameInit);
        this.#range = this.buildRange(state);
        this.#stream = new Stream(state.core, state);
        this.historyAdd(cfg?.source);
        let begin = { symbol: this.symbol, tf: this.timeFrameMS };
        this.tickerAdd(cfg?.source?.tickerStream, begin);
    }
    get id() { return this.#id; }
    get cfg() { return this.#cfg; }
    get state() { return this.#state; }
    get source() { return this.#source; }
    get stream() { return this.#stream; }
    get symbol() { return this.#symbol; }
    set timeFrame(t) { this.timeFrameUse(t); }
    get timeFrame() { return this.#timeFrameCurr; }
    get timeFrameMS() { return this.#timeFrameCurr; }
    get timeFrameStr() { return ms2Interval(this.#timeFrameCurr); }
    get timeFrames() { return this.#timeFrames; }
    get range() { return this.#range; }
    sourceSet(s) {
        if (isString(s))
            this.#source.name = s;
        else if (isObject(s))
            this.#source = { ...this.#source, ...s };
        else
            return;
    }
    symbolsAdd(s) {
    }
    symbolSet(s) {
        let symbol = this.#core.config.symbol;
        if ((!isString(s) || (isString(s) && !s.length)) &&
            !symbol.length)
            throwError$1(this.#core.ID, this.#state.key, `symbol invalid`);
        else if (isString(s) && s.length > 0)
            this.#symbol = s;
        else
            this.#symbol = symbol;
    }
    timeFramesAdd(t, d) {
        let tf;
        if (isArrayOfType(t, "integer")) {
            tf = buildTimeFrames(t);
        }
        else if (!isObject(t) || !Object.keys(t).length) {
            tf = d.defaultTimeFrames;
        }
        else {
            tf = buildTimeFrames(Object.values(t));
        }
        this.#timeFrames = { ...tf };
    }
    timeFrameUse(tf) {
        let TF = this.timeFrameValidate(tf);
        if (!TF)
            return;
        this.historyPause();
        this.#timeFrameCurr = TF;
        let matching = this.findMatchingState();
        if (matching instanceof State)
            this.#state.use(matching.key);
        else {
            let newStateDef = {};
            newStateDef.dataSource = doStructuredClone(this.#state.dataSource);
            this.#state.use(newStateDef);
        }
    }
    timeFrameValidate(tf) {
        tf = timeFrame2MS(tf);
        if (!isInteger(tf))
            throwError$1(this.#core.ID, this.#state.key, `time frame invalid`);
        let valid = this.timeFrameExists(tf);
        if (!isInteger(this.#timeFrameCurr))
            tf = detectInterval(this.#state.data.chart.data);
        if (!!valid) {
            if (valid == this.#timeFrameCurr)
                return;
            tf = valid;
        }
        else if (!Object.keys(this.#timeFrames).length) {
            if (tf == this.#timeFrameCurr)
                return;
            let str = ms2Interval(tf);
            this.#timeFrames[str] = tf;
        }
        else
            throwError$1(this.#core.ID, this.#state.key, `time frame invalid`);
        return tf;
    }
    timeFrameExists(tf) {
        if (tf in this.#timeFrames)
            return this.#timeFrames[tf];
        if (isInteger(tf)) {
            let str = ms2Interval(tf);
            if (str in this.#timeFrames)
                return tf;
        }
        return undefined;
    }
    tickerAdd(t, begin) {
        if (isFunction(t?.start)) {
            let n = 3;
            if (t.start.length !== n)
                consoleError$1(this.#core, this.#state.key, `range_limitPast function requires n parameters`);
            else {
                this.#source.tickerStream.start = t.start;
                if (isObject(begin)) {
                    let { symbol, tf } = { ...begin };
                    this.tickerStart(symbol, tf);
                }
            }
        }
        if (isFunction(t?.stop)) {
            this.#source.tickerStream.stop = t.stop;
        }
        else
            this.#source.tickerStream.stop = () => { this.#core.log(`TradeX-chart: ${this.#core.id} : DataSource : tickerStop() function is undefined`); };
    }
    tickerStart(symbol, tf) {
        tf = timeFrame2MS(tf);
        if (!isString(symbol) ||
            !symbol.length ||
            !isInteger(tf))
            return false;
        if (!this.#symbol || this.#symbol === "empty")
            this.symbolSet(symbol);
        else if (this.#symbol !== "empty" && this.#symbol !== symbol) {
            consoleError$1(this.#core, this.#state.key, `ticker symbol does not match chart symbol`);
            return false;
        }
        if (this.#state.isEmpty) {
            this.timeFrameUse(tf);
        }
        else if (this.#timeFrameCurr !== tf) {
            consoleError$1(this.#core, this.#state.key, `ticker time frame does not match chart time frame`);
            return false;
        }
        let onTick = (t) => { this.#stream.onTick.call(this.#stream, t); };
        this.#stream.start();
        this.#source.tickerStream.start(symbol, tf, onTick);
        return true;
    }
    tickerStop() {
        this.#source.tickerStream.stop();
        this.#stream.stop();
    }
    tickerError() {
    }
    tickerRemove() {
        this.tickerStop();
    }
    historyAdd(h) {
        this.historyRemove();
        let n = 4;
        if (isFunction(h?.rangeLimitPast)) {
            if (h.rangeLimitPast.length !== n)
                consoleError$1(this.#core, this.#state.key, `range_limitPast function requires ${n} parameters`);
            else {
                this.#source.rangeLimitPast = (e) => { return this.onRangeLimit(e, h.rangeLimitPast, e.startTS); };
                this.#core.on("range_limitPast", this.#source.rangeLimitPast, this);
            }
        }
        if (isFunction(h?.rangeLimitFuture)) {
            if (h.rangeLimitFuture.length !== n)
                consoleError$1(this.#core, this.#state.key, `range_limitFuture function requires ${n} parameters`);
            else {
                this.#source.rangeLimitFuture = (e) => {
                    return this.onRangeLimit(e, h.rangeLimitFuture, e.endTS);
                };
                this.#core.on("range_limitFuture", this.#source.rangeLimitFuture, this);
            }
        }
    }
    historyRemove() {
        if (isFunction(this.#source.rangeLimitPast)) {
            this.#core.off("range_limitPast", this.#source.rangeLimitPast, this);
            this.#source.rangeLimitPast = null;
        }
        if (isFunction(this.#source.rangeLimitFuture)) {
            this.#core.off("range_limitFuture", this.#source.rangeLimitFuture, this);
            this.#source.rangeLimitFuture = null;
        }
    }
    historyPause() {
        this.#core.off("range_limitPast", this.#source.rangeLimitPast, this);
        this.#core.off("range_limitFuture", this.#source.rangeLimitFuture, this);
    }
    historyRestart() {
        if (isFunction(this.#source.rangeLimitPast))
            this.#core.on("range_limitPast", this.#source.rangeLimitPast, this);
        if (isFunction(this.#source.rangeLimitFuture))
            this.#core.on("range_limitFuture", this.#source.rangeLimitFuture, this);
    }
    startTickerHistory(s) {
        if (!this.#state.isEmpty) {
            consoleError$1(this.#core, this.#state.key, `startTickerHistory() cannot execute because chart is not empty`);
        }
        if (!isFunction(s?.rangeLimitFuture))
            s.rangeLimitFuture = (e, sym, tf, ts) => { return Promise.resolve({}); };
        const v = {
            rangeLimitPast: "function",
            start: "function",
            stop: "function",
            symbol: "string",
            tf: "integer"
        };
        for (let key of Object.keys(v)) {
            if (key == "tf") {
                s.tf = timeFrame2MS(s.tf);
                if (isInteger(s.tf))
                    continue;
            }
            else if (checkType(v[key], s?.[key])) {
                continue;
            }
            else {
                consoleError$1(this.#core, this.#state.key, `startTickerHistory() ${key} is not of the required type ${v[key]}`);
                return false;
            }
        }
        this.#core.on("stream_candleFirst", () => {
            this.historyAdd({
                rangeLimitPast: s.rangeLimitPast,
                rangeLimitFuture: s.rangeLimitFuture,
            });
        });
        this.tickerAdd({
            start: s.start,
            stop: s.stop
        }, {
            symbol: s.symbol,
            tf: s.tf
        });
    }
    onRangeLimit(e, fn, ts) {
        if (!isFunction(fn) || !this.#state.isActive) {
            this.#waiting = false;
            return;
        }
        if (this.#waiting == true)
            return;
        this.#waiting = true;
        try {
            this.#core.progress.start();
            let p = fn(e, this.#symbol, this.#timeFrameCurr, ts);
            if (isPromise(p)) {
                p.then(d => {
                    if (!isObject(d))
                        consoleError$1(this.#core, this.#state.key, "Price history fetch did not return a Promise that resolved to an Object. Nothing to merge.");
                    this.identifyState();
                    this.#state.mergeData(d, false, true);
                    this.#waiting = false;
                    this.#core.progress.stop();
                })
                    .catch(e => {
                    this.#waiting = false;
                    this.#core.progress.stop();
                    this.#core.error(e);
                });
            }
            else
                consoleError$1(this.#core, this.#state.key, "Price history fetch did not return a Promise");
        }
        catch (e) {
            this.#waiting = false;
            this.#core.progress.stop();
            this.#core.error(e);
        }
    }
    buildRange(instance) {
        let core = instance.core;
        let cfg = core.config.range;
        let state = instance.data;
        let range = state.dataSource.initialRange;
        let tfms = detectInterval(state.chart.data);
        if (tfms === Infinity) {
            let { ms } = isTimeFrame(state.dataSource.timeFrameInit);
            tfms = ms || core.timeFrameMS || DEFAULT_TIMEFRAME;
        }
        if (!state.chart.isEmpty &&
            state.chart.data.length > 1 &&
            this.#timeFrameCurr !== tfms)
            this.#timeFrameCurr = tfms;
        if (!isTimeFrameMS(this.#timeFrameCurr))
            this.#timeFrameCurr = core.timeFrameMS || DEFAULT_TIMEFRAME;
        let config = {
            core,
            state: instance,
            interval: this.#timeFrameCurr || cfg?.timeFrameMS,
            initialCnt: range?.initialCnt || cfg?.initialCnt,
            limitFuture: range?.limitFuture || cfg?.limitFuture,
            limitPast: range?.limitPast || cfg?.limitPast,
            minCandles: range?.minCandles || cfg?.minCandles,
            maxCandles: range?.maxCandles || cfg?.maxCandles,
            yAxisBounds: range?.yAxisBounds || cfg?.yAxisBounds,
        };
        return new Range(range?.start, range?.end, config);
    }
    identifyState() {
        this.#core.log(`${this.state.key} ${this.symbol} ${this.timeFrameStr}`);
    }
    findMatchingState(source = this.#source.name, symbol = this.#symbol, timeFrame = this.#timeFrameCurr) {
        let tf = timeFrame2MS(timeFrame);
        let matching = { symbol: [], timeFrame: [] };
        if (!isString(source) || !isString(symbol) || !isInteger(tf))
            return undefined;
        let list = this.#state.list() || [];
        let ds;
        for (let state of list) {
            ds = state.value.dataSource.source;
            if (ds.source !== this.source)
                continue;
            if (ds.symbol !== this.symbol)
                continue;
            matching.symbol.push(state);
            if (ds.timeFrame === this.timeFrame)
                return state;
            else
                matching.timeFrame.push(state);
        }
        return matching;
    }
}
function consoleError$1(c, k, e) {
    c.error(`TradeX-chart: ${c.id}: State ${k} : DataSource : ${e}`);
}
function throwError$1(id, k, e) {
    throw new Error(`TradeX-chart: ${id} : State ${k} : DataSource : ${e}`);
}
function buildTimeFrames(t) {
    let tf = {};
    let str;
    for (let ms of t) {
        if (!isTimeFrameMS(ms))
            continue;
        str = ms2Interval(ms);
        tf[str] = [ms, str];
    }
    return tf;
}
function timeFrame2MS(tf) {
    if (isString(tf) && !isInteger(tf * 1)) {
        tf = interval2MS(tf);
    }
    return tf * 1;
}

var _a;
const DEFAULT_SET = {
    version: version,
    id: "",
    key: "",
    overlays: {},
    indicators: {},
    tools: {},
    markers: {}
};
class OverlaySet {
    static #setList = new xMap;
    static get default() { return doStructuredClone(DEFAULT_SET); }
    static server(chart) {
        if (!isChart(chart))
            return undefined;
        let sets = new xMap();
        if (!_a.#setList.has(chart.key)) {
            _a.#setList.set(chart.key, { chart, sets, active: undefined });
        }
    }
    static setList(chart) {
        if (!isChart(chart))
            return undefined;
        else if (_a.#setList.has(chart.key))
            return _a.#setList.get(chart.key);
        else
            return undefined;
    }
    static create(chart, state, set) {
        const instance = new _a(chart, state);
        const key = instance.key;
        let server = _a.#setList.get(chart.key);
        if (!server) {
            _a.server(chart);
            server = _a.#setList.get(chart.key);
            server.active = instance;
        }
        server.sets.set(key, instance);
        return instance;
    }
    static active(chart) {
        return _a.setList(chart)?.active;
    }
    static list(chart) {
        let sets = _a.setList(chart)?.sets;
        if (!sets)
            return undefined;
        return Array.from(sets, ([key, value]) => ({ key, value }));
    }
    static use(chart, set = _a.default) {
        let key = (_a.has(chart, set)) ? set :
            (_a.has(chart, set?.key)) ? set.key : set;
        if (!isString(key) && isObject(set) && !!Object.keys(set).length) {
            key = hashKey(set);
            if (!_a.has(chart, key)) {
                key = _a.create(chart, set).key;
            }
        }
        else if (!isString(key) && !isObject(set))
            return undefined;
    }
    static delete(chart, set) {
        let sets = _a.setList(chart)?.sets;
        if (!sets)
            return undefined;
        let key = set;
        if (set instanceof _a)
            key = set.key;
        if (!isString(key) ||
            !sets.has(key))
            return false;
        sets.delete(key);
        return true;
    }
    static has(chart, key) {
        return _a.setList(chart)?.sets?.has(key);
    }
    static get(chart, key) {
        return _a.setList(chart)?.sets?.get(key);
    }
    static getKey(chart, target) {
        let key = target;
        if (isObject(target) && Object.keys(target).length < 3) {
            if (isString(target?.id)) {
                key = _a.findSetById(chart, target.id) || target?.key;
            }
            else if (isString(target?.key))
                key = target?.key;
            else
                key = undefined;
        }
        else if (!isString(target))
            key = undefined;
        return key;
    }
    static findSetById(chart, id) {
        let sets = _a.setList(chart)?.sets;
        if (!sets)
            return undefined;
        for (let s of sets) {
            if (s[1].id == id)
                return s[1].key;
        }
        return undefined;
    }
    static isValidConfig(config) {
        if (!isObject(config) ||
            !Object.keys(config).length)
            return false;
        else {
            for (let [key, type] of Object.entries(config)) {
                if (key in DEFAULT_SET &&
                    typeof config[key] !== typeof DEFAULT_SET[key])
                    return false;
            }
            return true;
        }
    }
    static validate(instance) {
        doStructuredClone(_a.default);
    }
    static chartOverlaySet(chart) {
        if (!isChart(chart))
            return {};
        for (let [key, value] of chart.ChartPanes) {
        }
    }
    #core;
    #state;
    #data = _a.default;
    constructor(core, state, set) {
        if (!(core instanceof TradeXchart))
            throwError(`requires a valid chart instance`);
        if (!(state instanceof State))
            throwError(`requires a valid State instance`);
        this.#core = core;
        this.#state = state;
        this.#data.indicators = core.Indicators;
    }
    get core() { return this.#core; }
    get state() { return this.#state; }
    get key() { return this.#data.key; }
}
_a = OverlaySet;
function throwError(id, e) {
    throw new Error(`TradeX-chart: ${id} : Overlay Set : ${e}`);
}

const HASHKEY = "state";
const DEFAULTSTATEID = "defaultState";
const EMPTYCHART = "Empty Chart";
const DEFAULT_STATE = {
    version: version,
    id: DEFAULTSTATEID,
    key: "",
    status: "default",
    isEmpty: true,
    dataSource: {
        source: {
            name: "",
            rangeLimitPast: null,
            rangeLimitFuture: null,
            tickerStream: {
                start: null,
                stop: null,
                tfCountDown: true,
                alerts: []
            }
        },
        symbol: EMPTYCHART,
        symbols: {},
        timeFrameInit: DEFAULT_TIMEFRAMEMS,
        timeFrames: {},
        initialRange: {
            startTS: undefined,
            initialCnt: INTITIALCNT,
            limitFuture: LIMITFUTURE,
            limitPast: LIMITPAST,
            minCandles: MINCANDLES,
            maxCandles: MAXCANDLES,
            yAxisBounds: YAXIS_BOUNDS
        }
    },
    allData: {},
    chart: {
        name: "Primary",
        type: "candles",
        candleType: "CANDLE_SOLID",
        indexed: false,
        data: [],
        settings: {},
    },
    ohlcv: [],
    inventory: [],
    primary: [],
    secondary: [],
    datasets: [],
    tools: {
        display: true,
        data: {
            ts: {}
        }
    },
    trades: {
        display: true,
        displayInfo: true,
        data: {
            ts: {}
        }
    },
    events: {
        display: true,
        displayInfo: true,
        data: {
            ts: {}
        }
    },
    annotations: {
        display: true,
        displayInfo: true,
        data: {
            ts: {}
        }
    },
};
const TRADE = {
    timestamp: "timestamp",
    id: "string",
    side: "string",
    price: "number",
    amount: "number",
    filled: "number",
    average: "number",
    total: "number",
    tag: "string",
};
const EVENT = {
    timestamp: "timestamp",
    id: "string",
    title: "string",
    content: "string",
    url: "string",
};
const ANNOTATIONS = {
    timestamp: "timestamp",
    id: "string",
    title: "string",
    content: "string",
};
const TOOLS = {
    timestamp: "timestamp",
    id: "string",
    type: "string",
    nodes: "array",
};
const validator = {
    trades: TRADE,
    events: EVENT,
    annotations: ANNOTATIONS,
    tools: TOOLS
};
class State {
    static #chartList = new xMap();
    static #dss = {};
    static get default() { return doStructuredClone(DEFAULT_STATE); }
    static server(chart) {
        if (!isChart(chart))
            return undefined;
        let states = new xMap();
        if (!State.#chartList.has(chart.key)) {
            State.#chartList.set(chart.key, { chart, states, active: undefined });
        }
    }
    static chartList(chart) {
        if (!isChart(chart))
            return undefined;
        else if (State.#chartList.has(chart.key))
            return State.#chartList.get(chart.key);
        else
            return undefined;
    }
    static create(chart, state = State.default, deepValidate = false, isCrypto = false) {
        if (!isChart(chart))
            return undefined;
        state.core = chart;
        const instance = new State(state, deepValidate, isCrypto);
        const key = instance.key;
        let server = State.#chartList.get(chart.key);
        if (!server) {
            State.server(chart);
            server = State.#chartList.get(chart.key);
            server.active = instance;
        }
        server.states.set(key, instance);
        return instance;
    }
    static active(chart) {
        return State.chartList(chart)?.active;
    }
    static list(chart) {
        let states = State.chartList(chart)?.states;
        if (!states)
            return undefined;
        return Array.from(states, ([key, value]) => ({ key, value }));
    }
    static use(chart, state = State.default, inherit) {
        let key = State.determineKey(chart, state);
        if (!key)
            return;
        const states = State.#chartList.get(chart.key);
        let previous = states.active;
        let active = states.active;
        let target = states.states.get(key);
        if (!target) {
            chart.log(`${chart.name} id: ${chart.key} : State ${key} does not exist`);
            return undefined;
        }
        if (key != active?.key) {
            states.previous = { state: active, node: "" };
            active = target;
        }
        if (inherit) {
            State.inheritChartPanesInventory(active, previous);
        }
        if (isObject(active?.archive))
            State.unarchiveInventory(active);
        states.active = active;
        return active;
    }
    static determineKey(chart, state) {
        let key = (State.has(chart, state)) ? state :
            (State.has(chart, state?.key)) ? state.key : state;
        if (!isString(key) &&
            isObject(state) &&
            !!Object.keys(state).length) {
            key = hashKey(state);
            if (!State.has(chart, key))
                key = State.create(chart, state).key;
        }
        else if (!isString(key) &&
            !isObject(state))
            return undefined;
        return key;
    }
    static archive(chart, id) {
        let state = State.findStateById(chart, id);
        if (!state)
            return false;
    }
    static unarchiveInventory(active) {
        let archive = (isString(active?.archive?.data)) ?
            active?.archive.data :
            "";
        let archiveData = (!!active.archive?.compress) ?
            LZW.decompress(archive) :
            archive;
        let oldState = JSON.parse(archiveData);
        delete active.archive;
        State.parseChartPanesInventory(oldState);
        active.allData.primaryPane = oldState.primary;
        active.allData.secondaryPane = oldState.secondary;
        active.data.inventory = oldState.inventory;
    }
    static findStateById(chart, id) {
        let states = State.chartList(chart)?.states;
        if (!states)
            return undefined;
        for (let s of states) {
            if (s[1].id == id)
                return s[1].key;
        }
        return undefined;
    }
    static isValidConfig(config) {
        if (!isObject(config) ||
            !Object.keys(config).length)
            return false;
        else {
            for (let [key, type] of Object.entries(config)) {
                if (key in DEFAULT_STATE &&
                    typeof config[key] !== typeof DEFAULT_STATE[key])
                    return false;
            }
            return true;
        }
    }
    static validate(instance, source = State.default, deepValidate = false, isCrypto = false) {
        const defaultState = doStructuredClone(State.default);
        let state;
        if (!isObject(source))
            source = defaultState;
        if (!(source.core instanceof TradeXchart))
            throw new Error(`State : invalid TradeXchart instance`);
        if (!isObject(source.dataSource)) {
            source.dataSource = defaultState.dataSource;
            source.dataSource.symbol = source.core.config?.symbol || `undefined`;
        }
        if (!isString(source.dataSource.symbol) ||
            !source.dataSource.symbol.length ||
            source.dataSource.symbol == EMPTYCHART) {
            source.dataSource.symbol = source.core.config?.symbol || `undefined`;
        }
        if (!isObject(source.chart)) {
            source.chart = defaultState.chart;
            source.chart.data = (isArray(source?.ohlcv)) ? source.ohlcv : [];
            source.isEmpty = true;
            source.status = "default";
            delete source?.ohlcv;
        }
        state = mergeDeep(defaultState, source);
        if (deepValidate)
            state.chart.data = validateDeep(state.chart.data, isCrypto) ? state.chart.data : [];
        else
            state.chart.data = validateShallow(state.chart.data, isCrypto) ? state.chart.data : [];
        state.chart.isEmpty = (state.chart.data.length == 0) ? true : false;
        Object.defineProperty(state.allData, "data", {
            get: function () { return state.chart.data; }
        });
        if (!isObject(state.chart.settings)) {
            state.chart.settings = defaultState.chart.settings;
        }
        if (!isArray(state.inventory)) {
            state.inventory = defaultState.inventory;
        }
        if (!isArray(state.primary)) {
            state.primary = defaultState.primary;
        }
        state.allData.primaryPane = state.primary;
        if (!isArray(state.secondary)) {
            state.secondary = defaultState.secondary;
        }
        state.allData.secondaryPane = state.secondaryPane;
        if (!isArray(state.datasets)) {
            state.datasets = [];
        }
        state.allData.datasets = state.datasets;
        State.parseChartPanesInventory(state);
        State.validateData("trades", state);
        state.trades = state.allData.trades;
        State.validateData("events", state);
        state.events = state.allData.events;
        State.validateData("annotations", state);
        state.annotations = state.allData.annotations;
        State.validateData("tools", state);
        state.tools = state.allData.tools;
        for (var ds of state.datasets) {
            if (!this.#dss)
                this.#dss = {};
            this.#dss[ds.id] = new Dataset(this, ds);
        }
        return state;
    }
    static delete(chart, state) {
        let states = State.chartList(chart)?.states;
        if (!states)
            return undefined;
        let key = state;
        if (state instanceof State)
            key = state.#key;
        if (!isString(key) ||
            !states.has(key))
            return false;
        states.delete(key);
        return true;
    }
    static has(chart, key) {
        return State.chartList(chart)?.states?.has(key);
    }
    static get(chart, key) {
        return State.chartList(chart)?.states?.get(key);
    }
    static getKey(chart, target) {
        let key = target;
        if (isObject(target) && Object.keys(target).length < 3) {
            if (isString(target?.id)) {
                key = State.findStateById(chart, target.id) || target?.key;
            }
            else if (isString(target?.key))
                key = target?.key;
            else
                key = undefined;
        }
        else if (!isString(target))
            key = undefined;
        return key;
    }
    static setTimeFrame(chart, key, ohlcv) {
        let state = State.get(chart, key);
        let timeFrame = undefined;
        if (!state)
            return false;
        if (state.isEmpty && isArray(ohlcv) && ohlcv.length > 1) {
            timeFrame = detectInterval(ohlcv);
            state.range.interval = timeFrame;
            state.range.intervalStr = ms2Interval(timeFrame);
            if (chart?.stream instanceof Stream)
                chart.stream.resetLastPos();
            chart.emit("range_timeframeSet", state.range.intervalStr);
        }
        return timeFrame;
    }
    static ohlcv(data) {
        if (!isArray(data))
            return false;
        let ohlcv = {
            time: [],
            open: [],
            high: [],
            low: [],
            close: [],
            volume: []
        };
        let start = 0, end = data.length;
        while (end != 0 && start < end) {
            let val = data[start];
            ohlcv.time.push(val[OHLCV.t]);
            ohlcv.open.push(val[OHLCV.o]);
            ohlcv.high.push(val[OHLCV.h]);
            ohlcv.low.push(val[OHLCV.l]);
            ohlcv.close.push(val[OHLCV.c]);
            ohlcv.volume.push(val[OHLCV.v]);
            start++;
        }
        return ohlcv;
    }
    static export(chart, key, config = defaultExportConfig) {
        if (!State.has(chart, key))
            return undefined;
        if (!isObject(config))
            config = defaultExportConfig;
        const state = State.get(chart, key);
        const type = config?.type;
        let stateExport;
        let data = {};
        let exclude = [
            "core", "inventory", "range", "timeData"
        ];
        for (let d in state.data) {
            if (exclude.includes(d))
                continue;
            data[d] = doStructuredClone(state.data[d]);
        }
        let vals = data.chart.data;
        if (vals.length > 0 &&
            vals[vals.length - 1].length > 6)
            vals.length = vals.length - 1;
        data.inventory = (isArray(data.inventory)) ? Array.from(data.inventory) : [];
        data.version = version;
        data.key = state.key;
        data.range = state.range.export();
        let { indexed, timeFrame, timeFrameMS, timeZone, timeZoneOffset } = { ...state.data.timeData };
        data.timeData = { indexed, timeFrame, timeFrameMS, timeZone, timeZoneOffset };
        switch (type) {
            case "json":
            default:
                const { replacer, space } = { ...config };
                stateExport = JSON.stringify(data, replacer, space);
                if (!!config?.compress)
                    stateExport = LZW.compress(stateExport);
        }
        return stateExport;
    }
    static asyncExport(chart, key, config = {}) {
        return new Promise((resolve, reject) => {
            try {
                resolve(State.export(chart, key, config));
            }
            catch (e) {
                chart.error(e);
                reject();
            }
        });
    }
    static validateData(type, state) {
        if (!isString(type) ||
            !(type in validator) ||
            !isObject(state))
            throw new Error(`ERROR: State: validateData: ${type} unexpected data`);
        if (!isObject(state[type]))
            state[type] = doStructuredClone(DEFAULT_STATE[type]);
        state[type].display = !!state[type]?.display;
        state[type].displayInfo = !!state[type]?.displayInfo;
        if (!isObject(state[type].data))
            state[type].data = doStructuredClone(DEFAULT_STATE[type].data);
        else {
            let tradeData = state[type].data;
            let allData = state?.data?.allData || state.allData;
            let { tf } = isTimeFrame(state.dataSource.timeFrameInit);
            State.importData(type, tradeData, allData, tf);
        }
    }
    static archiveChartPanesInventory(state) {
        state.data.inventory.length = 0;
        if (!(state.core.ChartPanes instanceof xMap))
            return;
        for (let [key, pane] of state.core.ChartPanes) {
            let snapshot = pane.snapshot();
            let entry = [
                (snapshot.isPrimary) ? "primary" : "secondary",
                Object.values(snapshot.indicators),
                snapshot
            ];
            state.data.inventory.push(entry);
        }
    }
    static inheritChartPanesInventory(active, previous) {
        let matchedTF = isMatchingSymbolTF(active, previous);
        let { activeInventory, previousInventory, matchedInventory } = chartPanesActivePreviousMatched(active, previous, matchedTF);
        if (!matchedInventory?.length)
            return;
        active.data.inventory = matchedInventory;
        let start = active.range.indexStart;
        let end = start + previous.range.Length;
        let max = previous.range.maxCandles;
        active.range.set(start, end, max);
    }
    static parseChartPanesInventory(state) {
        validateInventory(state);
        validateInventoryChartPanes(state);
        validateInventoryPrimaryPane(state);
    }
    static importAnnotations(data, state, tf) {
        State.importData("annotations", data, state, tf);
    }
    static importEvents(data, state, tf) {
        State.importData("events", data, state, tf);
    }
    static importTrades(data, state, tf) {
        State.importData("trades", data, state, tf);
    }
    static importTools(data, state, tf) {
        State.importData("tools", data, state, tf);
    }
    static importData(type, data, state, tf) {
        if (!(type in validator))
            return false;
        if (!isObject(state?.[type]))
            state[type] = doStructuredClone(DEFAULT_STATE[type]);
        let d = state[type].data;
        if (!isObject(d?.[tf]))
            d[tf] = {};
        if (!isObject(data))
            return false;
        for (let ts in data) {
            if (isValidTimestamp(ts * 1) &&
                isArray(data[ts])) {
                for (let t of data[ts]) {
                    if (t?.id)
                        t.id = `${t.id}`;
                    if (State.isValidEntry(t, validator[type])) {
                        if (!isObject(d?.[tf]))
                            d[tf] = {};
                        if (!isArray(d[tf]?.[ts]))
                            d[tf][ts] = [];
                        d[tf][ts].push(t);
                    }
                }
            }
            else {
                d[ts] = data[ts];
            }
        }
        return true;
    }
    static isValidEntry(target, types) {
        return isObjectOfTypes(target, types);
    }
    #id = "";
    #key = "";
    #data = {};
    #gaps;
    #status = false;
    #timeData;
    #dataSource;
    #overlaySet;
    #core;
    #chartPanes = new xMap();
    #chartPaneMaximized = {
        instance: null,
        rowsH: 0,
        panes: {}
    };
    constructor(state = State.default, deepValidate = false, isCrypto = false) {
        if (!(state?.core instanceof TradeXchart))
            throw new Error(`State : invalid TradeXchart instance`);
        this.legacy(state);
        this.#core = state.core;
        this.#data = State.validate(this, state, deepValidate, isCrypto);
        this.#dataSource = DataSource.create(this.#data.dataSource, this);
        this.#data.timeData = new TimeData(this.#dataSource.range);
        this.#data.chart.ohlcv = State.ohlcv(this.#data.chart.data);
        this.#gaps = new Gaps(this);
        this.#key = hashKey(state);
    }
    get id() { return this.#id; }
    get key() { return this.#key; }
    get status() { return this.#data.status; }
    get isEmpty() { return !this.#data.chart.data.length; }
    get isActive() { return this.#key === State.active(this.#core).key; }
    get hasGaps() { return this.#gaps.hasGaps; }
    get core() { return (this.#core !== undefined) ? this.#core : false; }
    get data() { return this.#data; }
    get gaps() { return this.#gaps; }
    get time() { return this.#data.timeData; }
    get range() { return this.#dataSource.range; }
    get symbol() { return this.#dataSource.symbol; }
    set timeFrame(t) { this.#dataSource.timeFrame(t); }
    get timeFrame() { return this.#dataSource.timeFrame; }
    get timeFrameStr() { return this.#dataSource.timeFrameStr; }
    get timeFrames() { return this.#dataSource.timeFrames; }
    get chartPanes() { return this.#chartPanes; }
    get chartPaneMaximized() { return this.#chartPaneMaximized; }
    get dataSource() { return this.#dataSource; }
    get allData() {
        return {
            data: this.#data.chart.data,
            ohlcv: this.#data.chart.ohlcv,
            primaryPane: this.#data.primary,
            secondaryPane: this.#data.secondary,
            datasets: this.#data.datasets,
            trades: this.#data.trades.data,
            events: this.#data.events.data,
            annotations: this.#data.annotations.data,
            tools: this.#data.tools.data
        };
    }
    get trades() { return this.#data.trades; }
    get events() { return this.#data.events; }
    get annotations() { return this.#data.annotations; }
    get tools() { return this.#data.tools; }
    get inventory() { return this.#data.inventory; }
    error(e) { this.#core.error(e); }
    legacy(state) {
        if (!isObject(state?.data?.dataSource) && isObject(state?.data?.range)) {
            let ms = state.data.range.timeFrameMS || interval2MS(state.data.range.timeFrame);
            let tf = ms2Interval(ms);
            state.data.dataSource = {
                initialRange: { ...state.data.range },
                timeFrameInit: ms,
                timeFrames: { [`${tf}`]: ms }
            };
        }
    }
    create(state = State.default, deepValidate = true, isCrypto = false) {
        return State.create(state, deepValidate, isCrypto);
    }
    delete(state) {
        let core = this.#core;
        let key;
        if (state instanceof State)
            key = state.key;
        else if (isString(state))
            key = state;
        else if (isObject(state) && isString(state.key))
            key = state.key;
        else if (isObject(state) && isString(state.id) && !!this.getByID(state.id)) {
            key = this.getByID(state.id)?.key;
        }
        else
            core.error(`${core.name} : State.delete() : State not found`);
        if (key !== this.key) {
            if (this.has(key))
                State.delete(core, key);
        }
        else {
            if (this.has(key)) {
                const empty = this.create();
                this.use(empty?.key);
                State.delete(core, key);
            }
            else {
                core.error(`${core.name} : State.use() : State not found`);
                return false;
            }
        }
        return true;
    }
    list() {
        return State.list(this.#core);
    }
    has(key) {
        return State.has(this.#core, key);
    }
    get(key) {
        return State.get(this.#core, key);
    }
    getByID(id) {
        let list = State.list(this.#core);
        if (!list || !isString(id))
            return undefined;
        for (let s of list) {
            if (s.id == id)
                return s;
        }
    }
    use(key) {
        const errMsg = `TradeX-Chart: ${this.#core.ID} : cannot use supplied key or state`;
        if (isString(key) && !State.has(this.#core, key))
            return undefined;
        else if (key === undefined) {
            key = State.default;
        }
        else if (isObject(key) && !State.isValidConfig(key)) {
            this.#core.log(errMsg);
            return undefined;
        }
        if (isFunction(this.#core.MainPane?.init)) {
            if (this.#core.stream instanceof Stream) {
                this.#dataSource?.historyPause();
            }
            State.archiveChartPanesInventory(this);
            this.#core.MainPane.destroy(false);
        }
        if (State.isValidConfig(key)) {
            let source = key?.dataSource?.source?.name;
            let symbol = key?.dataSource?.symbol;
            let timeFrame = key?.dataSource?.timeFrameInit;
            let matching = this.dataSource.findMatchingState(source, symbol, timeFrame);
            if (matching instanceof State)
                key = matching.key;
        }
        let inherit = (!!this.#core.config.stateInheritPrevious) ? this : undefined;
        let state = State.use(this.#core, key, inherit);
        if (isObject(key))
            key.key = state?.key;
        if (isFunction(this.#core.MainPane?.init)) {
            if (this.#core?.stream instanceof Stream)
                this.#core.stream.resetLastPos();
            this.#core.MainPane.init(this.#core.MainPane.options);
            this.#core.MainPane.start();
            this.#core.MainPane.refresh();
            this.#core.progress.stop();
        }
        if (state instanceof State) {
            state.dataSource?.historyRestart();
        }
        else
            this.#core.log(errMsg);
        this.#core.emit(`state_usingState`, state);
        return state;
    }
    hasTimeFrame(tf) {
        return this.#dataSource.timeFrameExists(tf);
    }
    export(key = this.key, config = {}) {
        return State.export(this.#core, key, config = {});
    }
    mergeData(merge, newRange = false, calc = false) {
        if (this.isEmpty)
            State.setTimeFrame(this.#core, this.key, merge?.ohlcv);
        let tfMS = this.#dataSource.timeFrameMS;
        if (!isObject(merge)) {
            consoleError(this.#core, this.#key, `${this.symbol} merge data must be type Object!`);
            return false;
        }
        let end = (isArray(merge?.ohlcv)) ? merge.ohlcv.length - 1 : 0;
        let mergeTF = detectInterval(merge?.ohlcv);
        if (end > 1 && tfMS !== mergeTF) {
            consoleError(this.#core, this.#key, `${this.symbol} merge data time frame ${mergeTF} does not match existing time frame ${tfMS}!`);
            return false;
        }
        if (this.isEmpty || !isNumber(tfMS)) {
            if (!isObject(newRange) ||
                !isInteger(newRange.start) ||
                !isInteger(newRange.end)) {
                if (end > 1) {
                    newRange = { start: end - this.range.initialCnt, end };
                }
            }
        }
        if (isObject(newRange)) {
            if (isInteger(newRange?.startTS))
                newRange.start = newRange.startTS;
            else
                newRange.start = (isInteger(newRange.start)) ? this.range.value(newRange.start)[0] : this.range.timeMin;
            if (isInteger(newRange?.endTS))
                newRange.end = newRange.endTS;
            else
                newRange.end = (isInteger(newRange.end)) ? this.range.value(newRange.end)[0] : this.range.timeMax;
        }
        else {
            newRange = {};
            newRange.start = this.range.timeMin;
            newRange.end = this.range.timeMax;
        }
        let i, start;
        let mData = merge?.ohlcv || false;
        const data = this.allData.data;
        const primaryPane = this.allData?.primaryPane;
        const mPrimary = merge?.primary || false;
        const secondaryPane = this.allData?.secondaryPane;
        const mSecondary = merge?.secondary || false;
        const dataset = this.allData?.dataset?.data;
        const mDataset = merge?.dataset?.data || false;
        this.allData?.trades;
        const mTrades = merge?.trades || false;
        this.allData?.events;
        const mEvents = merge?.events || false;
        this.allData?.annotations;
        const mAnnotations = merge?.annotations || false;
        this.allData?.tools;
        const mTools = merge?.tools || false;
        const inc = (!isArray(mData)) ? 0 : (this.range.inRange(mData[0][0])) ? 1 : 0;
        const refresh = {};
        if (isArray(mData) && mData.length > 0) {
            i = mData.length - 1;
            data.length - 1;
            refresh.mData =
                this.range.inRange(mData[0][0]) &&
                    this.range.inRange(mData[0][i]);
            if (!isBoolean(mData[i][7]) &&
                mData[i].length !== 8 &&
                mData[i][6] !== null &&
                mData[i][7] !== true) {
                mData = sanitizeCandles(mData);
            }
            else {
                if (newRange.end >= this.range.timeFinish &&
                    newRange.start <= this.range.timeFinish) {
                    newRange.start += this.range.interval;
                    newRange.end += this.range.interval;
                }
            }
            if (data.length == 0) {
                let ohlcv = State.ohlcv(mData);
                this.allData.data.push(...mData);
                this.allData.ohlcv = { ...ohlcv };
            }
            else {
                let mStart = mData[0][0];
                let mEnd = mData[mData.length - 1][0];
                let mDataMS = (mData.length - 1) * tfMS;
                if (mEnd > mStart + mDataMS)
                    mData = this.#gaps.findFillGaps(mData);
                this.data.chart.data = this.merge(data, mData);
            }
            if (!calc) {
                if (isArray(mPrimary) && mPrimary.length > 0) {
                    for (let o of mPrimary) {
                        if (isArray(o?.data) && o?.data.length > 0) {
                            for (let p of primaryPane) {
                                if (isObject(p) &&
                                    p.name === o.name &&
                                    p.type === o.type &&
                                    isObjectEqual(p.settings, o.settings)) {
                                    p.data = this.merge(p.data, o.data);
                                    this.#core.getIndicator(p.id).drawOnUpdate = true;
                                }
                            }
                        }
                    }
                }
                if (isArray(mSecondary) && mSecondary.length > 0) {
                    for (let o of mSecondary) {
                        if (isArray(o?.data) && o?.data.length > 0) {
                            for (let p of secondaryPane) {
                                if (isObject(p) &&
                                    p.name === o.name &&
                                    p.type === o.type &&
                                    isObjectEqual(p.settings, o.settings)) {
                                    p.data = this.merge(p.data, o.data);
                                    this.#core.getIndicator(p.id).drawOnUpdate = true;
                                }
                            }
                        }
                    }
                }
            }
            let mStart = mData[0][0];
            let mEnd = mData[mData.length - 1][0];
            let filled = this.#gaps.removeFilledGaps(mStart, mEnd);
            this.#core.calcAllIndicators(filled);
            if (isArray(mDataset) && mDataset.length > 0) {
                for (let o of mDataset) {
                    if (isArray(o?.data) && o?.data.length > 0) {
                        for (let p of dataset) {
                            if (p.name === o.name &&
                                p.type === o.type &&
                                isObjectEqual(p.settings, o.settings)) {
                                p.data = this.merge(p.data, o.data);
                            }
                        }
                    }
                }
            }
            if (isObject(mAnnotations)) {
                State.importEvents(mAnnotations, this.allData, this.time.timeFrame);
            }
            if (isObject(mEvents)) {
                State.importEvents(mEvents, this.allData, this.time.timeFrame);
            }
            if (isObject(mTrades)) {
                State.importTrades(mTrades, this.allData, this.time.timeFrame);
            }
            if (isObject(mTools)) {
                State.importTools(mTools, this.allData, this.time.timeFrame);
            }
            if (newRange) {
                if (isObject(newRange)) {
                    start = (isInteger(newRange.start)) ? this.range.getTimeIndex(newRange.start) : this.range.indexStart;
                    end = (isInteger(newRange.end)) ? this.range.getTimeIndex(newRange.end) : this.range.indexEnd;
                }
                else {
                    if (mData[0][0])
                        start = this.range.indexStart + inc;
                    end = this.range.indexEnd + inc;
                }
                this.#core.setRange(start, end);
            }
            let r, u = false;
            for (r in refresh) {
                u = u || r;
            }
            if (merge.ohlcv.length > 1)
                this.#core.emit("state_mergeComplete");
            if (u)
                this.#core.refresh();
            this.#data.isEmpty = false;
            return true;
        }
    }
    merge(data, mData) {
        let merged = [];
        let older, newer;
        if (data[0][0] < mData[0][0]) {
            older = data;
            newer = mData;
        }
        else {
            older = mData;
            newer = data;
        }
        if (newer.length == 1 &&
            newer[0][0] == older[older.length - 1][0]) {
            older[older.length - 1] = newer[0];
            merged = older;
        }
        else if (newer.length == 1 &&
            newer[0][0] == older[older.length - 1][0] + this.range.interval) {
            merged = older.concat(newer);
        }
        else if (older[older.length - 1][0] >= newer[0][0]) {
            let o = 0;
            while (older[o][0] < newer[0][0]) {
                merged.push(older[o]);
                o++;
            }
            merged = merged.concat(newer);
            let i = o + newer.length;
            if (i < older.length) {
                merged = merged.concat(older.slice(i));
            }
        }
        else if (newer[0][0] - older[older.length - 1][0] > this.range.interval) {
            merged = this.#gaps.nullFillGapsOnMerge(newer, older);
            merged = merged.concat(newer);
        }
        else {
            merged = older.concat(newer);
        }
        return merged;
    }
    addIndicator(i, p) {
        if (isObject(i) && p == "primary") {
            i.params.overlay.id = i.instance.id;
            this.#data.primary.push(i.params.overlay);
        }
        else if (i instanceof Chart && p == "secondary") {
            this.#data.secondary.push(...i.options.view);
            this.range.maxMinDatasets();
        }
        else
            return false;
    }
    removeIndicator(i) {
        if (!isString(i))
            return false;
        const seekAndDestroy = (p, i) => {
            const a = this.data[p];
            for (let d = 0; d < a.length; d++) {
                if (a[d].id == i) {
                    a.splice(d, 1);
                    this.range.maxMinDatasets();
                    return true;
                }
            }
            return false;
        };
        if (seekAndDestroy("primary", i))
            return true;
        if (seekAndDestroy("secondary", i))
            return true;
        return false;
    }
    addTrade(t) {
        if (!State.isValidEntry(t, TRADE))
            return false;
        const ts = t.timestamp - (t.timestamp % tfMS);
        const d = new Date(ts);
        t.dateStr = `${d.getFullYear()}/${d.getMonth() + 1}/${d.getDate()} ${d.getHours()}:${d.getMinutes()}`;
        this.allData.trades.data.ts[t.timestamp] = t;
        this.allData.trades.data[tf][ts] = t;
        this.#core.emit("state_tradeAdded", t);
        this.#core.emit("trade_added", t);
        return true;
    }
    removeTrade(t) {
        console.log("TODO: state.removeTrade()");
    }
    addEvent(e) {
        if (!State.isValidEntry(e, EVENT))
            return false;
        const ts = t.timestamp - (e.timestamp % tfMS);
        const d = new Date(ts);
        e.dateStr = `${d.getFullYear()}/${d.getMonth() + 1}/${d.getDate()} ${d.getHours()}:${d.getMinutes()}`;
        this.allData.events.data.ts[e.timestamp] = e;
        this.allData.events.data[tf][ts] = e;
        this.#core.emit("state_eventAdded", e);
        this.#core.emit("event_added", e);
        return true;
    }
    removeEvent(e) {
        console.log("TODO: state.removeEvent()");
    }
    buildInventory() {
        return State.buildInventory(this);
    }
}
function hashKey(state) {
    let str = JSON.stringify(state);
    let hash = cyrb53(str);
    return `${SHORTNAME}_${HASHKEY}_${hash}`;
}
function isMatchingSymbolTF(active, previous) {
    return (active.timeFrame === previous.timeFrame &&
        active.symbol === previous.symbol);
}
function validateInventoryChartPanes(state) {
    let o = state.inventory;
    let c = o.length;
    while (c--) {
        if (!isArray(o[c]) || o[c].length == 0)
            o.splice(c, 1);
        else
            validateInventoryOverlays(state, c);
    }
}
function validateInventoryPrimaryPane(state) {
    let cnt = 0;
    state.inventory.forEach((v, i) => {
        if (v[0] == "primary") {
            if (++cnt > 1)
                state.inventory.splice(i, 1);
        }
    });
    if (!cnt) {
        let defaultState = doStructuredClone(State.default);
        state.inventory.push(["primary", defaultState.primary]);
    }
}
function validateInventoryOverlays(state, c) {
    let o = state.inventory;
    let i = state.inventory[c]?.[1] || [];
    let x = i.length;
    while (x--) {
        if (!isInventoryOverlayValid(i[x], state.core))
            i.splice(x, 1);
        else if (!isObject(i[x].settings))
            i[x].settings = {};
    }
    if (o[c].length == 0)
        o.splice(c, 1);
}
function isInventoryOverlayValid(o, core) {
    const overlayObjectDef = {
        name: "string",
        type: "string"
    };
    return (isObjectOfTypes(o, overlayObjectDef) &&
        (o.type in core.indicatorClasses ||
            o.type in core.overlayEntries()));
}
function validateInventory(state) {
    if (!isArray(state.inventory) || state.inventory.length == 0) {
        state.inventory.push(["primary", state.primary]);
        let secondary = (isArray(state?.secondary)) ? state.secondary : [];
        for (let s of secondary) {
            if (isObject(s) || isArrayOfType(s, "object")) {
                state.inventory.push(["secondary", s]);
            }
        }
    }
}
function findMatchingChartPane(source, target, isPrimary, assetMatch) {
    let pane, search;
    for (pane of target) {
        search = matchedInventoryIndicators(source, pane);
        if (search.matched.length)
            return pane;
    }
}
function chartPanesActivePreviousMatched(active, previous, matchedTF) {
    let previousInventory = previous.inventory;
    if (!isArray(previousInventory) ||
        !previousInventory.length)
        return {};
    let activeInventory = [];
    let matchedInventory = [];
    let entry, result, search;
    if (isArray(active.inventory)) {
        activeInventory = active.inventory;
    }
    previousInventory.forEach((i, j) => {
        search = findMatchingChartPane(i[1], activeInventory);
        result = (!!search) ? search : i;
        result[2] = i[2];
        if (matchedTF)
            entry = result;
        else {
            entry = doStructuredClone(result);
            entry[1] = (isObject(entry[1])) ? [entry[1]] : entry[1];
            for (let indicator of entry[1]) {
                indicator.data = [];
                delete indicator.id;
                delete indicator.key;
            }
        }
        matchedInventory.push(entry);
    });
    return {
        activeInventory,
        previousInventory,
        matchedInventory
    };
}
function matchedInventoryIndicators(source, target) {
    let matched = [];
    let noMatch = [];
    for (let s of source) {
        for (let t of target) {
            if (matchInventoryIndicator(s, t))
                matched.push(s);
            else
                noMatch.push(t);
        }
    }
    return { matched, noMatch };
}
function matchInventoryIndicator(source, target) {
    let type = source.type == target.type;
    let settings = isObjectEqual(source.settings, target?.settings);
    return type || settings;
}
function consoleError(c, k, e) {
    c.error(`TradeX-chart id: ${c.id}: State ${k} : ${e}`);
}
const defaultExportConfig = {
    type: "json",
    compress: true
};

const reserved = ["constructor", "list", "setCurrent", "setTheme", "setValue"];
class Theme {
    static #list = new xMap();
    static get list() { return Theme.#list; }
    #core;
    static create(theme, core) {
        if (!(isObject(theme)))
            return false;
        theme.id = (isString(theme.name)) ? uid(theme.name) : uid(`${core.ID}_theme`);
        const instance = new Theme(theme, core);
        Theme.list.set(theme.id, instance);
        return instance;
    }
    constructor(theme, core) {
        this.#core = core;
        this.setCurrent(theme);
    }
    get list() { return Theme.list; }
    setCurrent(theme = {}) {
        theme = (isObject(theme)) ? theme : {};
        const defaultT = doStructuredClone(defaultTheme);
        const newTheme = doStructuredClone(theme);
        const setTheme = mergeDeep(defaultT, newTheme);
        for (let t in setTheme) {
            if (reserved.includes(t))
                continue;
            this[t] = setTheme[t];
        }
        this.#core.refresh();
    }
    setTheme(theme) {
        if (isString(theme) && Theme.list.has(theme)) {
            const t = Theme.list.get(theme);
            this.setCurrent(t);
            return true;
        }
        return false;
    }
    setProperty(path, value) {
        if (!isString(path))
            return undefined;
        const old = getProperty(this, path);
        const keys = path.split(".");
        if (keys.length == 1) {
            this[keys[0]] = value;
        }
        else if (keys.length > 1) {
            let k = keys.shift();
            switch (k) {
                case "tools": console.log("theme set tools");
                case "utils": console.log("theme set utils");
                default:
                    this[k] = setProperty(this[k], keys.join('.'), value);
            }
        }
        this.#core.refresh();
        return old;
    }
    getProperty(path) {
        return getProperty(this, path);
    }
    deleteTheme(theme) {
        if (isString(theme) && Theme.list.has(theme)) {
            Theme.list.delete(theme);
            return true;
        }
        return false;
    }
    exportTheme(config = {}) {
        if (!isObject)
            config = {};
        const type = config?.type;
        const data = {};
        let themeExport;
        for (let t in this) {
            if (reserved.includes(t))
                continue;
            data[t] = this[t];
        }
        switch (type) {
            case "json":
            default:
                const { replacer, space } = { ...config };
                themeExport = JSON.stringify(data, replacer, space);
        }
        return themeExport;
    }
}

class ThreadWorker {
    #fn;
    constructor(fn) {
        this.#fn = fn;
        self.onmessage = m => this._onmessage(m.data);
    }
    _onmessage(m) {
        const { r, data } = m;
        try {
            const result = this.#fn(data, r);
            self.postMessage({ r, status: true, result });
        }
        catch (e) {
            self.postMessage({ r, status: false, result: e });
        }
    }
    end() {
        self.close();
    }
}
class Thread {
    #id;
    #cb;
    #err;
    #req = 0;
    #reqList = {};
    #worker;
    #idle = true;
    constructor(id, fn, cb, err) {
        this.#id = id;
        this.#cb = cb;
        this.#err = err;
        const workerFn = `
      ${WebWorker.ThreadWorker.toString()};
      const fn = ${fn}
      const worker = new ThreadWorker(fn)
    `;
        const blob = new Blob([`;(async () => {${workerFn}})().catch(e => {console.error(e)})`], { type: 'text/javascript' });
        const blobURL = URL.createObjectURL(blob);
        this.#worker = new Worker(blobURL);
        setTimeout(function (blobURL) {
            try {
                URL.revokeObjectURL(blobURL);
            }
            catch (e) { }
        }, 500, blobURL);
    }
    get id() { return this.#id; }
    get req() { return `r_${this.#req++}`; }
    get cb() { return this.#cb; }
    set cb(cb) { this.#cb = cb; }
    onMessage(m) {
        this.#idle = true;
        return (isFunction(this.#cb)) ? this.#cb(m) : m;
    }
    onError(e) {
        this.#idle = true;
        return (isFunction(this.#err)) ? this.#err(e) : e;
    }
    postMessage(m) {
        return new Promise((resolve, reject) => {
            try {
                let r = this.req;
                this.#reqList[r] = { resolve, reject };
                this.#idle = false;
                this.#worker.postMessage({ r, data: m });
                this.#worker.onmessage = m => {
                    const { r, status, result } = m.data;
                    if (r in this.#reqList) {
                        const { resolve, reject } = this.#reqList[r];
                        delete this.#reqList[r];
                        if (status) {
                            resolve(this.onMessage(result));
                        }
                        else {
                            reject(this.onError({ r, result }));
                        }
                    }
                    else if (status == "resolved")
                        this.onMessage(result);
                    else
                        throw new Error(`Orphaned thread request ${r}`);
                };
                this.#worker.onerror = e => {
                    reject(this.onError(e));
                };
            }
            catch (error) {
                this.#idle = true;
                reject(error);
            }
        });
    }
    terminate() {
        this.#worker.terminate();
    }
}
class WebWorker {
    static #threads = new Map();
    static { this.ThreadWorker = ThreadWorker; }
    static { this.Thread = Thread; }
    static create(worker, ID = "worker", cb, err) {
        if (typeof window.Worker === "undefined")
            return false;
        if (isFunction(worker)) {
            worker = worker.toString();
        }
        else if (isString(worker)) {
            let fnStr = worker.trim().match(/^function\s*\w*\s*\([\w\s,]*\)\s*{([\w\W]*?)}$/)[1];
            worker = fnStr;
        }
        else {
            return false;
        }
        ID = (isString(ID)) ? uid(ID) : uid("worker");
        this.#threads.set(ID, new this.Thread(ID, worker, cb, err));
        return this.#threads.get(ID);
    }
    static destroy(ID) {
        if (!isString(ID))
            return false;
        this.#threads.get(ID).terminate();
        this.#threads.delete(ID);
    }
    static end() {
        this.#threads.forEach((value, key, map) => {
            this.destroy(key);
        });
    }
}
class TaskProcessor {
    static { this.taskList = {}; }
    static add(t) {
        if (!isObject(t)) {
            this.typeError("add()", t, "object");
        }
        if (!isString(t?.id)) {
            this.typeError("add(t.id)", t, "string");
        }
        if (!isString(t?.fn)) {
            this.typeError("add(t.fn)", t, "string");
        }
        try {
            this.taskList[t.id] = new Function(`return ${t.fn}`)();
        }
        catch (error) {
            this.error("add()", `Failed to create function from string`, { cause: error });
        }
    }
    static remove(t) {
        if (!isString(t)) {
            this.typeError("remove()", t, "string");
        }
        if (!(t in this.taskList)) {
            this.error("remove()", `task ${t} not found!`);
        }
        delete this.taskList[t];
    }
    static exec(t) {
        if (!isObject(t)) {
            this.typeError("exec()", t, "object");
        }
        if (!isString(t?.id)) {
            this.typeError("exec(t.id)", t, "string");
        }
        if (!isObject(t?.params)) {
            this.typeError("exec(t.params)", t, "object");
        }
        if (!(t.id in this.taskList)) {
            this.error("exec()", `task ${t.id} not found!`);
        }
        try {
            this.taskList[t.id](...t.params);
        }
        catch (e) {
            this.error("exec()", `task ${t.id} error!`, { cause: e });
        }
    }
    static typeError(fn, t, e) {
        typeError(`TaskProcessor.${fn}`, t, e);
    }
    static error(fn, e, o) {
        error(`TaskProcessor.${fn}`, e, o);
    }
}

class EventHub {
    #hub = {};
    constructor() { }
    on(topic, handler, context) {
        if (!isString(topic) || !isFunction(handler))
            return false;
        if (!this.#hub[topic])
            this.#hub[topic] = [];
        this.#hub[topic].push({ handler, context });
        return true;
    }
    off(topic, handler, context) {
        if (!isString(topic) ||
            !isFunction(handler) ||
            !(topic in this.#hub))
            return false;
        const t = this.#hub[topic];
        for (let i = 0; i < t.length; i++) {
            if (t[i].handler === handler) {
                if (context !== undefined) {
                    if (t[i].context !== context)
                        continue;
                }
                t.splice(i, 1);
                if (t.length === 0) {
                    delete this.#hub[topic];
                    break;
                }
            }
        }
        return true;
    }
    expunge(context) {
        let topic, hub = this.#hub;
        for (topic in hub) {
            for (let i = 0; i < hub[topic].length; i++) {
                if (hub[topic][i].context === context) {
                    hub[topic].splice(i, 1);
                    if (hub[topic].length === 0) {
                        delete hub[topic];
                        break;
                    }
                }
            }
        }
        return true;
    }
    emit(topic, data) {
        if (!isString(topic))
            return false;
        (this.#hub[topic] || []).forEach(cb => {
            try {
                cb.handler.call(cb.context, data);
            }
            catch (e) {
                console.error(e);
                return false;
            }
        });
        return true;
    }
    execute(topic, data, cb) {
    }
}

class element extends HTMLElement {
    static #observedAttr = [];
    static set observedAttributes(a) { if (isArray(a))
        element.#observedAttr = a; }
    static get observedAttributes() { return element.#observedAttr; }
    #shadowRoot;
    #template;
    #hub;
    constructor(template, mode = "open") {
        super();
        this.ID = uid(SHORTNAME);
        this.doInit = true;
        this.DOM = {
            width: 0,
            height: 0,
            style: {}
        };
        this.oldDOM = {};
        this.subscribers = {
            resize: [],
            mutation: [],
            intersection: []
        };
        this.#hub = new EventHub();
        this.#template = template;
        this.#shadowRoot = this.attachShadow({ mode: mode });
    }
    destroy() {
    }
    connectedCallback(fn) {
        if (this.doInit) {
            this.doInit = false;
            this.shadowRoot.appendChild(this.template.content.cloneNode(true));
            this.DOM.width = this.clientWidth;
            this.DOM.height = this.clientHeight;
            this.oldDOM.width = this.clientWidth;
            this.oldDOM.height = this.clientHeight;
            this.intersectionObserver = new IntersectionObserver(this.onResize.bind(this));
            this.intersectionObserver.observe(this);
            this.resizeObserver = new ResizeObserver(this.onResize.bind(this));
            this.resizeObserver.observe(this);
            if (isFunction(fn))
                fn();
        }
    }
    disconnectedCallback() {
        this.resizeObserver.disconnect();
    }
    get shadowRoot() { return this.#shadowRoot; }
    get template() { return this.#template; }
    get hub() { return this.#hub; }
    get width() { return this.DOM.width; }
    set width(w) { this.setDim(w, "width"); }
    get oWidth() { return this.oldDOM.width; }
    get height() { return this.DOM.height; }
    set height(h) { this.setDim(h, "height"); }
    get oHeight() { return this.oldDOM.height; }
    get widthDeltaR() { return this.DOM.width / this.oldDOM.width; }
    get heightDeltaR() { return this.DOM.height / this.oldDOM.height; }
    set top(t) { this.setPos(t, "top"); }
    get top() { return this.DOM.top; }
    set left(l) { this.setPos(l, "left"); }
    get left() { return this.DOM.left; }
    set bottom(b) { this.setPos(b, "bottom"); }
    get bottom() { return this.DOM.bottom; }
    set right(r) { this.setPos(r, "right"); }
    get right() { return this.DOM.right; }
    get dimensions() { return this.DOM; }
    set cursor(c) { this.style.cursor = c; }
    get cursor() { return this.style.cursor; }
    setDim(v, d) {
        if (!["width", "height", "top", "bottom", "left", "right"].includes(d) || !isString(v))
            return;
        if (isNumber(v)) {
            this.DOM[d] = v;
            v += "px";
        }
        else if (isString(v)) {
            if (!v.match(CSSUNITS))
                v = "100%";
        }
        else {
            this.DOM[d] = this.parentElement.getBoundingClientRect()[d];
            v = this.DOM[d] + "px";
        }
        this.style[d] = v;
    }
    setPos(v, d) {
        this.setDim(v, d);
    }
    getDims() {
        const rect = this.getBoundingClientRect();
        for (let k in rect) {
            const v = rect[k];
            if (!isFunction(v))
                this.DOM[k] = v;
        }
        this.DOM.visible = isVisible(this);
        this.DOM.viewport = isInViewport(this);
        return this.DOM;
    }
    onIntersection(i) {
        this.emit("intersection", this);
    }
    onMutation(m) {
        this.emit("mutation", this);
    }
    onResize(r) {
        this.oldDOM = { ...this.DOM };
        this.getDims();
        this.emit("resize", this.DOM);
    }
    on(topic, handler, context = this) {
        if (!(this.#hub instanceof EventHub))
            return false;
        return this.#hub.on(topic, handler, context);
    }
    off(topic, handler, context = this) {
        if (!(this.#hub instanceof EventHub))
            return false;
        return this.#hub.off(topic, handler, context);
    }
    expunge(context) {
        if (!(this.#hub instanceof EventHub))
            return false;
        return this.#hub.expunge(context);
    }
    emit(topic, data) {
        if (!(this.#hub instanceof EventHub))
            return false;
        return this.#hub.emit(topic, data);
    }
}

var stateMachineConfig$1 = {
    id: "template",
    initial: "idle",
    context: {},
    states: {
        idle: {
            onEnter(data) {
                console.log('idle: onEnter');
            },
            onExit(data) {
                console.log('idle: onExit');
            },
            on: {
                tool_activated: {
                    target: 'tool_activated',
                    action(data) {
                        this.context.origin.onToolActivated(data);
                    },
                },
                tool_deactivated: {
                    target: 'tool_deactivated',
                    action(data) {
                        this.context.origin.onTooldeActivated(data);
                    },
                },
                tool_selected: {
                    target: 'tool_selected',
                    action(data) {
                        this.context.origin.onToolSelected(data);
                    },
                },
                tool_deselected: {
                    target: 'tool_deselected',
                    action(data) {
                        this.context.origin.onToolDeselected(data);
                    },
                },
                tool_deleted: {
                    target: 'tool_deleted',
                    action(data) {
                        this.context.origin.onToolDeleted(data);
                    },
                },
            }
        },
        tool_activated: {
            onEnter(data) {
            },
            onExit(data) {
            },
            on: {
                tool_selected: {
                    target: 'tool_selected',
                    action(data) {
                        this.context.origin.onToolTargetSelected(data);
                    },
                },
                tool_deactivated: {
                    target: 'idle',
                    action(data) {
                    }
                }
            }
        },
        tool_deactivated: {
            onEnter(data) {
            },
            onExit(data) {
            },
            on: {
                always: {
                    target: "idle",
                    action(data) {
                    },
                }
            }
        },
        tool_selected: {
            onEnter(data) {
            },
            onExit(data) {
            },
            on: {
                always: {
                    target: 'idle',
                    condition: 'toolTarget',
                    action(data) {
                        this.context.origin.addNewTool();
                    },
                },
            }
        },
        tool_deselected: {
            onEnter(data) {
            },
            onExit(data) {
            },
            on: {
                always: {
                    target: 'idle',
                    condition: 'toolTarget',
                    action(data) {
                    },
                },
            }
        },
        tool_deleted: {
            onEnter(data) {
            },
            onExit(data) {
            },
            on: {
                always: {
                    target: 'idle',
                    condition: 'toolTarget',
                    action(data) {
                    },
                },
            }
        },
    },
    guards: {
        toolTarget() { return true; }
    }
};

class ToolsBar extends Component {
    #name = "Toolbar";
    #shortName = "tools";
    #elTools;
    #widgets;
    #tools;
    #toolClasses = {};
    #activeTool = "";
    #toolTarget;
    #toolsOverlay;
    #toolEvents = { click: [], pointerover: [] };
    #menus = [];
    constructor(core, options) {
        super(core, options);
        this.#elTools = core.elTools;
        this.#tools = tools || core.config.tools;
        this.#widgets = core.WidgetsG;
        this.init();
    }
    get name() { return this.#name; }
    get shortName() { return this.#shortName; }
    get pos() { return this.dimensions; }
    get dimensions() { return elementDimPos(this.#elTools); }
    get tools() { return this.core.Tools; }
    get list() { return this.listTools(); }
    get overlays() { return this.listToolOverlays(); }
    init() {
        this.mount(this.#elTools);
    }
    start() {
        this.initAllToolsGUI();
        this.drawRangeTools();
        this.eventsListen();
        stateMachineConfig$1.id = this.id;
        stateMachineConfig$1.context = this;
        this.stateMachine = stateMachineConfig$1;
        this.stateMachine.start();
        this.log(`Tool Bar ${this.#name} instantiated and running`);
    }
    destroy() {
        this.core.hub.expunge(this);
        const id = this.id;
        const tools = this.#elTools.querySelectorAll(`.icon-wrapper`);
        for (let tool of tools) {
            for (let t of this.#tools) {
                if (t.id === id)
                    tool.removeEventListener("click", this.#toolEvents[id].click);
            }
        }
        this.stateMachine.destroy();
    }
    eventsListen() {
        this.on("chart_started", this.onChartStarted, this);
        this.on("tool_selected", this.onToolSelect, this);
        this.on("tool_deselected", this.onToolDeselect, this);
    }
    onChartStarted() {
        this.#toolsOverlay = this.core.Chart.graph.overlays.list.get("tools").layer.viewport;
    }
    onResized() {
        for (let menu of this.#menus) {
            menu.position();
        }
    }
    onIconClick(e) {
        let t = e.currentTarget;
        if (!t.classList.contains("enable"))
            return;
        let d = t.dataset, evt = d.event, menu = d.menu || false, tool = t.id, data = {
            target: t,
            menu,
            evt,
            tool
        };
        console.log(data);
        if (menu)
            this.emit("menu_open", data);
        else {
            this.emit("tool_activated", data);
            this.addNewTool(tool, t);
        }
    }
    onToolTargetSelected(tool) {
        console.log("tool_targetSelected:", tool.target);
        this.#toolTarget = tool.target;
    }
    onToolActivated(tool) {
        console.log("Tool activated:", tool);
        this.#activeTool = tool;
    }
    onToolSelect(e) {
        console.log("Tool selected:", e);
    }
    onToolDeselect(e) {
        console.log("Tool deselected:", e);
    }
    mount(el) {
        el.innerHTML = this.#elTools.defaultNode(this.#tools);
    }
    show(pos = this.core.theme.tools.location) {
        let toolBarW = this.core.theme.tools.width || TOOLSW;
        let dividerPos = "0px";
        switch (pos) {
            case "none":
                toolBarW = 0;
                break;
            case "right":
                dividerPos = `${toolBarW}px`;
                break;
            case "left":
            default:
                pos = "left";
                break;
        }
        let divider = this.core.elBody.clientWidth - toolBarW;
        this.core.theme.tools.location = pos;
        this.core.WidgetsG.elements.divider.style.right = dividerPos;
        this.core.WidgetsG.elements.divider.style.width = `${divider}px`;
        this.core.elBody.setToolsLocation(pos);
        this.core.MainPane.setDimensions();
        this.core.refresh();
    }
    hide() {
        this.core.WidgetsG.elements.divider.style.right = `0px`;
        this.core.elBody.setToolsLocation("none");
        this.core.MainPane.setDimensions();
        this.core.refresh();
    }
    initAllToolsGUI() {
        const tools = this.#elTools.querySelectorAll(`.icon-wrapper`);
        for (let tool of tools) {
            let id = tool.id, svg = tool.querySelector('svg');
            svg.style.fill = ToolsStyle.COLOUR_ICON;
            svg.style.width = "90%";
            for (let t of this.#tools) {
                if (t.id === id) {
                    this.#toolEvents[id] = {};
                    this.#toolEvents[id].click = this.onIconClick.bind(this);
                    if (t.active !== false) {
                        tool.addEventListener("click", this.#toolEvents[id].click);
                    }
                    if (t?.sub) {
                        let config = {
                            content: t.sub,
                            primary: tool
                        };
                        let menu = this.#widgets.insert("Menu", config);
                        tool.dataset.menu = menu.id;
                        menu.start();
                        this.#menus.push(menu);
                        for (let s of t.sub) {
                            this.#toolClasses[s.id] = s.class;
                        }
                    }
                    else {
                        this.#toolClasses[t.id] = t.class;
                    }
                }
            }
        }
    }
    addTool(tool = this.#activeTool, chartPaneID, config = {}) {
        const cfg = {
            ...config,
            name: tool,
            theme: this.core.theme,
            parent: this,
            chartPaneID
        };
        return this.tools.add(this.#toolClasses[tool], cfg);
    }
    addNewTool(tool, chartPaneID) {
    }
    drawRangeTools() {
    }
    listTools() {
        const list = {};
        function iterate(tools) {
            for (let t of tools) {
                list[t.id] = t;
                if (isArray(t?.sub))
                    iterate(t.sub);
            }
        }
        iterate(this.#tools);
        return list;
    }
    listToolOverlays() {
        const list = {};
        const tools = this.listTools();
        for (let t of Object.keys(tools)) {
            if (!!tools[t]?.class?.isOverlay)
                list[t] = tools[t];
        }
        return list;
    }
}

const iconW = 20;
const iconH = 20;
const handleColour = new Colour(GlobalStyle.COLOUR_BORDER);
const template$e = document.createElement('template');
template$e.innerHTML = `
<style>
  .scrollBarWidget {
    display: flex;
    flex-direction: row;
    justify-content: space-between;
    align-items: stretch;
    gap: 2px;
  }
  .scrollBar {
    position: relative;
    border: 1px solid var(--txc-time-scrollbar-color, ${GlobalStyle.COLOUR_BORDER});
    height: 20px;
    border-radius: 3px;
    flex-basis: 100%;
    overflow: hidden;
  }
  .scrollBar input {
    pointer-events: none;
    position: absolute;
    overflow: hidden;
    left: 0;
    top: 0;
    width: 100%;
    outline: none;
    height: 100%;
    margin: 0;
    padding: 0;
    background:  var(--txc-time-slider-color, #555);

  }
  .scrollBar input::-moz-range-thumb {
    -moz-appearance: none;
    appearance: none; 
    pointer-events: auto;
    position: relative;
    z-index: 10;
    outline: 0;
    height: 100%;
  }
  .scrollBar input::-webkit-slider-thumb {
    -webkit-appearance: none !important;
    appearance: none; 
    pointer-events: auto;
    position: relative;
    z-index: 1;
    height: 100%;
  }
  .scrollBar input::-moz-range-track {
    position: relative;
    z-index: -1;
    background-color: rgba(0, 0, 0, 1);
    border: 0;
  }
  .scrollBar input:last-of-type::-moz-range-track {
    -moz-appearance: none;
    background: none transparent;
    border: 0;
  }
  .scrollBar input[type="range"]::-webkit-slider-runnable-track {
    -webkit-appearance: none !important;
    appearance: none;
    background: none transparent;
    cursor: default;
    height: 1px; /* Required for Samsung internet based browsers */
    outline: 0;
  }
  .scrollBar input[type=range]::-moz-focus-outer {
    border: 0;
  }
  input[type=range] {
    -webkit-appearance: none;
    background: none;
  }

  input[type=range]::-webkit-slider-runnable-track {
    height: 5px;
    border: none;
    border-radius: 3px;
    background: transparent;
  }

  input[type=range]::-ms-track {
    height: 5px;
    background: transparent;
    border: none;
    border-radius: 3px;
  }

  input[type=range]::-moz-range-track {
    height: 5px;
    background: transparent;
    border: none;
    border-radius: 3px;
  }

  input[type=range]::-webkit-slider-thumb {
    -webkit-appearance: none;
    border: none;
    height: 20px;
    width: 16px;
    border-radius: 3px;
    background: var(--txc-time-slider-color, #555);
    margin-top: -10px;
    position: relative;
    z-index: 10000;
  }

  input[type=range]::-ms-thumb {
    -webkit-appearance: none;
    border: none;
    height: 20px;
    width: 16px;
    border-radius: 3px;
    background:  var(--txc-time-slider-color, #555);
    margin-top: -5px;
    position: relative;
    z-index: 10000;
  }

  input[type=range]::-moz-range-thumb {
    -webkit-appearance: none;
    border: none;
    height: 100%;
    width: 16px;
    border-radius: 3px;
    background:  var(--txc-time-slider-color, #555);
    margin-top: -5px;
    position: relative;
    z-index: 10000;
  }

  input[type=range]:focus {
    outline: none;
  }

  .handle {
    background-color: var(--txc-time-handle-color, ${handleColour.hex}44); 
    width: 2px;
    height: 18px;
    margin: 1px;
    margin-left: 872.968px;
    margin-right: 0px;
    position: absolute;
  }
  .icon {
    flex-basis: ${iconW}px;
  }
  .icon svg {
    fill: var(--txc-time-icon-color, ${GlobalStyle.COLOUR_ICON});
    width: ${iconW}px;
    height: ${iconH}px;
    margin-top: 1px;
  }
  .icon svg:hover {
    fill: var(--txc-time-icon-hover-color, ${GlobalStyle.COLOUR_ICONHOVER});
  }
</style>
<div class="scrollBarWidget">
  <span id="rwdStart" class="icon rwdStart">${rwdStart}</span>
  <span class="scrollBar">
    <div class="viewport"></div>
    <input id="min" class="min" name="min" type="range" step="1" min="0" max="3000" />
    <input id="max" class="max" name="max" type="range" step="1" min="0" max="3000" />
    <div class="handle"></div>
  </span>
  <span id="fwdEnd" class="icon fwdEnd">${fwdEnd}</span>
</div>
`;
class tradeXOverview extends element {
    #template;
    #scrollBarWidget;
    #rwdStart;
    #fwdEnd;
    #scrollBar;
    #viewport;
    #handle;
    #icons;
    #max;
    #min;
    #sliders;
    #overviewCSS;
    constructor() {
        super(template$e);
        this.#template = template$e;
    }
    destroy() {
    }
    connectedCallback() {
        super.connectedCallback(() => {
            document.getElementById('slider-bar');
            this.#scrollBarWidget = this.shadowRoot.querySelector('.scrollBarWidget');
            this.#rwdStart = this.shadowRoot.querySelector('.rwdStart');
            this.#fwdEnd = this.shadowRoot.querySelector('.fwdEnd');
            this.#scrollBar = this.shadowRoot.querySelector('.scrollBar');
            this.#viewport = this.shadowRoot.querySelector('.viewport');
            this.#handle = this.shadowRoot.querySelector('.handle');
            this.#icons = this.shadowRoot.querySelectorAll('svg');
            this.#max = this.shadowRoot.querySelector('#max');
            this.#min = this.shadowRoot.querySelector('#min');
            this.#sliders = this.shadowRoot.querySelectorAll('input');
            this.#overviewCSS = this.shadowRoot.querySelector('style[title=overview]');
            this.max.addEventListener('input', this.onChangeSliderHandler.bind({ self: this, input: this.max }));
            this.min.addEventListener('input', this.onChangeSliderHandler.bind({ self: this, input: this.min }));
        });
    }
    get scrollBarWidget() { return this.#scrollBarWidget; }
    get rwdStart() { return this.#rwdStart; }
    get fwdEnd() { return this.#fwdEnd; }
    get scrollBar() { return this.#scrollBar; }
    get viewport() { return this.#viewport; }
    get handle() { return this.#handle; }
    get icons() { return this.#icons; }
    get max() { return this.#max; }
    get min() { return this.#min; }
    get sliders() { return this.#sliders; }
    get overviewCSS() { return this.#overviewCSS; }
    onChangeSliderHandler() {
        console.log(`${this.input.value}, ${this.input.getAttribute('max')}`);
    }
}

customElements.get('tradex-overview') || window.customElements.define('tradex-overview', tradeXOverview);
const template$d = document.createElement('template');
template$d.innerHTML = `
<style>
  .viewport {
    width: 100%;
    height: ${TIMESCALEH}px;
  }
  tradex-overview {
    height: ${TIMENAVIGATIONH}px;
  }
</style>
<div class="viewport"></div>
<tradex-overview></tradex-overview>
`;
class tradeXTime extends element {
    #elViewport;
    #elOverview;
    constructor() {
        super(template$d);
    }
    destroy() {
    }
    connectedCallback() {
        super.connectedCallback(() => {
            this.#elViewport = this.shadowRoot.querySelector('.viewport');
            this.#elOverview = this.shadowRoot.querySelector('tradex-overview');
        });
    }
    get viewport() { return this.#elViewport; }
    get overview() { return this.#elOverview; }
}
customElements.get('tradex-time') || window.customElements.define('tradex-time', tradeXTime);

const template$c = document.createElement('template');
template$c.innerHTML = `
<style>
.scene-canvas {
  display: block;
}
</style>
<slot name="viewportCanvas"></slot>
<canvas class="scene-canvas"></canvas>
`;
class tradeXViewport extends element {
    #canvasSlot;
    #canvas;
    #onSlotChange = this.onSlotChange.bind(this);
    constructor() {
        super(template$c);
    }
    destroy() {
    }
    connectedCallback() {
        super.connectedCallback(() => {
            this.#canvasSlot = this.shadowRoot.querySelector('slot[name="viewportCanvas"]');
            this.#canvasSlot.addEventListener("slotchange", this.#onSlotChange);
        });
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        this.#canvasSlot.removeEventListener("slotchange", this.#onSlotChange);
    }
    get hasCanvasSlot() { return true; }
    get canvasSlot() { return this.#canvasSlot; }
    get canvas() { return this.#canvas; }
    onSlotChange() {
        this.#canvas = Array.from(this.canvasSlot.assignedElements()).find(i => i.localName === 'canvas')[0];
    }
}
customElements.get('tradex-viewport') || window.customElements.define('tradex-viewport', tradeXViewport);

const template$b = document.createElement('template');
template$b.innerHTML = `
<style>
  tradex-viewport {
    position: relative;
    width: 100%;
    height: 100%;
  }
</style>
  <tradex-viewport></tradex-viewport>
`;
class tradeXGrid extends element {
    #elViewport;
    constructor() {
        super(template$b);
    }
    destroy() {
    }
    connectedCallback() {
        super.connectedCallback(() => this.#elViewport = this.shadowRoot.querySelector('tradex-viewport'));
    }
    get viewport() { return this.#elViewport; }
}
customElements.get('tradex-grid') || window.customElements.define('tradex-grid', tradeXGrid);

const template$a = document.createElement('template');
template$a.innerHTML = `
<style>

.legends {
  display: flex;
  flex-direction: column;
}
.legends .collapse {
  order: 999;
  padding-left: 0.5em;
}

.legend {
  display: block;
  position: relative;
  width: 100%;
  min-height: 2em;
  margin: 0;
}
.legend * {
  margin: 0;
  padding: 0;
  vertical-align: middle;
}
.legend .upper,
.legend .lower {
  display: block;
  position: absolute;
  top: 0
  width: 100%;
  padding: 0 0.5em;
  white-space: nowrap;
}
.legend .lower {
  background: #0002;
  border-radius: 0 5px 5px 0;
}
.legend.secondary {
  // display: none !important;
}
.legend .controls {
  opacity: 0;
}
.legend .controls svg {
  vertical-align: text-top;
  margin-bottom: 0.2em;
}
.legend dl {
  display: inline; 
  margin: 0;
  overflow: hidden;
}
.legend dl:first-child,
.legend dl dt:first-of-type {
  margin-left: 0;
}
.legend dt {
  display: inline; margin-left: 1em;
}
.legend dd {
  display: inline; margin-left: .25em; color: #F900FE;
}
.legend .upper:hover {
  background: #444444cc;
  border-radius: 5px;
}
.legend .upper:hover .controls {
  opacity: 1;
}
.legend .title {
  margin-right: 1em;
  white-space: nowrap;
}
.legend .lower .title {
  visibility:hidden;
}
.legend .controls,
.legend dl {
  display: inline;
}
.legend .control,
.legend .control.collapse {
  margin-right: 2px;
  padding-left: 0;
}


.hide .indicator {
  display: none !important;
}


.controls .control:hover {
  background: #889;
  border-radius: 3px;
}

.controls.maximized .up,
.controls.maximized .down,
.controls.maximized .expand,
.controls.maximized .collapse,
.controls.maximized .maximize,
.controls.maximized .remove
{
  display: none;
}

.controls.restored .restore
{
  display: none;
}

.controls.collapsed .collapse {
  display: none;
}

.controls.expanded .expand {
  display: none;
}

.controls.visible .visible {
  display: none;
}
.controls.visible .notvisible {
  display: inline;
}

.controls.notvisible .notvisible {
  display: none;
}
.controls.notvisible .visible {
  display: inline;
}

.chart .upper {
  right: 0;
  z-index:1;
}
.chart .upper .title,
.secondary .upper .title {
  display: none;
}
.chart .lower .title {
  visibility: visible;
}

.secondary .upper {
  right: 0;
  z-index:1;
}
</style>
<div class="legends">
  <slot name="legend"></slot>
  <div class="controls collapse restored">
    <span id="hideLegends" class="control" data-icon="hide" style="display:none">${up}</span>
    <span id="showLegends" class="control" data-icon="show" style="display:none">${down}</span>
  </div>
</div>
`;
class tradeXLegends extends element {
    #title;
    #elLegends;
    #elTitle;
    #elInputs;
    #elControls;
    #slot;
    #hub = [];
    #onSlotChange;
    constructor() {
        super(template$a);
    }
    destroy() {
    }
    connectedCallback() {
        super.connectedCallback(() => {
            this.#slot = this.shadowRoot.querySelector('slot');
            this.#elLegends = this.shadowRoot.querySelector('.legends');
            this.#elTitle = this.shadowRoot.querySelector('.title');
            this.#elInputs = this.shadowRoot.querySelector('dl');
            this.#elControls = this.shadowRoot.querySelector('.controls');
            this.#onSlotChange = this.onSlotChange.bind(this);
            this.#slot.addEventListener('slotchange', this.#onSlotChange);
        });
    }
    disconnectedCallback() {
        this.#slot.removeEventListener('slotchange', this.#onSlotChange);
    }
    get slot() { return this.#slot; }
    get legends() { return this.#elLegends; }
    get elTitle() { return this.#elTitle; }
    get elInputs() { return this.#elInputs; }
    get elControls() { return this.#elControls; }
    get title() { return this.#title; }
    set title(t) { this.setTittle(t); }
    onSlotChange(e) {
        this.#hub.forEach(cb => cb.handler.call(cb.context, e));
    }
    insert(legend) {
        this.legends.insertAdjacentHTML('beforeend', legend);
    }
    setTittle(t) {
        if (!isString)
            return;
        this.#title = t;
        this.elTitle.innerHTML = t;
    }
    buildLegend(o, theme) {
        let styleInputs = "";
        let styleLegend = `${theme.legend.font}; color: ${theme.legend.colour}; text-align: left;`;
        let styleLegendTitle = "";
        let visibility = (o?.type !== "chart") ? `visible` : `notvisible`;
        const styleControls = "";
        const controls = (!theme.legend.controls) ? "" :
            `
      <div class="controls restored expanded ${visibility}" style="${styleControls}">
        ${this.buildControls(o)}
      </div>
    `;
        switch (o?.type) {
            case "chart":
                styleLegendTitle += "font-size: 1.5em;";
                break;
            case "secondary":
                styleLegend += " margin-bottom: -1.5em;";
                styleLegendTitle += "";
                o.title = "";
                break;
            default:
                styleLegendTitle += "font-size: 1.2em;";
                break;
        }
        const node = `
      <div id="legend_${o.id}" class="legend ${o.type}" style="${styleLegend}" data-type="${o.type}" data-id="${o.id}" data-parent="${o.parent.id}">
        <div class="lower">
          <span class="title" style="${styleLegendTitle}">${o.title}</span>
          <dl style="${styleInputs}">${this.buildInputs(o)}</dl>
        </div>
        <div class="upper">
            <span class="title" style="${styleLegendTitle}">${o.title}</span>
            ${controls}
      </div>
     </div>
    `;
        return node;
    }
    buildInputs(o) {
        let i = 0, inp = "", input, blank = "", styleDT = "", styleDD = "";
        for (input in o.inputs) {
            let colour = (o?.colours?.[i]) ? ` color: ${o.colours[i]};` : "";
            let value = (o?.inputs?.[input] !== undefined) ? o.inputs[input] : blank;
            let label = (o?.labels?.[i]) ? `${input}:` : blank;
            styleDT += (o?.labels?.[i]) ? "1em;" : ".25em";
            inp +=
                `<dt style="${styleDT}">${label}</dt>
      <dd style="${styleDD}${colour}">${value}</dd>`;
            ++i;
        }
        return inp;
    }
    buildControls(o) {
        let inp = "";
        let id = o.id;
        inp += `<span id="${id}_up" class="control up" data-icon="up">${up2}</span>`;
        inp += `<span id="${id}_down" class="control down" data-icon="down">${down2}</span>`;
        if (o?.type === "indicator") {
            inp += `<span id="${id}_visible" class="control visible" data-icon="visible">${visible}</span>`;
            inp += `<span id="${id}_notVisible" class="control notvisible" data-icon="notVisible">${notVisible}</span>`;
        }
        if (o?.type !== "indicator") {
            inp += `<span id="${id}_collapse" class="control collapse" data-icon="collapse">${collapse}</span>`;
            inp += `<span id="${id}_expand" class="control expand" data-icon="expand">${expand}</span>`;
            inp += `<span id="${id}_maximize" class="control maximize" data-icon="maximize">${maximize}</span>`;
            inp += `<span id="${id}_restore" class="control restore" data-icon="restore">${restore}</span>`;
        }
        inp += (o?.type !== "chart") ? `<span id="${id}_remove" class="control remove" data-icon="remove">${close}</span>` : ``;
        inp += (o?.type !== "secondary") ? `<span id="${id}_config" class="control config" data-icon="config">${config}</span>` : ``;
        return inp;
    }
}
customElements.get('tradex-legends') || window.customElements.define('tradex-legends', tradeXLegends);

const template$9 = document.createElement('template');
template$9.innerHTML = `
<style>
  :host {
    overflow: hidden;
  }

  .viewport {
    position: relative;
    width: 100%;
    height: inherit;
    background: var(--txc-chartpane-background, none);
  }
  .viewport canvas {
    position: absolute;
    top: 1px;
  }
  tradex-legends {
    position: absolute;
    top: 0;
    left: 0;
    z-index:100;
    width: 100%;
  }
</style>
<div class="viewport"></div>
<tradex-legends></tradex-legends>
`;
class tradeXChartPane extends element {
    #elViewport;
    #elLegend;
    constructor() {
        super(template$9);
    }
    destroy() {
    }
    connectedCallback() {
        super.connectedCallback(() => {
            this.#elViewport = this.shadowRoot.querySelector('.viewport');
            this.#elLegend = this.shadowRoot.querySelector('tradex-legends');
        });
    }
    disconnectedCallback() {
    }
    get viewport() { return this.#elViewport; }
    get legend() { return this.#elLegend; }
}
customElements.get('tradex-chartpane') || window.customElements.define('tradex-chartpane', tradeXChartPane);

const template$8 = document.createElement('template');
template$8.innerHTML = `
<style>
  slot[name="chartpane"] {
    display: flex;
    flex-direction: column;
  }
  ::slotted(tradex-chartpane) {
    display: block;
    position: relative;
    top: 0;
    width: 100%;
  }
  ::slotted(tradex-chartpane:first-of-type) {
    border-top: none !important;
  }
</style>
<slot name="chartpane" id="chartpane"></slot>
`;
class tradeXRows extends element {
    #oWidth;
    #oHeight;
    #widthCache;
    #heightCache;
    constructor() {
        super(template$8);
    }
    destroy() {
    }
    connectedCallback() {
        super.connectedCallback();
        this.previousDimensions();
    }
    disconnectedCallback() {
    }
    get grid() { return this.shadowRoot.querySelector('tradex-grid'); }
    get primary() { return Array.from(this.chartPaneSlot.assignedElements()).find(i => i.classList.contains("primary")); }
    get secondary() { return Array.from(this.chartPaneSlot.assignedElements()).find(i => i.classList.contains("secondary")); }
    get chartPanes() { return this.chartPaneSlot.assignedElements(); }
    get chartPaneSlot() { return this.shadowRoot.querySelector('slot[name="chartpane"]'); }
    get width() { return this.#widthCache; }
    get height() { return this.#heightCache; }
    get oWidth() { return this.#oWidth; }
    get oHeight() { return this.#oHeight; }
    get widthDeltaR() { return this.#widthCache / this.#oWidth; }
    get heightDeltaR() { return this.#heightCache / this.#oHeight; }
    previousDimensions() {
        this.#oWidth = (this.#widthCache) ? this.#widthCache : this.clientWidth;
        this.#oHeight = (this.#heightCache) ? this.#heightCache : this.clientHeight;
        this.#widthCache = this.clientWidth;
        this.#heightCache = this.clientHeight;
    }
}
customElements.get('tradex-rows') || window.customElements.define('tradex-rows', tradeXRows);

const template$7 = document.createElement('template');
template$7.innerHTML = `
<style>
  :host {
    display: grid;
    grid-row-gap: 0;
    grid-template-rows: 1fr ${TIMESCALEH}px;
  }
  #viewport {
    position: absolute;
    width: 100%;
    height: inherit;
    background: var(--txc-chartpane-background, none);
    z-index: 0;
  }
  #viewport canvas {
    position: absolute;
  }
  tradex-rows {
    display: grid;
    grid-row: 1/2;
    overflow: hidden;
    width: 100%;
    border: 1px solid;
    border-color: var(--txc-border-color, ${GlobalStyle.COLOUR_BORDER}); 
  }
  tradex-time {
    grid-row: 2/3;
    width: 100%;
    overflow: hidden;
  }
</style>
<div id="viewport"></div>
<tradex-rows></tradex-rows>
<tradex-time></tradex-time>
`;
class tradeXMain extends element {
    #elRows;
    #elTime;
    #elViewPort;
    #theme;
    constructor() {
        super(template$7);
    }
    destroy() {
    }
    connectedCallback() {
        super.connectedCallback(() => {
            this.#elViewPort = this.shadowRoot.querySelector('#viewport');
            this.#elRows = this.shadowRoot.querySelector('tradex-rows');
            this.#elTime = this.shadowRoot.querySelector('tradex-time');
        });
    }
    get viewport() { return this.#elViewPort; }
    get rows() { return this.#elRows; }
    get time() { return this.#elTime; }
    start(theme) {
        this.#theme = theme;
        this.setMain();
    }
    rowNode(type, style = "", api) {
        const node = `
      <tradex-chartpane slot="chartpane" class="${type}" style="${style}">
      </tradex-chartpane>
    `;
        return node;
    }
    scaleNode(type) {
        const styleRow = STYLE_ROW + ` width: 100%;`;
        const node = `
    <div slot="chartpane" class="viewport scale ${type}" style="$${styleRow}"></div>
  `;
        return node;
    }
    addRow(type, style = "", api, height) {
        let row;
        let node = this.rowNode(type, style, api);
        this.#elRows.insertAdjacentHTML("beforeend", node);
        row = this.#elRows.chartPaneSlot.assignedElements().slice(-1)[0];
        row.style.height = `${height}px`;
        return row;
    }
    removeRow(id) {
        const row = this.shadowRoot.querySelector(`#${id}`);
        if (!!row) {
            row.remove();
            return true;
        }
        else
            return false;
    }
    addScaleRow(type, height, elScale) {
        let axis;
        let node = this.scaleNode(type);
        elScale.insertAdjacentHTML("beforeend", node);
        axis = elScale.chartPaneSlot.assignedElements().slice(-1)[0];
        axis.style.height = `${height}px`;
        axis.style.width = `100%`;
        axis.height = height;
        axis.width = elScale.width;
        return axis;
    }
    setMain() {
        let timeH = (isNumber(this.#theme?.time?.height)) ? this.#theme.time.height : TIMEH;
        this.style.gridTemplateRows = `1fr ${timeH}px`;
    }
}
customElements.get('tradex-main') || window.customElements.define('tradex-main', tradeXMain);

const template$6 = document.createElement('template');
template$6.innerHTML = `
  <slot></slot>
`;
class tradeXTools extends element {
    constructor() {
        super(template$6);
    }
    destroy() {
    }
    get icons() { return this.shadowRoot.querySelector('slot').assignedElements(); }
    defaultNode(tools) {
        let toolbar = `
    <style>
      svg {
        height: ${ToolsStyle.ICONSIZE};
        width: ${ToolsStyle.ICONSIZE};
        fill: ${ToolsStyle.COLOUR_ICON};
        opacity: 0.5;
        display: none;
      }
      .display svg {
        display: block;
      }
      .enable svg {
        opacity: 1;
      }
      .enable svg:hover {
        fill: ${ToolsStyle.COLOUR_ICONHOVER} !important;
      }
      .icon-wrapper {
        width: ${ToolsStyle.ICONSIZE};
        margin: 0 auto;
      }
    </style>
    `;
        for (const tool of tools) {
            toolbar += this.iconNode(tool);
        }
        return toolbar;
    }
    iconNode(tool) {
        const menu = ("sub" in tool) ? `data-menu="true"` : "";
        const active = (tool?.active !== false) ? `active` : ``;
        const enable = (tool?.enable !== false) ? `enable` : ``;
        const display = (tool?.display !== false) ? `display` : ``;
        return `
      <div id="${tool.id}" data-event="${tool.event}" ${menu} class="icon-wrapper ${active} ${enable} ${display}">${tool.icon}</div>\n
    `;
    }
}
customElements.get('tradex-tools') || window.customElements.define('tradex-tools', tradeXTools);

const template$5 = document.createElement('template');
template$5.innerHTML = `
<style>
  tradex-viewport {
    width: 100%;
    height: 100%;
    display: block;
    position: absolute;
    z-index: -100;
  }
  slot[name="chartpane"] {
    display: flex;
    flex-direction: column;
  }
  ::slotted(div.scale:first-of-type) {
    border-top: none !important;
  }
</style>
<tradex-viewport></tradex-viewport>
<slot name="chartpane" id="chartPane"></slot>
`;
class tradeXScale extends element {
    #elViewport;
    #elChartPanes;
    #elChartPaneSlot;
    constructor() {
        super(template$5);
    }
    destroy() {
    }
    connectedCallback() {
        super.connectedCallback(() => {
            this.#elViewport = this.shadowRoot.querySelector('tradex-viewport');
            this.#elChartPaneSlot = this.shadowRoot.querySelector('slot[name="chartpane"]');
            this.#elChartPanes = this.chartPaneSlot.assignedElements();
        });
    }
    get viewport() { return this.#elViewport; }
    get chartPanes() { return this.#elChartPanes; }
    get chartPaneSlot() { return this.#elChartPaneSlot; }
}
customElements.get('tradex-scale') || window.customElements.define('tradex-scale', tradeXScale);

const template$4 = document.createElement('template');
const content = `
<style>
  :host {
    display: grid;
    grid-column-gap: 0;
    grid-template-columns: 0 0 1fr ${SCALEW}px 0;
    grid-template-rows: 1fr;
  }
  tradex-main, tradex-scale, tradex-tools {
    max-height: 100%;
    min-height: 100%;
    overflow: hidden;
  }
  tradex-tools {
    grid-column: 1/2;
    grid-row: 1/2;
  }
  tradex-scale:first-of-type {
    grid-column: 2/3;
  }
  tradex-main {
    grid-column: 3/4;
  }
  tradex-scale:last-of-type {
    grid-column: 4/5;
  }
</style>
<tradex-tools></tradex-tools>
<tradex-scale></tradex-scale>
<tradex-main></tradex-main>
<tradex-scale></tradex-scale>
`;
template$4.innerHTML = content;
class tradeXBody extends element {
    #theme;
    #elTools;
    #elMain;
    #elScale;
    #elScale2;
    #gridTemplateColumns = {
        toolsLeft: `${TOOLSW}px`,
        scaleLeft: `0`,
        main: `1fr`,
        scaleRight: `${TOOLSW}px`,
        toolsRight: `0`
    };
    constructor() {
        super(template$4);
    }
    destroy() {
    }
    connectedCallback() {
        super.connectedCallback(() => {
            this.style.display = "grid";
            this.#elTools = this.shadowRoot.querySelector('tradex-tools');
            this.#elMain = this.shadowRoot.querySelector('tradex-main');
            this.#elScale = this.shadowRoot.querySelectorAll('tradex-scale')[1];
            this.#elScale2 = this.shadowRoot.querySelectorAll('tradex-scale')[0];
        });
    }
    get tools() { return this.#elTools; }
    get main() { return this.#elMain; }
    get scale() { return this.#elScale; }
    get scaleW() { return this.#elScale.width || this.#theme?.scale?.width || SCALEW; }
    get scale2W() { return this.#elScale.width || this.#theme?.scale?.width || SCALEW; }
    get toolsW() { return this.#elTools.width || this.#theme?.tools?.width || TOOLSW; }
    start(theme) {
        this.#theme = theme;
        this.setToolsLocation();
    }
    setYAxisWidth(width = this.scaleW) {
        width = (isNumber(width)) ? width : this.scaleW;
        this.setYAxisLocation(undefined, width);
    }
    setYAxisLocation(side = this.#theme?.yAxis?.location, width = this.scaleW) {
        switch (side) {
            case "left":
                this.#gridTemplateColumns.scaleLeft = `${width}px`;
                this.#gridTemplateColumns.scaleRight = `0`;
                this.#elScale.style.gridColumn = "2/3";
                this.#elScale2.style.gridColumn = "4/5";
                this.#elScale.style.display = "block";
                this.#elScale2.style.display = "none";
                break;
            case "both":
                this.#gridTemplateColumns.scaleLeft = `${width}px`;
                this.#gridTemplateColumns.scaleRight = `${width}px`;
                this.#elScale.style.gridColumn = "4/5";
                this.#elScale2.style.gridColumn = "2/3";
                this.#elScale.style.display = "block";
                this.#elScale2.style.display = "block";
                break;
            case "right":
            default:
                this.#gridTemplateColumns.scaleLeft = `0`;
                this.#gridTemplateColumns.scaleRight = `${width}px`;
                this.#elScale.style.gridColumn = "4/5";
                this.#elScale2.style.gridColumn = "2/3";
                this.#elScale.style.display = "block";
                this.#elScale2.style.display = "none";
                break;
        }
        this.setGridColumns();
    }
    setToolsLocation(side = this.#theme?.tools?.location) {
        let toolsW = (side == "left" || side == "right") ? this.#theme.tools.width || TOOLSW : 0;
        this.#elTools.style.width = `${toolsW}px`;
        switch (side) {
            case "none":
            case false:
                this.#gridTemplateColumns.toolsLeft = `0`;
                this.#gridTemplateColumns.toolsRight = `0`;
                this.#elTools.style.display = "none";
                break;
            case "right":
                this.#gridTemplateColumns.toolsLeft = `0`;
                this.#gridTemplateColumns.toolsRight = `${toolsW}px`;
                this.#elTools.style.gridColumn = "5/6";
                this.#elTools.style.display = "block";
                break;
            case "left":
            default:
                this.#gridTemplateColumns.toolsLeft = `${toolsW}px`;
                this.#gridTemplateColumns.toolsRight = `0`;
                this.#elTools.style.gridColumn = "1/2";
                this.#elTools.style.display = "block";
                break;
        }
        this.setGridColumns();
    }
    setGridColumns() {
        this.style.gridTemplateColumns = Object.values(this.#gridTemplateColumns).join(" ");
    }
}
customElements.get('tradex-body') || window.customElements.define('tradex-body', tradeXBody);

const template$3 = document.createElement('template');
template$3.innerHTML = `
  <style>
    .utilsOptions {
      display: inline-block; float: right;
    }
  </style>
  <slot></slot>
  <div class="utilsOptions">
  </div>
`;
class tradeXUtils extends element {
    constructor() {
        super(template$3);
    }
    destroy() {
    }
    get icons() { return this.shadowRoot.querySelector('slot').assignedElements()[0].children; }
    defaultNode(utils) {
        let style = `display: inline-block; float: right;`;
        let utilsBar = `
    <div style="${style}">
    <style>
      svg {
        height: ${UtilsStyle.ICONSIZE};
        fill: ${UtilsStyle.COLOUR_ICON};
      }
    </style>
    `;
        for (const util of utils) {
            utilsBar += this.iconNode(util);
        }
        return utilsBar + "</div>";
    }
    iconNode(util) {
        const iconStyle = `display: inline-block; height: ${UtilsStyle.ICONSIZE}; padding-top: 2px`;
        const menu = ("sub" in util) ? `data-menu="true"` : "";
        return `
      <div id="TX_${util.id}" data-event="${util.event}" ${menu} class="icon-wrapper" style="${iconStyle}">${util.icon}</div>\n
    `;
    }
}
customElements.get('tradex-utils') || window.customElements.define('tradex-utils', tradeXUtils);

const template$2 = document.createElement('template');
template$2.innerHTML = `
  <slot name="widget"></slot>
`;
class tradeXWidgets extends element {
    constructor() {
        super(template$2);
    }
    destroy() {
    }
}
customElements.get('tradex-widgets') || window.customElements.define('tradex-widgets', tradeXWidgets);

const HTML = `
  <style title="core">
    :host {
      position: relative;
      z-index: 0;
      display: grid;
      grid-row-gap: 0;
      grid-template-rows: ${UTILSH}px 1fr 0;
    }
    tradex-utils {
      grid-row: 1/2;
      width: 100%; 
    }
    tradex-body {
      grid-row: 2/3;
      width: 100%;
    }
    tradex-widgets {
      grid-row: 3/4;
      position: relative;
    }
  </style>
  <div style="display: none;">
    <slot></slot>
  </div>
  <tradex-utils></tradex-utils>
  <tradex-body></tradex-body>
  <tradex-widgets></tradex-widgets>
`;
const template$1 = document.createElement('template');
template$1.innerHTML = HTML;
class tradeXChart extends element {
    #elBody;
    #elUtils;
    #elWidgets;
    #template;
    #chartW = CHART_MINW;
    #chartH = CHART_MINH;
    #oWidth;
    #oHeight;
    #widthCache;
    #heightCache;
    #theme;
    #resizeEntries;
    constructor() {
        super(template$1, "closed");
    }
    destroy() {
        this.resizeObserver.disconnect();
    }
    static get observedAttributes() {
        return ['config', 'disabled', 'height', 'width'];
    }
    connectedCallback() {
        if (this.doInit) {
            this.doInit = false;
            this.shadowRoot.appendChild(template$1.content.cloneNode(true));
            this.init();
            this.#chartH = this.parentElement.clientHeight || CHART_MINH;
            this.#chartW = this.parentElement.clientWidth || CHART_MINW;
            let height = this.getAttribute('height') || "100%";
            let width = this.getAttribute('width') || "100%";
            this.setDimensions(width, height);
            this.resizeObserver = new ResizeObserver(debounce(this.onResized, 100, this));
            this.resizeObserver.observe(this);
            this.start(defaultConfig);
        }
    }
    disconnectedCallback() {
        this.resizeObserver.disconnect();
    }
    attributeChangedCallback(prop, oldVal, newVal) {
        switch (prop) {
            case "config":
                break;
            case "disabled":
                break;
            case "height":
                this.setDimensions(undefined, newVal);
                break;
            case "width":
                this.setDimensions(newVal, undefined);
                break;
        }
    }
    init() {
        this.style.display = "grid";
        this.style.minHeight = TX_MINH;
        this.#elWidgets = this.shadowRoot.querySelector('tradex-widgets');
        this.#elUtils = this.shadowRoot.querySelector('tradex-utils');
        this.#elBody = this.shadowRoot.querySelector('tradex-body');
    }
    get disabled() { return this.hasAttribute('disabled'); }
    set disabled(d) {
        if (d) {
            this.setAttribute('disabled', '');
        }
        else {
            this.removeAttribute('disabled');
        }
    }
    get elBody() { return this.#elBody; }
    get elUtils() { return this.#elUtils; }
    get elWidgets() { return this.#elWidgets; }
    get elWidgetsG() { return this.#elWidgets; }
    get elMain() { return this.#elBody.main; }
    get elTime() { return this.#elBody.main.time; }
    get elRows() { return this.#elBody.main.rows; }
    get elTools() { return this.#elBody.tools; }
    get elYAxis() { return this.#elBody.scale; }
    get width() { return this.#chartW; }
    get height() { return this.#chartH; }
    get resizeEntries() { return this.#resizeEntries; }
    elStart(theme) {
        this.#theme = theme;
        this.setUtilsLocation();
    }
    onResized(entries) {
        super.onResize(entries);
        const { width, height } = entries[0].contentRect;
        this.#chartW = width;
        this.#chartH = height;
        this.#resizeEntries = entries[0];
        if (this.ToolsBar instanceof ToolsBar) {
            this.ToolsBar.onResized();
        }
        this.log(`onResize w: ${width}, h: ${height}`);
        this.emit("global_resize", { w: width, h: height });
    }
    setWidth(w) {
        if (isNumber(w)) {
            w += "px";
        }
        else if (isString(w) && w.match(CSSUNITS)) ;
        else {
            w = "100%";
        }
        this.style.width = w;
        this.#chartW = Math.round(this.getBoundingClientRect().width);
    }
    setHeight(h) {
        if (isNumber(h)) {
            h += "px";
        }
        else if (isString(h) && h.match(CSSUNITS)) ;
        else {
            this.#chartH = this.parentElement.getBoundingClientRect().height;
            h = this.#chartH + "px";
        }
        this.style.height = h;
        this.#chartH = Math.round(this.getBoundingClientRect().height);
    }
    setWidthMin(w) { this.style.minWidth = `var(--txc-min-width, ${w})`; }
    setHeightMin(h) { this.style.minHeight = `var(--txc-min-height, ${h})`; }
    setWidthMax(w) { this.style.minWidth = `var(--txc-max-width, ${w})`; }
    setHeightMax(h) { this.style.minHeight = `var(--txc-max-height, ${h})`; }
    setDimensions(w, h) {
        let dims;
        let width = this.width;
        let height = this.height;
        if (!w || !h) {
            const dims = this.getBoundingClientRect();
            const parent = this.parentElement.getBoundingClientRect();
            h = (!dims.height) ? (!parent.height) ? CHART_MINH : parent.height : dims.height;
            w = (!dims.width) ? (!parent.width) ? CHART_MINW : parent.width : dims.width;
        }
        else if (!isNumber(w) || !isNumber(h)) {
            if (!isString(w) || !w.match(CSSUNITS)) {
                w = "100%";
            }
            if (!isString(h) || !h.match(CSSUNITS)) {
                h = "100%";
            }
        }
        this.setWidth(w);
        this.setHeight(h);
        dims = {
            width: this.width,
            height: this.height,
            resizeW: w / width,
            resizeH: h / height,
            resizeWDiff: w - width,
            resizeHDiff: h - height
        };
        return dims;
    }
    setUtilsLocation(pos = this.#theme?.utils?.location) {
        this.#theme.utils = this.#theme?.utils || {};
        const utilsH = (isNumber(this.#theme.uitils?.height) &&
            this.#theme.utils.height > 0) ?
            this.#theme.uitils.height :
            UTILSH;
        switch (pos) {
            case "top":
            case true:
                this.#theme.utils.location = "top";
                this.#theme.utils.height = utilsH;
                this.style.gridTemplateRows = `${utilsH}px 1fr`;
                this.elBody.style.minHeight = `${CHART_MINH - utilsH}px`;
                break;
            case "none":
            case false:
            default:
                this.#theme.utils.location = "none";
                this.#theme.utils.height = 0;
                this.elUtils.style.display = "none";
                this.style.gridTemplateRows = `0 1fr`;
                this.elBody.style.minHeight = `${CHART_MINH}px`;
                break;
        }
    }
}

var utilsList = [
    {
        id: "indicators",
        name: "Indicators",
        icon: chart,
        event: "utils_indicators",
        sub: [],
    },
    {
        id: "timezone",
        name: "Timezone",
        icon: clock,
        event: "utils_timezone",
    },
    {
        id: "screenshot",
        name: "Screenshot",
        icon: camera,
        event: "utils_screenshot",
    },
    {
        id: "settings",
        name: "Settings",
        icon: config,
        event: "utils_settings",
    },
];

class UtilsBar extends Component {
    #name = "Utilities";
    #shortName = "utils";
    #elUtils;
    #utils;
    #location;
    #widgets;
    #indicators;
    #menus = {};
    #utilsEvents = {};
    #timers = {};
    constructor(core, options) {
        super(core, options);
        this.#elUtils = core.elUtils;
        this.#utils = core.config?.utilsBar || utilsList;
        this.#widgets = core.WidgetsG;
        this.#indicators = core.indicatorsPublic || indicators;
        this.#location = core.config.theme?.utils?.location || "none";
        if (!!this.#location ||
            this.#location == "none" ||
            !UTILSLOCATIONS.includes(this.#location)) {
            this.core.style.gridTemplateRows = `0 1fr`;
        }
        this.#elUtils.innerHTML = this.#elUtils.defaultNode(this.#utils);
    }
    get name() { return this.#name; }
    get shortName() { return this.#shortName; }
    get pos() { return this.dimensions; }
    get dimensions() { return elementDimPos(this.#elUtils); }
    get location() { return this.#location; }
    start() {
        this.initAllUtils();
        this.eventsListen();
        this.log(`Utils Bar ${this.#name} instantiated and running`);
    }
    destroy() {
        const api = this.core;
        const utils = findBySelectorAll(`#${api.id} .${CLASS_UTILS} .icon-wrapper`);
        for (let util of utils) {
            let id = util.id.replace('TX_', '');
            for (let u of this.#utils) {
                if (u.id === id)
                    util.removeEventListener("click", this.#utilsEvents[id].click);
                util.removeEventListener("pointerover", this.#utilsEvents[id].pointerover);
                util.removeEventListener("pointerout", this.#utilsEvents[id].pointerout);
            }
        }
        this.core.hub.expunge(this);
    }
    eventsListen() {
        this.on("utils_indicators", this.onIndicators, this);
        this.on("utils_timezone", this.onTimezone, this);
        this.on("utils_settings", this.onSettings, this);
        this.on("utils_screenshot", this.onScreenshot, this);
    }
    onIconClick(e) {
        const target = findTargetParentWithClass(e.target, "icon-wrapper");
        if (!isObject(target))
            return false;
        const now = Date.now();
        if (now - this.#timers[target.id] < 1000)
            return false;
        this.#timers[target.id] = now;
        let evt = target.dataset.event;
        let menu = target.dataset.menu || false, data = {
            target: target.id,
            menu: menu,
            evt: evt
        };
        let action = target.dataset.action;
        this.emit(evt, data);
        if (menu)
            this.emit("menu_open", data);
        else {
            this.emit("util_selected", data);
        }
        if (action)
            action(data, this.core);
    }
    onIconOver(e) {
        const svg = e.currentTarget.querySelector('svg');
        svg.style.fill = UtilsStyle.COLOUR_ICONHOVER;
    }
    onIconOut(e) {
        const svg = e.currentTarget.querySelector('svg');
        svg.style.fill = UtilsStyle.COLOUR_ICON;
    }
    initAllUtils() {
        const utils = this.#elUtils.querySelectorAll(`.icon-wrapper`);
        for (let util of utils) {
            this.#timers[util.id] = 0;
            let id = util.id.replace('TX_', ''), svg = util.querySelector('svg');
            svg.style.fill = UtilsStyle.COLOUR_ICON;
            svg.style.height = "90%";
            for (let u of this.#utils) {
                if (u.id === id) {
                    this.#utilsEvents[id] = {};
                    this.#utilsEvents[id].click = this.onIconClick.bind(this);
                    this.#utilsEvents[id].pointerover = this.onIconOver.bind(this);
                    this.#utilsEvents[id].pointerout = this.onIconOut.bind(this);
                    util.addEventListener("click", this.#utilsEvents[id].click);
                    util.addEventListener("pointerover", this.#utilsEvents[id].pointerover);
                    util.addEventListener("pointerout", this.#utilsEvents[id].pointerout);
                    if (id === "indicators")
                        u.sub = Object.values(this.#indicators);
                    if (u?.sub) {
                        let config = {
                            content: u.sub,
                            primary: util
                        };
                        let menu = this.#widgets.insert("Menu", config);
                        util.dataset.menu = menu.id;
                        menu.start();
                    }
                }
            }
        }
    }
    onIndicators(data) {
    }
    onTimezone(data) {
        this.core.notImplemented();
    }
    onSettings(data) {
        this.core.notImplemented();
    }
    onScreenshot(data) {
        this.core.downloadImage();
    }
}

const MENUMINWIDTH = 150;
class Menu {
    #id;
    #widgets;
    #core;
    #config;
    #elWidgetsG;
    #elMenus;
    #elMenu;
    #cursorPos;
    #controller;
    #menuEvents = {};
    static { this.menuList = {}; }
    static { this.menuCnt = 0; }
    static { this.class = CLASS_MENUS; }
    static { this.Name = "Menus"; }
    static { this.type = "menu"; }
    static create(widgets, config) {
        const id = `menu_${++Menu.menuCnt}`;
        config.id = id;
        Menu.menuList[id] = new Menu(widgets, config);
        return Menu.menuList[id];
    }
    static destroy(id) {
        Menu.menuList[id].end();
        delete Menu.menuList[id];
    }
    constructor(widgets, config) {
        this.#widgets = widgets;
        this.#core = config.core;
        this.#config = config;
        this.#id = config.id;
        this.#elMenus = widgets.elements[Menu.type];
        this.#elWidgetsG = this.#core.elWidgetsG;
        this.mount(this.#elMenus);
    }
    get el() { return this.#elMenu; }
    get id() { return this.#id; }
    get pos() { return this.dimensions; }
    get dimensions() { return elementDimPos(this.#elMenu); }
    get type() { return Menu.type; }
    start() {
        this.position();
        this.eventsListen();
    }
    end() {
        const menuItems = this.#elMenus.querySelectorAll(`#${this.id} li`);
        menuItems.forEach((item) => {
            item.removeEventListener('click', this.#menuEvents[this.id][item.id]);
        });
        document.removeEventListener('click', this.#menuEvents[this.id].outside);
        this.off("global_resize", this.onResize, this);
    }
    eventsListen() {
        const menuItems = this.#elMenus.querySelectorAll(`#${this.id} li`);
        this.#menuEvents[this.id] = {};
        menuItems.forEach((item) => {
            this.#menuEvents[this.id][item.id] = this.onMenuSelect.bind(this);
            item.addEventListener('click', this.#menuEvents[this.id][item.id]);
        });
        this.on("global_resize", this.onResize, this);
    }
    on(topic, handler, context = this) {
        this.#core.on(topic, handler, context);
    }
    off(topic, handler, context = this) {
        this.#core.off(topic, handler, context);
    }
    emit(topic, data) {
        this.#core.emit(topic, data);
    }
    onMenuSelect(e) {
        let evt = e.currentTarget.dataset.event, data = {
            target: e.currentTarget.id,
            menu: this.#id,
            evt: evt
        };
        this.emit("menuItem_selected", data);
        this.emit("menu_close", data);
        this.#core.log(`menu_close: ${this.#id}`);
    }
    onOutsideClickListener(e) {
        if (!this.#elMenu.contains(e.target)
            && (!this.#config.primary.contains(e.target))
            && isVisible(this.#elMenu)) {
            let data = {
                target: e.currentTarget.id,
                menu: this.#id,
            };
            this.emit("menu_close", data);
        }
        document.removeEventListener('click', this.#menuEvents[this.id].outside);
    }
    onResize() {
        this.position();
    }
    mount(el) {
        if (el.lastElementChild == null)
            el.innerHTML = this.menuNode();
        else
            el.lastElementChild.insertAdjacentHTML("afterend", this.menuNode());
        this.#elMenu = this.#elMenus.querySelector(`#${this.id}`);
    }
    static defaultNode() {
        const menuStyle = ``;
        const node = `
      <div slot="widget" class="${CLASS_MENUS}" style="${menuStyle}"></div>
    `;
        return node;
    }
    menuNode() {
        const menu = this.#config;
        const menuStyle = `position: absolute; z-index: 1000; display: none; border: 1px solid ${MenuStyle.COLOUR_BORDER}; background: ${MenuStyle.COLOUR_BG}; color: ${MenuStyle.COLOUR_TXT}; box-shadow: rgba(0, 0, 0, 0.3) 0px 19px 38px, rgba(0, 0, 0, 0.22) 0px 15px 12px;`;
        let content = this.content(menu);
        let node = `
      <div id="${menu.id}" class="${CLASS_MENU}" style="${menuStyle}">
        ${content}
      </div>
    `;
        return node;
    }
    content(menu) {
        const listStyle = `list-style: none; text-align: left; margin:1em 1em 1em -2.5em; min-width: ${MENUMINWIDTH}px`;
        const itemStyle = "padding: .25em 1em .25em 1em; white-space: nowrap;";
        const shortStyle = "display: inline-block; width: 4em;";
        const cPointer = "cursor: pointer;";
        const over = `onmouseover="this.style.background ='#222'"`;
        const out = `onmouseout="this.style.background ='none'"`;
        let content = `<ul style="${listStyle}">`;
        if (menu?.content) {
            for (let i of menu.content) {
                content += `<li id="${i.id}" data-event="${i.event}" style="${itemStyle} ${cPointer}" ${over} ${out}><a style="${cPointer}"><span style="${shortStyle}">${i.id}</span><span>${i.name}</span></li></a>`;
            }
        }
        content += "</ul>";
        return content;
    }
    position() {
        let wPos = this.#elWidgetsG.getBoundingClientRect();
        let iPos = this.#config.primary.getBoundingClientRect();
        let left = Math.round(iPos.left - wPos.left);
        let top = Math.round(iPos.bottom - wPos.top);
        this.#elMenu.style.left = left + "px";
        this.#elMenu.style.top = top + "px";
        let pos = elementDimPos(this.#elMenu);
        if (pos.right > this.#elWidgetsG.offsetWidth) {
            let o = Math.floor(this.#elWidgetsG.offsetWidth - pos.width);
            o = limit(o, 0, this.#elWidgetsG.offsetWidth);
            this.#elMenu.style.left = `${o}px`;
        }
        let bottom = this.#core.MainPane.rowsH + top + pos.height;
        if (bottom > this.#core.MainPane.rowsH) {
            let o = Math.floor(pos.height * -1);
            o = limit(o, this.#core.MainPane.rowsH * -1, 0);
            this.#elMenu.style.top = `${o}px`;
        }
    }
    remove() {
    }
    open() {
        if (Menu.currentActive === this)
            return true;
        Menu.currentActive = this;
        this.#elMenu.style.display = "block";
        this.position();
        setTimeout(() => {
            this.#menuEvents[this.id].outside = this.onOutsideClickListener.bind(this);
            document.addEventListener('click', this.#menuEvents[this.id].outside);
        }, 250);
    }
    close() {
        Menu.currentActive = null;
        this.#elMenu.style.display = "none";
        this.emit("menuClosed", this.id);
    }
}

class Dialogue extends Window {
    static { this.Name = "Dialogues"; }
    static { this.type = "dialogue"; }
    static { this.class = "tradeXdialogue"; }
    static { this.defaultStyles = `
  /** default Dialogue widget styles */
  `; }
    static create(widgets, cfg) {
        cfg.dragBar = (isBoolean(cfg?.dragBar)) ? cfg.dragBar : true;
        cfg.close = (isBoolean(cfg?.close)) ? cfg.close : true;
        cfg.type = cfg?.type || Dialogue.type;
        cfg.class = cfg?.class || "dialogue";
        cfg.id = cfg?.id || uid("dialogue");
        return super.create(widgets, cfg);
    }
    static defaultNode() {
        const windowStyle = ``;
        const node = `
      <div slot="widget" class="tradeXdialogue" style="${windowStyle}">
      </div>
    `;
        return node;
    }
    constructor(widgets, config) {
        super(widgets, config);
    }
    destroy() {
        super.destroy();
    }
    get type() { return Dialogue.type; }
    dialogueBuild(content = "", buttons = []) {
        let modifiers = { buttons: {} };
        let buttonHTML = `
    <input class="submit" type="submit" value="Submit"/>
    <input class="cancel" type="button" value="Cancel"/>
    <input class="default" type="button" value="Default"/>
    `;
        if (isArray(buttons) &&
            buttons.length > 1) ;
        else {
            modifiers.submit =
                provideEventListeners(`input.submit`, [{
                        event: "click",
                        fn: (e) => {
                            if (isFunction(this.parent.onConfigDialogueSubmit))
                                this.parent.onConfigDialogueSubmit(this);
                        }
                    }]);
            modifiers.cancel =
                provideEventListeners(`input.cancel`, [{
                        event: "click",
                        fn: (e) => {
                            if (isFunction(this.parent.onConfigDialogueCancel))
                                this.parent.onConfigDialogueCancel(this);
                        }
                    }]);
            modifiers.default =
                provideEventListeners(`input.default`, [{
                        event: "click",
                        fn: (e) => {
                            if (isFunction(this.parent.onConfigDialogueDefault))
                                this.parent.onConfigDialogueDefault(this);
                        }
                    }]);
        }
        const html = `
    ${new String(content)}
    <div class="buttons">
      ${buttonHTML}
    </div>
    `;
        return { html, modifiers };
    }
}

const tabStyles = `
/** default Config Dialogue widget styles */

.tabbedContent {
  overflow: hidden;
}

.tabbedContent .content {
  padding: 0;
}
.tabbedContent .tabs {
  display: flex;
  flex-wrap: wrap;
  background: #e5e5e588;
  box-shadow: 0 48px 80px -32px rgba(0,0,0,0.3);
  width: 300px;
}
.tabbedContent .input {
  position: absolute;
  opacity: 0;
  padding: 0;
  margin: 0;
  height: 100%;
  width: 100%;
  top: 0;
  left: 0;
}
.tabbedContent .label {
  position: relative;
  width: auto;
  padding: .4em 1em;
  background: #e5e5e588;
  cursor: pointer;
  font-weight: bold;
  color: #7f7f7f;
  transition: background 0.1s, color 0.1s;
}
.tabbedContent .label:hover {
  background: #d8d8d8;
}
.tabbedContent .label:active {
  background: #ccc;
}
.tabbedContent label:has(> input:checked) {
  background: #fff;
  color: #000;
}
.tabbedContent .panel {
  display: none;
  padding: 1em 1em 1.5em;
  background: #ffffff88;
  order: 100;
}
.tabbedContent label:has(> input:checked) + .panel {
  display: grid;
  width: 100%;
  grid-template-columns: [label] 1fr [input] 10em [end];
  grid-row-gap: 2px;
  align-items: center;
}
.tabbedContent .panel label,
.tabbedContent .panel input {
  ${GlobalStyle.FONTSTRING}
  padding: 1px 2px;
}
.tabbedContent .panel label {
  grid-column-start: label;
  grid-column-end: input;
  color: #444;
  font-weight: bold;
}
.tabbedContent .panel input {
  border: 1px solid #888;
}
.tabbedContent .panel input[type="color"] {
  -webkit-appearance: none;
  -moz-appearance: none;
  appearance: none;
  width: 3em;
  height: 2em;
  background-color: transparent;
  cursor: pointer;
  padding: 0;
  border: none;
}
.tabbedContent .panel input[type="color"]::-webkit-color-swatch,
.tabbedContent .panel input[type="color"]::-moz-color-swatch {
  border-radius: 0;
  padding: 1px;
  margin 0;
  border-radius: 3px;
  border: 1px solid #000;
  height: 2em;
  background: #fff;
}
`;
const template = document.createElement('template');
template.innerHTML = `
<style>
  ${tabStyles}
}
</style>
<div class="tabbedContent">
</div>
`;
class tradeXTabs extends element {
    #id;
    #elTabs;
    #tabsSlot;
    #tabs;
    #onSlotChange = this.onSlotChange.bind(this);
    constructor() {
        super(template);
    }
    destroy() {
    }
    connectedCallback() {
        super.connectedCallback(() => {
            this.#elTabs = this.shadowRoot.querySelector('.tabbedContent');
            this.#tabsSlot = this.shadowRoot.querySelector('slot[name="viewporttabs"]');
            this.#tabsSlot.addEventListener("slotchange", this.#onSlotChange);
        });
    }
    disconnectedCallback() {
        super.disconnectedCallback();
        this.#tabsSlot.removeEventListener("slotchange", this.#onSlotChange);
    }
    get hastabsSlot() { return true; }
    get tabsSlot() { return this.#tabsSlot; }
    get tabs() { return this.#tabs; }
    onSlotChange() {
        this.#tabs = Array.from(this.tabsSlot.assignedElements()).find(i => i.localName === 'tabs')[0];
    }
    insertTab(t) {
        let { id, label, content, checked } = t;
        switch (typeof id) {
            case "string":
            case "number": break;
            default: id = this.#tabs.length;
        }
        let tab = tabsPanel(id, label, content, checked);
        tab = this.#elTabs.insertAdjacentHTML("afterend", tab);
        this.#tabs.push({ id, label, content, checked, tab });
    }
    removeTab(t) {
        if (isString(t)) {
            let tab = this.#elTabs.querySelectorAll(`.tab-${t}`);
            for (let d of tab) {
                d.remove();
            }
            for (let d = 0; d < this.#tabs.length; d++) {
                if (this.#tabs[d].id == t)
                    delete this.#tabs[d];
            }
        }
        else if (isNumber(t)) {
            this.#elTabs.querySelectorAll(`.input`);
        }
    }
}
class Tabs {
    static #cnt;
    static { this.defaultStyles = tabStyles; }
    static create(config) {
        if (!isObject(config))
            config = {};
        config.id = config?.id || Tabs.#cnt++;
        const tabs = new Tabs(config);
        return tabs;
    }
    #id;
    #element;
    #elementHtML;
    constructor(config) {
        this.#id = config.id;
        this.#elementHtML = tabsElement(config.params);
        if (isHTMLElement(config?.element)) {
            this.#element = config.element;
            this.#element.innerHTML = this.#elementHtML;
        }
    }
}
function tabsElement(c = {}) {
    if (!isObject(c))
        c = {};
    const element = `
  <div class="tabs">
    ${tabsBuild(c)}
  </div>
  `;
    return element;
}
function tabsBuild(c = {}, fn) {
    if (!isObject(c))
        c = {};
    let tabs = ``;
    let t = Object.keys(c);
    let i = t.length;
    if (i < 1) {
        tabs += tabsPanel(1, "Question", "Why did the chicken cross the road?", true);
        tabs += tabsPanel(2, "Answer", "To get to the other side.");
    }
    else {
        let j = [];
        for (--i; i >= 0; i--) {
            let f = (i == 0) ? true : false;
            let content = (isFunction(fn)) ? fn(c[t[i]]) : c[t[i]];
            j.push(tabsPanel(i, t[i], content, f));
        }
        tabs = j.reverse().join("&nbsp;");
    }
    return tabs;
}
function tabsPanel(id, label, content, checked = false) {
    content = (isString(content)) ? content : ``;
    const check = (!!checked) ? `checked="checked"` : ``;
    const tab = `
  <label class="label tab_${id}" for="tab_${id}">
    <span>${label}</span>
    <input class="input tab_${id}" name="tabs" type="radio" id="tab_${id}" ${check}/>
  </label>
  <div class="panel tab_${id}">
    ${content}
  </div>
  `;
    return tab;
}
customElements.get('tradex-tabs') || window.customElements.define('tradex-tabs', tradeXTabs);

class ConfigDialogue extends Dialogue {
    static { this.Name = "ConfigDialogues"; }
    static { this.type = "configDialogue"; }
    static { this.class = "tradeXconfig"; }
    static { this.defaultStyles = `
  /** default Config Dialogue widget styles */
  
  .tradeXwindow.config {
    /* overflow: hidden; */
    background: none;
  }

  .tradeXwindow.config.active .content {
    padding: 0;
    position: relative;
  }

  .tradeXwindow.config.active .buttons {
    background: #ffffffbb;
    display: flex;
    justify-content: flex-end;
    padding: 3px 1em;
    border-radius: 0 0 5px 5px;
  }

  .tradeXwindow.config.active .buttons input {
    margin-left: 5px;
    font-size: 1em;
    padding: 1px .5em;
  }

  ${tabStyles} 
  `; }
    static create(widgets, config) {
        config.dragBar = true;
        config.close = true;
        config.type = ConfigDialogue.type;
        config.class = "config";
        config.id = uid("config");
        return new ConfigDialogue(widgets, config);
    }
    static defaultNode() {
        const windowStyle = ``;
        const node = `
      <div slot="widget" class="tradeXconfig" style="${windowStyle}">
      </div>
    `;
        return node;
    }
    #update = true;
    constructor(widgets, config) {
        super(widgets, config);
    }
    destroy() {
        super.destroy();
        this.elColourPicker.destroy();
    }
    set update(u) { this.#update = !!u; }
    get update() { return this.#update; }
    configBuild(contObj = {}) {
        let { content, modifiers = {} } = this.configContent(contObj);
        const tabsHTML = `
    <div class="tabbedContent">
      <form class="tabs">
        ${tabsBuild(content)}
      </form>
    </div>
    `;
        const { html, modifiers: mods } = super.dialogueBuild(tabsHTML);
        modifiers = { ...modifiers, ...mods };
        return { html, modifiers };
    }
    configContent(cfgObj) {
        if (!isObject(cfgObj))
            return `<p>Config content missing!</p>`;
        let obj;
        let content = {};
        let modifierList = {};
        for (let i in cfgObj) {
            content[i] = "";
            if (isArray(cfgObj[i])) {
                for (let j of cfgObj[i]) {
                    for (let k in j.style) {
                        obj = j.style[k];
                        if (!isObject(obj))
                            continue;
                        this.configEntryFields(i, obj, content, modifierList);
                    }
                }
            }
            else if (isObject(cfgObj[i])) {
                content[i] = "";
                for (let j in cfgObj[i]) {
                    obj = cfgObj[i][j];
                    this.configEntryFields(i, obj, content, modifierList);
                }
            }
            else {
                this.core.error(`ERROR: Building Config Dialogue : Input malformed`);
                continue;
            }
        }
        return { content, modifiers: modifierList };
    }
    configEntryFields(i, input, content, modifierList) {
        let id = (isString(input.entry)) ? input.entry : "";
        let label = (isString(input.label)) ? input.label : id;
        switch (input.type) {
            case "select":
                content[i] += htmlSelect(label, input);
                break;
            default:
                content[i] += htmlInput(label, input);
                break;
        }
        modifierList[id] = input["$function"];
    }
    contentUpdate(update) {
        if (!isObject(update))
            return false;
        if (isString(update?.title))
            this.setTitle(update.title);
        if (isString(update?.content))
            this.setContent(this.configBuild(update.content));
        this.#update = true;
        return this.#update;
    }
    provideInputColor(el, selector) {
        const input = el.querySelector(selector);
        const colourInput = document.createElement("tradex-colourinput");
        input.type = "text";
        input.pattern = RGBAHex;
        colourInput.setTarget(input);
        colourInput.style.display = "inline-block";
    }
}

class ColourPicker extends Dialogue {
    static { this.Name = "ColourPicker"; }
    static { this.type = "colourPicker"; }
    static { this.class = "tradeXcolourPicker"; }
    static { this.defaultStyles = `
  /** default Colour Picker widget styles */

  .tradeXwindow.picker {
    overflow: hidden;
  }

  .tradeXwindow.picker .content {
    padding: 0;
  }
  `; }
    static create(widgets, config) {
        config.dragBar = true;
        config.close = true;
        config.type = ColourPicker.type;
        config.class = "picker";
        config.id = uid("picker");
        return new ColourPicker(widgets, config);
    }
    static defaultNode() {
        const windowStyle = ``;
        const node = `
      <div slot="widget" class="tradeXcolourPicker" style="${windowStyle}">
      </div>
    `;
        return node;
    }
    #update = true;
    #elColourPicker;
    constructor(widgets, config) {
        super(widgets, config);
    }
    destroy() {
        super.destroy();
    }
    set update(u) { this.#update = !!u; }
    get update() { return this.#update; }
    get elColourPicker() { return this.#elColourPicker; }
    start() {
        const element = document.createElement("tradex-colourpicker");
        this.elContent.appendChild(element);
        this.#elColourPicker = element;
    }
    open(data = {}) {
        this.#elColourPicker.colour = data?.params?.colour;
        super.open(data);
    }
}

class Progress {
    static { this.progressList = {}; }
    static { this.progressCnt = 0; }
    static { this.class = CLASS_PROGRESS; }
    static { this.type = "progress"; }
    static { this.Name = "Progress"; }
    static { this.icons = {
        loadingBars,
        loadingSpin
    }; }
    static defaultNode() {
        const progressStyle = ``;
        const node = `
      <div slot="widget" class="${CLASS_PROGRESS}" style="${progressStyle}"></div>
    `;
        return node;
    }
    static create(widgets, config) {
        const id = `progress_${++Progress.progressCnt}`;
        config.id = id;
        Progress.progressList[id] = new Progress(widgets, config);
        return Progress.progressList[id];
    }
    static destroy(id) {
        Progress.progressList[id].destroy();
        delete Progress.progressList[id];
    }
    #id;
    #widgets;
    #core;
    #config;
    #elWidgetsG;
    #elProgress;
    #elProg;
    #elIcon;
    constructor(widgets, config) {
        this.#widgets = widgets;
        this.#core = config.core;
        this.#config = config;
        this.#id = config.id;
        this.#elProgress = widgets.elements[Progress.type];
        this.#elWidgetsG = this.#core.elWidgetsG;
        this.init();
    }
    destroy() {
        this.#elProgress.remove();
    }
    get type() { return Progress.type; }
    init() {
        this.mount(this.#elProgress);
    }
    start() {
        if (!isObject(this.#core.config?.progress) ||
            !isObject(this.#core.config.progress?.loading))
            return false;
        this.#elProg.style.display = "block";
        const x = (this.#core.elBody.width / 2) - (this.#elProg.clientWidth / 2);
        const y = (this.#core.elBody.height / -2) - (this.#elProg.clientHeight / 2);
        this.#elProg.style.top = `${y}px`;
        this.#elProg.style.left = `${x}px`;
    }
    stop() {
        this.#elProg.style.display = "none";
    }
    progressNode(p) {
        const progressStyle = `position: absolute; z-index: 1000; display: none; justify-content: center; align-items: center;`;
        const contentStyle = ``;
        const content = `<div class="content" style="${contentStyle}">${p.icon}</div>`;
        let node = `
      <div id="${this.#config.id}" class="progress ${p.type}" style="${progressStyle}">${content}</div>
    `;
        return node;
    }
    mount(el) {
        let type = "loadingBars";
        if (this.#config?.type in Progress.icons)
            type = this.#config?.type;
        const p = { type, icon: Progress.icons[type] };
        if (el.lastElementChild == null)
            el.innerHTML = this.progressNode(p);
        else
            el.lastElementChild.insertAdjacentHTML("afterend", this.progressNode(p));
        this.#elProg = this.#elProgress.querySelector(`#${this.#config.id}`);
        this.#elIcon = this.#elProg.querySelector(`svg`);
        this.#elIcon.style.fill = `${ProgressStyle.COLOUR_ICONHOVER};`;
    }
}

var stateMachineConfig = {
    id: "widgets",
    initial: "idle",
    context: {},
    states: {
        idle: {
            onEnter(data) {
            },
            onExit(data) {
            },
            on: {
                menu_open: {
                    target: 'menu_open',
                    action(data) {
                    },
                },
                window_open: {
                    target: 'window_open',
                    action(data) {
                    },
                },
            }
        },
        menu_open: {
            onEnter(data) {
            },
            onExit(data) {
            },
            on: {
                menu_close: {
                    target: "idle",
                    action(data) {
                    },
                },
            }
        },
        window_open: {
            onEnter(data) {
            },
            onExit(data) {
            },
            on: {
                window_close: {
                    target: "idle",
                    action(data) {
                    },
                },
            }
        },
    }
};

class Widgets extends Component {
    #name = "Widgets";
    #shortName = "widgets";
    #widgets;
    #widgetsList = { Divider, Progress, Menu, Window, Dialogue, ConfigDialogue };
    #widgetsInstances = {};
    #elements = {};
    #elWidgetsG;
    #width;
    #height;
    constructor(core, options) {
        super(core, options);
        this.#widgets = { ...this.#widgetsList, ...options.widgets };
        this.#elWidgetsG = core.elWidgetsG;
        this.mount(this.#elWidgetsG);
        for (let i in this.#widgets) {
            let widget = this.#widgets[i];
            let entry = `${widget.type}`;
            this.#elements[entry] = this.#elWidgetsG.querySelector(`.${widget.class}`);
            this.#elements[entry].innerHTML = `
      <style title="${widget.type}">
        ${widget?.defaultStyles || ""}
      </style>
      `;
            widget.stylesInstalled = true;
        }
    }
    get name() { return this.#name; }
    get shortName() { return this.#shortName; }
    get elements() { return this.#elements; }
    get instances() { return this.#widgetsInstances; }
    get types() { return this.#widgets; }
    start() {
        this.eventsListen();
        stateMachineConfig.id = this.id;
        stateMachineConfig.context = this;
        this.stateMachine = stateMachineConfig;
        this.stateMachine.start();
    }
    destroy() {
        this.core.hub.expunge(this);
        this.stateMachine.destroy();
        for (let i in this.#widgetsInstances) {
            this.delete(i);
        }
        for (let t in this.#widgets) {
            this.#widgets[t].destroy();
        }
    }
    eventsListen() {
        this.on("resize", this.onResize, this);
        this.on("menu_open", this.onOpenMenu, this);
        this.on("menu_close", this.onCloseMenu, this);
        this.on("menu_off", this.onCloseMenu, this);
        this.on("menuItem_selected", this.onMenuItemSelected, this);
        this.on("global_resize", this.onResize, this);
    }
    onOpenMenu(data) {
        this.#widgetsInstances[data.menu].open();
    }
    onCloseMenu(data) {
        this.#widgetsInstances[data.menu].close();
    }
    onMenuItemSelected(e) {
        this.emit(e.evt, e.target);
    }
    onResize(dimensions) {
        this.setDimensions(dimensions);
        this.elements.divider.style.width = `${this.core.width}px`;
    }
    mount(el) {
        el.innerHTML = this.defaultNode();
    }
    setWidth(w) {
        this.#width = w;
    }
    setHeight(h) {
        this.#height = h;
    }
    setDimensions(dimensions) {
        this.setWidth(dimensions.mainW);
        this.setHeight(dimensions.mainH);
    }
    defaultNode() {
        let nodes = ``, types = [];
        for (let i in this.#widgets) {
            let widget = this.#widgets[i];
            if (types.indexOf(widget.type) === -1) {
                nodes += widget.defaultNode();
                types.push(widget.type);
            }
        }
        return nodes;
    }
    insert(type, config) {
        if (!(type in this.#widgets) || !isObject(config))
            return false;
        config.core = this.core;
        const widget = this.#widgets[type].create(this, config);
        this.#widgetsInstances[widget.id] = widget;
        return widget;
    }
    delete(id) {
        if (!isString(id) || !(id in this.#widgetsInstances))
            return false;
        const type = this.#widgetsInstances[id].type;
        this.#widgets[type].destroy(id);
        return true;
    }
}

function exportImage(core, dest, type, quality, output, watermark) {
    const theme = core.theme;
    const time = core.Timeline.graph.viewport.scene;
    const main = core.MainPane;
    const mainScene = main.graph.viewport.scene;
    const width = main.width;
    const height = main.height;
    const container = document.createElement("div");
    container.setAttribute("width", width);
    container.setAttribute("height", height);
    const imgViewport = new CEL.Viewport({
        width: width,
        height: height,
        container: container
    });
    const ctx = imgViewport.scene.context;
    let y = 0;
    let x1 = 0;
    let x2 = width - core.Chart.scale.width;
    if (theme?.yAxis?.location == "left") {
        x1 = core.Chart.scale.width;
        x2 = 0;
    }
    let opts;
    ctx.save();
    renderRectFill(ctx, 0, 0, width, height, { fill: theme.chart.Background });
    ctx.drawImage(mainScene.canvas, x1, 0, mainScene.width, mainScene.height);
    for (const [key, value] of core.ChartPanes) {
        let scene = value.graph.viewport.scene;
        let { width, height } = scene;
        let scale = value.scale.graph.viewport.scene;
        let { width: w, height: h } = scale;
        if (y > 0) {
            opts = { stroke: theme.divider.line };
            renderLineHorizontal(ctx, y, 0, main.width, opts);
        }
        ctx.drawImage(scene.canvas, x1, y, width, height);
        ctx.drawImage(scale.canvas, x2, y - 1, w, h);
        y += height;
    }
    ctx.drawImage(time.canvas, 0, y, time.width, time.height);
    opts = {
        text: core.config.title,
        colour: theme.chart.TextColour,
        fontSize: theme.chart.FontSize * 1.5,
        fontWeight: "normal",
        fontFamily: theme.chart.FontFamily,
        textBaseLine: "top"
    };
    renderText(ctx, 6, 6, opts);
    const outputImage = (wm) => {
        if (wm) {
            const x = watermark?.x || 0;
            const y = watermark?.y || 0;
            const w = watermark?.width || width * 0.25;
            const h = watermark?.height || height * 0.25;
            ctx.drawImage(wm, x, y, w, h);
        }
        ctx.restore();
        const cleanUp = () => {
            imgViewport.destroy();
            container.remove();
        };
        switch (output) {
            case "url":
                if (isFunction(dest)) {
                    const cb = (r) => {
                        dest(r);
                        cleanUp();
                    };
                    imgViewport.scene.toImage(type, quality, cb);
                }
                else {
                    new Promise(function (resolve, reject) {
                        const url = imgViewport.scene.toImage(type, quality);
                        if (url)
                            resolve(url);
                        else
                            reject(false);
                        cleanUp();
                    });
                }
                break;
            case "download":
            default:
                imgViewport.scene.export({ fileName: dest }, null, type, quality);
                cleanUp();
                break;
        }
    };
    if (isObject(watermark)) {
        isImage(watermark?.imgURL).then((r) => {
            outputImage(r);
        }).catch((e) => {
            console.error(e);
        });
    }
    else {
        outputImage();
    }
}

class TradeXchart extends tradeXChart {
    static #version = version;
    static #cnt = 0;
    static #cfg = {};
    static #instances = {};
    static #talib = null;
    static #talibPromise = null;
    static #talibReady = false;
    static #talibAwait = [];
    static #talibError = null;
    static #TALibWorker = null;
    static #TALibWorkerReady = false;
    static get version() { return TradeXchart.#version; }
    static get default() { return doStructuredClone(defaultConfig); }
    static get talib() { return TradeXchart.#talibPromise; }
    static get talibPromise() { return TradeXchart.#talibPromise; }
    static get talibReady() { return TradeXchart.#talibReady; }
    static get talibAwait() { return TradeXchart.#talibAwait; }
    static get talibError() { return TradeXchart.#talibError; }
    static get webWorkers() { return WebWorker; }
    static get TALibWorker() { return TradeXchart.#TALibWorker; }
    static #initErrMsg = `${NAME} requires "talib-web" to function properly. Without it, some features maybe missing or broken.`;
    static #permittedClassNames = ["TradeXchart", "Chart", "MainPane", "Secondary", "Primary",
        "ScaleBar", "Timeline", "ToolsBar", "UtilsBar", "Widgets"];
    #key;
    #name;
    #shortName;
    #core;
    #txCfg;
    #config;
    #options;
    #ready;
    #inCnt;
    #state;
    #stateClass;
    #indicators;
    #indicatorsPublic;
    #overlaysDefault;
    #overlaysOptional;
    #overlaysCustom;
    #TALib;
    #theme;
    #UtilsBar;
    #ToolsBar;
    #MainPane;
    #WidgetsG;
    #scrollPos;
    #smoothScrollOffset;
    #pointerPos;
    #pointerButtons;
    #progress;
    #workers;
    #stream;
    #candles;
    #pricePrecision;
    #volumePrecision;
    #delayedSetRange;
    #mergingData;
    #toolbox;
    static create(cfg = TradeXchart.default) {
        let txCfg = TradeXchart.default;
        if (isObject(cfg) && Object.keys(cfg).length > 0) {
            if (!("watermark" in cfg) ||
                (!isString(cfg?.watermark?.text) &&
                    !("imgURL" in cfg?.watermark)))
                txCfg.watermark = { display: false };
            txCfg = mergeDeep(txCfg, cfg);
        }
        if (TradeXchart.#cnt == 0) {
            TradeXchart.#cfg.CPUCores = navigator.hardwareConcurrency;
            TradeXchart.#cfg.api = {
                permittedClassNames: TradeXchart.#permittedClassNames,
            };
        }
        if (isObject(txCfg?.talib) &&
            TradeXchart.isTalibInstantiated(txCfg.talib)) {
            TradeXchart.#talibReady = true;
        }
        else if (!TradeXchart.#talibReady &&
            TradeXchart.#talibError === null) {
            if (isPromise(txCfg?.talib))
                TradeXchart.#talibPromise = txCfg.talib;
            else if (isFunction(txCfg?.talib?.init))
                TradeXchart.#talibPromise = txCfg.talib.init(txCfg.wasm);
            else
                return txCfg;
            TradeXchart.#talibPromise.then((r) => {
                TradeXchart.#talibReady = true;
                TradeXchart.#talib = r;
                for (let c of TradeXchart.#talibAwait) {
                    if (isFunction(c))
                        c();
                }
            }, () => { TradeXchart.#talibReady = false; });
        }
        return txCfg;
    }
    static destroy(chart) {
        if (!(chart instanceof TradeXchart))
            return false;
        const inCnt = chart.inCnt;
        chart.destruction = true;
        chart.destroy();
        delete TradeXchart.#instances[inCnt];
        return true;
    }
    static cnt() {
        return TradeXchart.#cnt++;
    }
    static isTalibInstantiated(talib) {
        let result = false;
        return result;
    }
    constructor() {
        super();
        this.#key = uid();
        this.#name = NAME;
        this.#shortName = SHORTNAME;
        this.#ready = false;
        this.#indicators = IndicatorClasses;
        this.#indicatorsPublic = indicators;
        this.#overlaysDefault = { ...OVERLAYPANES };
        this.#overlaysOptional = { ...OVERLAYPANES };
        this.#overlaysCustom = { ...OVERLAYPANES };
        this.chartWMin = CHART_MINW;
        this.chartHMin = CHART_MINH;
        this.chartW_Reactive = true;
        this.chartH_Reactive = true;
        this.chartBGColour = GlobalStyle.COLOUR_BG;
        this.chartTxtColour = GlobalStyle.COLOUR_TXT;
        this.chartBorderColour = GlobalStyle.COLOUR_BORDER;
        this.#MainPane = {
            chart: {},
            time: {}
        };
        this.panes = {
            utils: this.#UtilsBar,
            tools: this.#ToolsBar,
            main: this.#MainPane,
        };
        this.destruction = false;
        this.logs = false;
        this.infos = false;
        this.warnings = false;
        this.errors = false;
        this.timers = false;
        this.#scrollPos = 0;
        this.#smoothScrollOffset = 0;
        this.#pointerPos = { x: 0, y: 0 };
        this.#pointerButtons = [false, false, false];
        this.#delayedSetRange = false;
        this.#mergingData = false;
        this.#core = this;
        this.#inCnt = TradeXchart.cnt();
        this.logs = false;
        this.infos = false;
        this.warnings = false;
        this.errors = false;
        this.timers = false;
        this.setID(null);
        this.#stateClass = State;
        this.#toolbox = new Toolbox(this);
        this.warn(`!WARNING!: ${NAME} changes to config format, for details please refer to https://github.com/tradex-app/TradeX-chart/blob/master/docs/notices.md`);
        this.log(`${SHORTNAME} instance count: ${this.inCnt}`);
        this.oncontextmenu = window.oncontextmenu;
        this.#workers = WebWorker;
        const so = this.#overlaysDefault;
        so.primaryPane = { ...so.primaryPane, ...standardOverlays.primaryPane };
        this.#overlaysOptional = { ...optionalOverlays };
    }
    log(...l) { if (this.logs)
        console.log(...l); }
    info(...i) { if (this.infos)
        console.info(...i); }
    warn(...w) { if (this.warnings)
        console.warn(...w); }
    error(e) { if (this.errors)
        console.error(e); }
    timer(n) { if (this.timers)
        console.time(n); }
    timeLog(n) { if (this.timers)
        console.timeLog(n); }
    timeEnd(n) { if (this.timers)
        console.timeEnd(n); }
    get version() { return TradeXchart.version; }
    get name() { return this.#name; }
    get shortName() { return this.#shortName; }
    get key() { return this.#key; }
    get options() { return this.#options; }
    get config() { return this.#config; }
    get core() { return this.#core; }
    get inCnt() { return this.#inCnt; }
    get txCfg() { return this.#txCfg; }
    get elUtils() { return super.elUtils; }
    get elTools() { return super.elTools; }
    get elBody() { return super.elBody; }
    get elMain() { return super.elMain; }
    get elRows() { return super.elRows; }
    get elTime() { return super.elTime; }
    get elYAxis() { return super.elYAxis; }
    get elWidgetsG() { return super.elWidgets; }
    get UtilsBar() { return this.#UtilsBar; }
    get ToolsBar() { return this.#ToolsBar; }
    get MainPane() { return this.#MainPane; }
    get Timeline() { return this.#MainPane.time; }
    get WidgetsG() { return this.#WidgetsG; }
    get Chart() { return this.#MainPane.chart; }
    get ChartPanes() { return this.#MainPane.chartPanes; }
    get Indicators() { return this.#MainPane.indicators; }
    get Tools() { return this.#toolbox; }
    get ready() { return this.#ready; }
    get stateClass() { return this.#stateClass; }
    get state() { return this.#stateClass?.active(this); }
    get allData() {
        return {
            data: this.state.data.chart.data,
            primaryPane: this.state.data.primary,
            secondaryPane: this.state.data.secondary,
            datasets: this.state.data.datasets
        };
    }
    get rangeLimit() { return (isNumber(this.range.initialCnt)) ? this.range.initialCnt : RANGELIMIT; }
    get range() { return this.state.range; }
    get time() { return this.state.time; }
    get timeData() { return this.state.time; }
    get TimeUtils() { return Time; }
    get theme() { return this.#theme; }
    get settings() { return this.state.data.chart.settings; }
    get indicatorClasses() { return this.#indicators; }
    get indicatorsPublic() { return this.#indicatorsPublic; }
    get TALib() { return this.#TALib; }
    get TALibReady() { return TradeXchart.talibReady; }
    get TALibError() { return TradeXchart.talibError; }
    get talibAwait() { return TradeXchart.talibAwait; }
    get TALibPromise() { return TradeXchart.talibPromise; }
    get candleW() { return this.Timeline.candleW; }
    get candlesOnLayer() { return this.Timeline.candlesOnLayer; }
    get buffer() { return this.MainPane.buffer; }
    get bufferPx() { return this.MainPane.bufferPx; }
    set scrollPos(pos) { this.setScrollPos(pos); }
    get scrollPos() { return this.#scrollPos; }
    get smoothScrollOffset() { return 0; }
    get rangeScrollOffset() { return Math.floor(this.bufferPx / this.candleW); }
    get mousePos() { return this.#pointerPos; }
    get pointerButtons() { return this.#pointerButtons; }
    get symbol() { return this.state?.symbol; }
    get timeFrame() { return this.range.interval; }
    get timeFrameStr() { return this.range.intervalStr; }
    get interval() { return this.range.interval; }
    get intervalStr() { return this.range.intervalStr; }
    set pricePrecision(p) { this.setPricePrecision(p); }
    get pricePrecision() { return this.#pricePrecision || PRICE_PRECISION; }
    get volumePrecision() { return this.#volumePrecision; }
    get stream() { return this.state.dataSource.stream; }
    get worker() { return this.#workers; }
    get isEmpty() { return this.state.isEmpty; }
    get isStreaming() { return this.state.dataSource.stream.isActive; }
    set candles(c) { if (isObject(c))
        this.#candles = c; }
    get candles() { return this.#candles; }
    get progress() { return this.#progress; }
    get overlays() { return this.overlaysList(); }
    get overlaysDefault() { return this.#overlaysDefault; }
    get overlaysOptional() { return this.#overlaysOptional; }
    get overlaysCustom() { return this.#overlaysCustom; }
    start(cfg = TradeXchart.default) {
        this.log(`${NAME} configuring...`);
        if (this.#ready)
            this.#MainPane.destroy();
        const oldID = this.ID;
        const txCfg = TradeXchart.create(cfg);
        this.#txCfg = txCfg;
        this.logs = (txCfg?.logs) ? txCfg.logs : null;
        this.infos = (txCfg?.infos) ? txCfg.infos : null;
        this.warnings = (txCfg?.warnings) ? txCfg.warnings : null;
        this.errors = (txCfg?.errors) ? txCfg.errors : null;
        this.timers = (txCfg?.timer) ? txCfg.timer : null;
        this.#config = txCfg;
        this.#inCnt = txCfg.cnt || this.#inCnt;
        this.#TALib = txCfg.talib;
        this.props(txCfg);
        this.log("processing state...");
        let deepValidate = txCfg?.deepValidate || false;
        let isCrypto = txCfg?.isCrypto || false;
        let state = txCfg.state;
        if (!(txCfg.state instanceof State))
            state = this.configureState(txCfg);
        if (this.#ready) {
            if (!(state instanceof State)) {
                const newState = this.#stateClass.create(this, state, deepValidate, isCrypto);
                this.#stateClass.use(this, newState.key);
                this.#stateClass.delete(this, { id: initialEmptyState });
            }
            delete txCfg.state;
            this.#MainPane = new MainPane(this, txCfg);
            this.MainPane.start();
            document.querySelector(`style[title="${oldID}_style"]`)?.remove();
            this.setUtilsLocation(this.theme?.utils?.location);
            this.elBody.setToolsLocation(this.theme?.tools?.location);
            this.log(`${this.name} id: ${this.ID} : loaded a new ${this.state.status} state`);
        }
        else {
            txCfg.watermark.display = true;
            state.id = initialEmptyState;
            let newState = this.#stateClass.create(this, state, deepValidate, isCrypto);
            this.#stateClass.use(this, newState.key);
            delete txCfg.state;
            this.log(`${this.name} id: ${this.ID} : created with a ${this.state.status} state`);
            this.#WidgetsG = new Widgets(this, { widgets: txCfg?.widgets });
            this.#UtilsBar = new UtilsBar(this, txCfg);
            this.#ToolsBar = new ToolsBar(this, txCfg);
            this.#MainPane = new MainPane(this, txCfg);
            this.eventsListen();
            this.elStart(this.theme);
            this.elBody.start(this.theme);
            this.UtilsBar.start();
            this.ToolsBar.start();
            this.MainPane.start();
            this.WidgetsG.start();
            this.#progress = this.WidgetsG.insert("Progress", {});
        }
        this.insertAdjacentHTML('beforebegin', `<style title="${this.ID}_style"></style>`);
        this.setTheme(this.#theme.id);
        this.Tools.static.register();
        this.#scrollPos = this.bufferPx * -1;
        if (!isObject(txCfg?.stream) && this.state.data.chart.data.length < 2) {
            this.warn(`${NAME} has no chart data or streaming provided.`);
        }
        else if (isObject(txCfg?.stream) && this.state.data.chart.data.length < 2) {
            this.#delayedSetRange = true;
        }
        this.log(`Time Frame: ${this.range.timeFrame} Milliseconds: ${this.range.timeFrameMS}`);
        if (this.#delayedSetRange)
            this.on(STREAM_UPDATE, this.delayedSetRange, this);
        this.#config.callbacks = this.#config.callbacks || {};
        this.#ready = true;
        setTimeout(this.refresh.bind(this), 1000);
        this.log(`${this.#name} V${TradeXchart.version} configured and running...`);
        this.emit("chart_started");
    }
    use(cfg) {
        this.start(cfg);
    }
    destroy() {
        if (this?.destuction !== true) {
            TradeXchart.destroy(this);
            return true;
        }
        this.log("...cleanup the mess");
        this.removeEventListener('mousemove', this.onMouseMove);
        this.hub.expunge(this);
        this.UtilsBar.destroy();
        this.ToolsBar.destroy();
        this.MainPane.destroy();
        this.WidgetsG.destroy();
        this.#workers.end();
        this.#state;
        this.#stateClass;
    }
    configureState(txCfg) {
        let state = doStructuredClone(txCfg?.state) || {};
        state.id = this.ID;
        state.core = this;
        let { tf, ms } = (!!interval2MS(txCfg?.timeFrame)) ?
            isTimeFrame(txCfg.timeFrame) :
            { tf: DEFAULT_TIMEFRAME,
                ms: DEFAULT_TIMEFRAMEMS
            };
        let ts = Date.now();
        ts = ts - (ts % ms);
        if (!isObject(txCfg?.range)) {
            txCfg.range = {
                startTS: ts,
                timeFrame: tf,
                timeFrameMS: ms
            };
        }
        else {
            let r = txCfg?.range;
            if (!isInteger(r.startTS))
                r.startTS = ts;
            if (!isInteger(r.timeFrameMS))
                r.timeFrameMS = ms;
            if (interval2MS(r.timeFrame) != r.timeFrameMS)
                r.timeFrame = ms2Interval(ms);
        }
        state.range = { ...state.range, ...txCfg.range };
        return state;
    }
    eventsListen() {
        this.addEventListener('mousemove', this.onMouseMove.bind(this));
        this.on(STREAM_UPDATE, this.onStreamUpdate, this);
        this.on("state_mergeComplete", () => this.#progress.stop());
    }
    onMouseMove(e) {
        this.#pointerPos.x = e.clientX;
        this.#pointerPos.y = e.clientY;
    }
    onStreamUpdate(candle) {
        const r = this.range;
        if (r.inRange(candle[0])) {
            const max = r.valueMax;
            const min = r.valueMin;
            if (candle[2] > max || candle[3] < min) {
                this.setRange(r.indexStart, r.indexEnd);
                this.emit("chart_yAxisRedraw", this.range);
            }
        }
    }
    props(txCfg) {
        let entries = {
            width: (width) => this.setWidth(width),
            height: (height) => this.setHeight(height),
            widthMin: (width) => this.setWidthMin(width),
            heightMin: (height) => this.setHeightMin(height),
            widthMax: (width) => this.setWidthMax(width),
            heightMax: (height) => this.setHeightMax(height),
            logs: (logs) => this.logs = (isBoolean(logs)) ? logs : false,
            infos: (infos) => this.infos = (isBoolean(infos)) ? infos : false,
            warnings: (warnings) => this.warnings = (isBoolean(warnings)) ? warnings : false,
            errors: (errors) => this.errors = (isBoolean(errors)) ? errors : false,
            indicators: (indicators) => this.setIndicators(indicators),
            theme: (theme) => { this.#theme = this.addTheme(theme); },
            stream: (stream) => this.#stream = (isObject(stream)) ? stream : {},
            pricePrecision: (pricePrecision) => this.setPricePrecision(pricePrecision),
            volumePrecision: (precision) => this.setVolumePrecision(precision),
        };
        if (isObject(txCfg)) {
            for (const option in txCfg) {
                if (option in entries) {
                    entries[option](txCfg[option]);
                }
            }
        }
        this.validateID(txCfg);
        if (!("theme" in txCfg) || !isObject(txCfg.theme))
            txCfg.theme = defaultTheme;
    }
    getInCnt() { return this.#inCnt; }
    validateID(txCfg) {
        const id = String(txCfg?.id);
        this.setID(id);
        this.classList.add(this.ID);
    }
    setID(id) {
        if (isString(id))
            this.ID = id;
        else
            this.ID = `${uid(SHORTNAME)}_${this.#inCnt}`;
    }
    setTitle(t) {
        this.Chart.setTitle(String(t));
        return true;
    }
    setWatermark(w) {
        if (isString(w.text) || isString(w))
            this.core.config.watermark.text = w;
        else if ("imgURL" in w)
            this.core.config.watermark.imgURL = w;
        this.Chart.setWatermark(w);
    }
    setDimensions(w, h) {
        const dims = super.setDimensions(w, h);
        this.emit("global_resize", dims);
    }
    setUtilsH(h) {
        this.elUtils.style.height = `${h}px`;
    }
    setToolsW(w) {
        this.elTools.style.width = `${w}px`;
    }
    setPricePrecision(pricePrecision) {
        if (!isNumber(pricePrecision) || pricePrecision < 0) {
            pricePrecision = PRICE_PRECISION;
        }
        this.#pricePrecision = pricePrecision;
    }
    setVolumePrecision(volumePrecision) {
        if (!isNumber(volumePrecision) || volumePrecision < 0) {
            volumePrecision = VOLUME_PRECISION;
        }
        this.#volumePrecision = volumePrecision;
    }
    addTheme(theme) {
        const t = Theme.create(theme, this);
        if (!(this.#theme instanceof Theme))
            this.#theme = t;
        return t;
    }
    setTheme(ID) {
        if (!this.theme.list.has(ID))
            return false;
        this.#theme.setTheme(ID, this);
        const theme = this.#theme;
        const style = document.querySelector(`style[title=${this.ID}_style]`);
        const borderColour = `var(--txc-border-color, ${theme.chart.BorderColour}`;
        let innerHTML = `.${this.ID} { `;
        innerHTML += `--txc-background: ${theme.chart.Background}; `;
        this.style.background = `var(--txc-background, ${theme.chart.Background})`;
        this.style.border = `${theme.chart.BorderThickness || 0}px solid`;
        this.style.borderColor = borderColour;
        innerHTML += `--txc-border-color:  ${theme.chart.BorderColour}; `;
        if (theme.chart.BorderThickness > 0) {
            this.elMain.rows.style.border = `1px solid ${borderColour}`;
        }
        else {
            this.elMain.rows.style.border = `none`;
        }
        innerHTML += `--txc-time-scrollbar-color: ${theme.chart.BorderColour}; `;
        innerHTML += `--txc-time-handle-color: ${theme.xAxis.handle}; `;
        innerHTML += `--txc-time-slider-color: ${theme.xAxis.slider}; `;
        innerHTML += `--txc-time-cursor-fore: ${theme.xAxis.colourCursor}; `;
        innerHTML += `--txc-time-cursor-back: ${theme.xAxis.colourCursorBG}; `;
        innerHTML += `--txc-time-icon-color: ${theme.icon.colour}; `;
        innerHTML += `--txc-time-icon-hover-color: ${theme.icon.hover}; `;
        this.elTime.overview.scrollBar.style.borderColor = borderColour;
        this.elTime.overview.handle.style.backgroundColor = `var(--txc-time-handle-color, ${theme.xAxis.handle})`;
        this.elTime.overview.style.setProperty("--txc-time-slider-color", theme.xAxis.slider);
        this.elTime.overview.style.setProperty("--txc-time-icon-color", theme.icon.colour);
        this.elTime.overview.style.setProperty("--txc-time-icon-hover-color", theme.icon.hover);
        if (this.Chart instanceof Chart) {
            for (let [key, legend] of Object.entries(this.Chart.legend.list)) {
                legend.el.style.color = `var(--txc-legend-color, ${theme.legend.colour})`;
                legend.el.style.font = `var(--txc-legend-font, ${theme.legend.font})`;
            }
        }
        for (let t of this.elUtils.icons) {
            if (t.className != "icon-wrapper")
                continue;
            t.children[0].style.fill = theme.icon.colour;
        }
        for (let t of this.elTools.icons) {
            if (t.className != "icon-wrapper")
                continue;
            t.children[0].style.fill = theme.icon.colour;
        }
        innerHTML += ` }`;
        style.innerHTML = innerHTML;
        return true;
    }
    setScrollPos(pos) {
        pos = Math.round(pos);
        if (isNumber(pos) && pos <= 0 && pos >= this.bufferPx * -1)
            this.#scrollPos = pos;
        else {
            this.emit("Error", `setScrollPos: not a valid value`);
        }
    }
    createState(state, deepValidate, isCrypto) {
        return this.stateClass.create(this, state, deepValidate, isCrypto);
    }
    deleteState(key) {
        let r = this.stateClass.delete(this, key);
        if (!r)
            return false;
        this.emit("state_deleted", key);
        return true;
    }
    exportState(key = this.state.key, config = {}) {
        let r = this.stateClass.export(this, key, config);
        if (!r)
            return false;
        this.emit("state_exported", key);
        return r;
    }
    startStream() {
        if (this.stream instanceof Stream) {
            this.stream.start();
        }
    }
    stopStream() {
        if (this.stream instanceof Stream) {
            this.stream.stop();
        }
    }
    delayedSetRange() {
        while (this.#delayedSetRange) {
            let l = Math.floor(this.range.initialCnt * 0.5);
            this.setRange(l * -1, l);
            this.off(STREAM_UPDATE, this.delayedSetRange, this);
            this.#delayedSetRange = false;
        }
    }
    updateRange(pos) {
        if (!isArray(pos) || !isNumber(pos[4]) || pos[4] == 0)
            return;
        if (pos[4] < 0 && this.range.isPastLimit())
            return;
        if (pos[4] > 0 && this.range.isFutureLimit())
            return;
        let dist, scrollPos;
        dist = pos[4];
        scrollPos = this.#scrollPos + dist;
        scrollPos % this.candleW;
        if (scrollPos < this.bufferPx * -1) {
            let r = this.offsetRange(this.rangeScrollOffset * -1);
            if (!r)
                return;
            scrollPos = 0;
        }
        else if (scrollPos > 0) {
            let r = this.offsetRange(this.rangeScrollOffset);
            if (!r)
                return;
            scrollPos = this.bufferPx * -1;
        }
        this.#scrollPos = scrollPos;
        this.emit("chart_scrollUpdate", scrollPos);
    }
    offsetRange(offset) {
        let start = this.range.indexStart - offset, end = this.range.indexEnd - offset;
        if (this.range.isPastLimit(start) ||
            this.range.isFutureLimit(end))
            return false;
        this.setRange(start, end);
        return true;
    }
    setRange(start = 0, end = this.rangeLimit) {
        const max = (this.config?.maxCandles) ? this.config.maxCandles :
            (this.Chart?.layerWidth) ? this.Chart.layerWidth : this.Chart.width;
        this.range.set(start, end, max);
        this.state.gaps.fillRangeGaps();
        let startTS = (this.range.indexStartTS < this.range.timeStart) ?
            this.range.timeStart :
            this.range.indexStartTS;
        let endTS = (this.range.indexEndTS > this.range.timeFinish) ?
            this.range.timeFinish :
            this.range.indexEndTS;
        let e = { chart: this, start, end, startTS, endTS };
        if (start < 0 && !this.#mergingData)
            this.emit("range_limitPast", e);
        else if (end > this.range.dataLength && !this.#mergingData)
            this.emit("range_limitFuture", e);
        let gaps = this.state.gaps.findGapsInTimeSpan();
        if (!gaps.length)
            return;
        else {
            e.startTS = gaps[0];
            e.endTS = gaps[gaps.length - 1];
            e.start = this.range.getTimeIndex(gaps[0]);
            e.end = this.range.getTimeIndex(gaps[gaps.length - 1]);
            if (isFunction(this.state.dataSource.source.rangeLimitPast))
                this.emit("range_limitPast", e);
            else if (isFunction(this.state.dataSource.source.rangeLimitFuture))
                this.emit("range_limitFuture", e);
            else
                return;
        }
    }
    jumpToIndex(start, limited = true, center = true) {
        if (limited)
            start = limit(start, 0, this.range.dataLength);
        let length = this.range.Length;
        let end = start + length;
        if (center) {
            start -= length / 2;
            end -= length / 2;
        }
        this.setRange(start, end);
    }
    jumpToTS(ts, limited = true, center = true) {
        let start = this.Timeline.xAxis.t2Index(ts);
        this.jumpToIndex(start, limited, center);
    }
    jumpToStart(center = false) {
        this.jumpToIndex(0, true, center);
    }
    jumpToEnd(center = true) {
        let end = this.range.dataLength - this.range.Length;
        if (center)
            end += Math.round(this.range.Length / 2);
        this.jumpToIndex(end + 1, true, false);
    }
    mergeData(merge, newRange = false, calc = false) {
        this.#mergingData = true;
        let m = this.state.mergeData(merge, newRange, calc);
        if (isBoolean(m))
            this.#mergingData = false;
        return m;
    }
    isOverlay(o) {
        return (isClass(o) &&
            isFunction(o.prototype?.draw) &&
            !this.isIndicator(o) &&
            Object.getPrototypeOf(o.prototype).constructor.isOverlay);
    }
    hasOverlay(o) {
        const e = this.overlayEntries();
        if (!Object.keys(e).includes(o))
            return false;
        return e[o];
    }
    overlaysList(by) {
        switch (by) {
            case "all":
                return {
                    ...this.overlayEntries(),
                    ...this.indicatorClasses,
                    ...this.ToolsBar.overlays
                };
            case "type":
            default:
                return {
                    standard: { ...this.overlayEntries() },
                    indicators: { ...this.indicatorClasses },
                    tools: { ...this.ToolsBar.overlays }
                };
        }
    }
    overlayKeys() {
        return Object.keys(this.overlayEntries());
    }
    overlayEntries() {
        let e = {};
        function merge(c) {
            for (let p in c) {
                e = { ...e, ...c[p] };
            }
        }
        merge(this.#overlaysDefault);
        merge(this.#overlaysOptional);
        merge(this.#overlaysCustom);
        return e;
    }
    setCustomOverlays(o) {
        if (!isObject(o))
            return false;
        const result = {};
        for (const [k, v] of Object.entries(o)) {
            if (isObject(v) &&
                this.isOverlay(v?.class) &&
                Object.keys(this.#overlaysCustom).includes(v?.location)) {
                this.#overlaysCustom[v.location][k] = v;
                result[k] = true;
                this.log(`Custom Overlay: ${k} - Registered`);
            }
            else {
                result[k] = false;
                this.log(`Custom Overlay: ${k} - Rejected: Not a valid Overlay`);
            }
        }
        return result;
    }
    addOverlay(key, targetID) {
        let result;
        const target = this.findOverlayInGraph(key, targetID);
        if (!target)
            result = target;
        else {
            try {
                const { overlay, graph } = { ...target };
                result = graph.addOverlay(key, overlay);
                this.log(`Overlay: ${key} - Added to ${targetID}`);
                return result;
            }
            catch (error) {
                this.error(`Overlay: ${key} - Error attempting to add overlay to ${targetID}`);
                this.error(error);
                return null;
            }
        }
    }
    removeOverlay(key, targetID) {
        let result;
        const target = this.findOverlayInGraph(key, targetID);
        if (!target)
            result = target;
        else {
            const { overlay, graph } = { ...target };
            result = graph.removeOverlay(key);
        }
        if (!result) {
            this.error(`Overlay: ${key} - Error attempting to remove overlay from ${targetID}`);
            return false;
        }
        else {
            this.log(`Overlay: ${key} - Removed from ${targetID}`);
            return true;
        }
    }
    findGraph(targetID) {
        switch (targetID) {
            case "mainPane": return this.MainPane.graph;
            case "chartPane": return this.Chart.graph;
            case "chartScale": return this.Chart.scale.graph;
            case "timeLine": return this.Chart.time.graph;
            default:
                const panes = Array.from(this.ChartPanes.keys());
                if (panes.includes(targetID)) {
                    return this.ChartPanes.get(targetID).graph;
                }
                else {
                    for (let p of panes) {
                        let scale = this.ChartPanes.get(targetID).scale;
                        if (scale.id == targetID) {
                            return scale.graph;
                        }
                    }
                    return false;
                }
        }
    }
    findOverlayInGraph(key, targetID) {
        const overlay = this.hasOverlay(String(key));
        if (!overlay)
            return false;
        const graph = this.findGraph(String(targetID));
        if (!graph)
            return false;
        return { overlay, graph };
    }
    isIndicator(i) {
        return (isClass(i) &&
            isFunction(i.prototype?.draw) &&
            "primaryPane" in i.prototype &&
            !!i?.isIndicator);
    }
    setIndicators(i, flush = false) {
        if (!isObject(i))
            return false;
        if (flush) {
            console.warn(`Expunging all default indicators!`);
            this.#indicators = {};
        }
        const result = {};
        for (const [k, v] of Object.entries(i)) {
            if (isString(v?.id) &&
                isString(v?.name) &&
                isString(v?.event) &&
                this.isIndicator(v?.ind)) {
                this.indicatorDefinitionDefaults(v);
                if (!!v?.public)
                    this.#indicatorsPublic[k] = v;
                this.#indicators[k] = v.ind;
                result[k] = true;
                this.log(`Custom Indicator: ${k} - Registered`);
            }
            else {
                result[k] = false;
                this.warn(`Custom Indicator: ${k} - Rejected: Not a valid indicator`);
            }
        }
        return result;
    }
    addIndicator(i, name = i, params = {}) {
        const r = this.#MainPane.addIndicator(i, name, params);
        if (!r)
            this.error(`Indicator: ${i} - Error failed to add indicator`);
        return i;
    }
    getIndicator(i) {
        return this.#MainPane.getIndicator(i);
    }
    getIndicatorsByType(t) {
        return this.#MainPane.getIndicatorsByType(t);
    }
    removeIndicator(i) {
        const r = this.#MainPane.removeIndicator(i);
        if (!r)
            this.error(`Indicator: ${i} - Error failed to remove indicator`);
        return i;
    }
    indicatorSettings(i, s) {
        return this.#MainPane.indicatorSettings(i, s);
    }
    indicatorDefinitionDefaults(i) {
    }
    hasStateIndicator(i, dataset = "searchAll") {
        const find = function (i, d) {
            for (let e of d) {
                return (e?.id === i || e?.name === i) ? true : false;
            }
        };
        let r;
        if (dataset == "searchAll") {
            for (let d of this.allData) {
                if (find(i, d))
                    return true;
            }
            r = false;
        }
        else {
            if (dataset in this.allData) {
                r = find(i, d);
            }
        }
        return r;
    }
    async calcAllIndicators(update) {
        const indicators = [];
        const executeIndicator = (i) => {
            return new Promise(resolve => setTimeout(() => {
                resolve(i());
            }, 0));
        };
        for (const [key, value] of Object.entries(this.Indicators)) {
            for (const [k, ind] of Object.entries(value)) {
                indicators.push(ind.instance.calcIndicatorHistory.bind(ind.instance, update));
            }
        }
        await Promise.all(indicators.map(async (i) => {
            executeIndicator(i);
        }));
        this.refresh();
    }
    addTrade(t) {
        return this.state.addTrade(t);
    }
    removeTrade(t) {
        return this.state.removeTrade(t);
    }
    addEvent(e) {
        return this.state.addEvent(e);
    }
    removeEvent(e) {
        return this.state.removeEvent(e);
    }
    resize(width, height) {
        if (!isNumber(width) && !isNumber(height))
            return false;
        this.setDimensions(width, height);
        return true;
    }
    refresh() {
        if (!this.ready)
            return;
        this.#MainPane.refresh();
    }
    toImageURL(cb, type, quality, watermark) {
        return exportImage(this, cb, type, quality, "url", watermark);
    }
    downloadImage(fileName = `${this.ID}.png`, type, quality, watermark) {
        exportImage(this, fileName, type, quality, "download", watermark);
    }
    notImplemented() {
        if (!this.implemented) {
            let content = `
        This feature is not implemented yet.
      `;
            let config = {
                content,
                styles: {
                    content: { padding: "1em" }
                }
            };
            this.implemented = this.#WidgetsG.insert("Dialogue", config);
            this.implemented.start();
        }
        else
            this.implemented.open();
    }
}
if (!window.customElements.get('tradex-chart')) {
    document.head.insertAdjacentHTML("beforeend", cssVars);
    document.head.insertAdjacentHTML("beforeend", style);
    customElements.get('tradex-chart') || customElements.define('tradex-chart', TradeXchart);
}
function isChart(chart) {
    return chart instanceof TradeXchart;
}

const joinPoints = [
    "before", "after", "around", "afterReturning", "afterThrowing"
];
class Aspect {
    static add(aspect, target) {
        if (!(aspect instanceof Aspect))
            return false;
        if (isClass(target)) ;
        const proxy = new Proxy(target, {
            get: (target, property) => {
                if (typeof target[property] === 'function') {
                    return Aspect.intercept(aspect, target, property);
                }
                return target[property];
            },
        });
        return proxy;
    }
    static intercept(aspect, target, methodName) {
        const doAdvices = (advices, type, args) => {
            let cnt = 0, input, output = args;
            for (let advice of advices) {
                if (type == advice.type) {
                    cnt++;
                    input = (advice.transfer) ? output : args;
                    input = (advice.type == "afterReturning") ? advice.args : input;
                    output = advice.func.apply(target, input);
                }
            }
            output = (cnt > 0) ? output : undefined;
            return output;
        };
        return function (...args) {
            const joinPoint = `${methodName}`;
            const advices = aspect.advice[joinPoint];
            if (!advices)
                return target[methodName].apply(target, args);
            try {
                let output;
                output = doAdvices(advices, "replace", args);
                if (output !== undefined)
                    return output;
                output = doAdvices(advices, "before", args);
                if (aspect.transfer && output !== undefined)
                    args = output;
                const result = target[methodName].apply(target, args);
                if (aspect.transfer && result !== undefined)
                    args = result;
                output = doAdvices(advices, "after", args);
                if (aspect.transfer && output !== undefined)
                    args = result;
                output = doAdvices(advices, "around", { args, result });
                doAdvices(advices, "afterReturning", args);
                output = (output === undefined) ? result : output;
                return output;
            }
            catch (e) {
                doAdvices(advices, ["afterThrowing"], e);
                throw (e);
            }
        };
    }
    constructor(name, transfer = true) {
        this.name = name;
        this.advice = {};
        this.transfer = transfer;
    }
    before(joinPoint, advice, transfer, args) {
        this.#adviceType(joinPoint, advice, 'before', transfer, args);
    }
    after(joinPoint, advice, transfer, args) {
        this.#adviceType(joinPoint, advice, 'after', transfer, args);
    }
    around(joinPoint, advice, transfer, args) {
        this.#adviceType(joinPoint, advice, 'around', transfer, args);
    }
    afterReturning(joinPoint, advice, transfer, args) {
        this.#adviceType(joinPoint, advice, 'afterReturning', transfer, args);
    }
    afterThrowing(joinPoint, advice, transfer, args) {
        this.#adviceType(joinPoint, advice, 'afterThrowing', transfer, args);
    }
    #adviceType(joinPoint, advice, type, transfer = true, args = []) {
        if (typeof joinPoint != "string" ||
            typeof advice != "function" ||
            !Array.isArray(args) ||
            (joinPoints.includes(joinPoint)))
            return false;
        this.advice[joinPoint] = this.advice[joinPoint] || [];
        this.advice[joinPoint].push({ type, func: advice, args, transfer });
        return true;
    }
}

export { Aspect, TradeXchart as Chart, DEFAULT_STATE, DOM, EventHub, Indicator, IndicatorClasses, Overlay, Range, StateMachine, TimeData, YAXIS_PADDING, YAXIS_TYPE, YAXIS_TYPES, candleW, canvas, copyDeep, doStructuredClone, isChart, isPromise, mergeDeep, talibAPI, typeChecks, uid, utilities as utils };
